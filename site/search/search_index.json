{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"examples/01_hello_world/","text":"Hello World Expressions # Use expressions to evaluate values in Python. # -------------------------------------------------------------------------------- # An expression is anything that evaluates to a value. The following is true # for all expressions: # # - An expression always returns a value. # - Expressions can be used in statements (e.g. if, while, for). # - Expressions can be part of other expressions. 1 # Simple expression 1 + 2 + 3 # Arithmetic expression Hello World # Hello World # -------------------------------------------------------------------------------- # This simple program prints \"Hello world!\" and performs a basic # addition (1 + 1) to highlight Python's core syntax. print(\"Hello world!\") print(1 + 1) Modules # Use import to access python modules # -------------------------------------------------------------------------------- # A module is a file containing Python code. It can define functions, # classes, and variables that you can use in your code. You can import a # module using the `import` statement. import math from math import pi print(math.pi) print(pi) Print Statement # Use the print() function to output text to the console. # -------------------------------------------------------------------------------- # The print() function is used to output data to the screen. It can take # multiple arguments and will convert them to strings before printing them. # By default, print() ends with a newline character. print(\"Hello\") print(\"World\") # Output: # Hello # World # You can change this behavior by specifying the end parameter. print(\"Hello\", end=\"\") print(\"World\", end=\"\") # Output: # HelloWorld # A print statement with no arguments prints a newline character. print(\"Hello\", end=\"\") print() print(\"World\", end=\"\") # Output: # Hello # World # You can also specify the separator symbol print(\"Hello\", \"World\", sep=\"\") print(\"Hello\", \"World\", sep=\" \") print(\"Hello\", \"World\", sep=\", \") # Output: # HelloWorld # Hello World # Hello, World Statements # Use statements to perform actions in Python. # -------------------------------------------------------------------------------- # A statement is a piece of code that performs an action. It can be as simple # as a single line or a more complex block of code. The following is true # for all statements: # # - A statement does not return a value. # - Statements cannot be used in expressions (e.g. if, while, for). # - It is a standalone operation. # Valid statements x = 5 print(x) # Invalid statements # if (x = 5): # SyntaxError (statement cannot be used in an expression) Zen Of Python # Import the `this` module to print the Zen of Python # -------------------------------------------------------------------------------- # This is a fun Easter egg in Python that prints the Zen of Python, the # guiding principles for writing computer programs in Python. It emphasizes # simplicity, readability, and the importance of explicitness in code design. import this # Output: # The Zen of Python, by Tim Peters # # Beautiful is better than ugly. # Explicit is better than implicit. # Simple is better than complex. # Complex is better than complicated. # Flat is better than nested. # Sparse is better than dense. # Readability counts. # Special cases aren't special enough to break the rules. # Although practicality beats purity. # Errors should never pass silently. # Unless explicitly silenced. # In the face of ambiguity, refuse the temptation to guess. # There should be one-- and preferably only one --obvious way to do it. # Although that way may not be obvious at first unless you're Dutch. # Now is better than never. # Although never is often better than *right* now. # If the implementation is hard to explain, it's a bad idea. # If the implementation is easy to explain, it may be a good idea. # Namespaces are one honking great idea -- let's do more of those!","title":"Hello World"},{"location":"examples/01_hello_world/#hello-world","text":"","title":"Hello World"},{"location":"examples/01_hello_world/#expressions","text":"# Use expressions to evaluate values in Python. # -------------------------------------------------------------------------------- # An expression is anything that evaluates to a value. The following is true # for all expressions: # # - An expression always returns a value. # - Expressions can be used in statements (e.g. if, while, for). # - Expressions can be part of other expressions. 1 # Simple expression 1 + 2 + 3 # Arithmetic expression","title":"Expressions"},{"location":"examples/01_hello_world/#hello-world_1","text":"# Hello World # -------------------------------------------------------------------------------- # This simple program prints \"Hello world!\" and performs a basic # addition (1 + 1) to highlight Python's core syntax. print(\"Hello world!\") print(1 + 1)","title":"Hello World"},{"location":"examples/01_hello_world/#modules","text":"# Use import to access python modules # -------------------------------------------------------------------------------- # A module is a file containing Python code. It can define functions, # classes, and variables that you can use in your code. You can import a # module using the `import` statement. import math from math import pi print(math.pi) print(pi)","title":"Modules"},{"location":"examples/01_hello_world/#print-statement","text":"# Use the print() function to output text to the console. # -------------------------------------------------------------------------------- # The print() function is used to output data to the screen. It can take # multiple arguments and will convert them to strings before printing them. # By default, print() ends with a newline character. print(\"Hello\") print(\"World\") # Output: # Hello # World # You can change this behavior by specifying the end parameter. print(\"Hello\", end=\"\") print(\"World\", end=\"\") # Output: # HelloWorld # A print statement with no arguments prints a newline character. print(\"Hello\", end=\"\") print() print(\"World\", end=\"\") # Output: # Hello # World # You can also specify the separator symbol print(\"Hello\", \"World\", sep=\"\") print(\"Hello\", \"World\", sep=\" \") print(\"Hello\", \"World\", sep=\", \") # Output: # HelloWorld # Hello World # Hello, World","title":"Print Statement"},{"location":"examples/01_hello_world/#statements","text":"# Use statements to perform actions in Python. # -------------------------------------------------------------------------------- # A statement is a piece of code that performs an action. It can be as simple # as a single line or a more complex block of code. The following is true # for all statements: # # - A statement does not return a value. # - Statements cannot be used in expressions (e.g. if, while, for). # - It is a standalone operation. # Valid statements x = 5 print(x) # Invalid statements # if (x = 5): # SyntaxError (statement cannot be used in an expression)","title":"Statements"},{"location":"examples/01_hello_world/#zen-of-python","text":"# Import the `this` module to print the Zen of Python # -------------------------------------------------------------------------------- # This is a fun Easter egg in Python that prints the Zen of Python, the # guiding principles for writing computer programs in Python. It emphasizes # simplicity, readability, and the importance of explicitness in code design. import this # Output: # The Zen of Python, by Tim Peters # # Beautiful is better than ugly. # Explicit is better than implicit. # Simple is better than complex. # Complex is better than complicated. # Flat is better than nested. # Sparse is better than dense. # Readability counts. # Special cases aren't special enough to break the rules. # Although practicality beats purity. # Errors should never pass silently. # Unless explicitly silenced. # In the face of ambiguity, refuse the temptation to guess. # There should be one-- and preferably only one --obvious way to do it. # Although that way may not be obvious at first unless you're Dutch. # Now is better than never. # Although never is often better than *right* now. # If the implementation is hard to explain, it's a bad idea. # If the implementation is easy to explain, it may be a good idea. # Namespaces are one honking great idea -- let's do more of those!","title":"Zen Of Python"},{"location":"examples/02_variables/","text":"Variables String Cases # String case manipulation examples # -------------------------------------------------------------------------------- # This code applies various string case manipulation methods in Python. # Store the string to be manipulated text = \"AAAA bbbb\" print(text.upper()) # Output: # AAAA BBBB print(text.lower()) # Output: # aaaa bbbb print(text.title()) # Output: # Aaaa Bbbb print(text.capitalize()) # Output: # Aaaa bbbb print(text.swapcase()) # Output: # aaaa BBBB String Concatenation # String concatenation example # -------------------------------------------------------------------------------- # This code concatenates (joins) strings using the `+` operator. This # technique is common when constructing messages or combining text from # different sources. string1 = 'Hello' string2 = \"World\" string3 = \"!\" result = string1 + \" \" + string2 + string3 print(result) # Output: # Hello World! String Escaping # Escape sequences in Python strings # -------------------------------------------------------------------------------- # This example uses escape sequences in strings so you can include # characters that would otherwise be difficult or impossible to type # directly. # # Special characters: # - `\\n` for new line # - `\\t` for tab # - `\\\\` for backslash # - `\\'` for single quote # - `\\\"` for double quote print(\"Hello\\nWorld\") # Print new line inside string print(\"He said, \\\"Goodbye\\\"\") # Print double quotes inside string # Output: # Hello # World # He said, \"Goodbye\" String Indexing # String indexing # -------------------------------------------------------------------------------- # This code accesses individual characters in a string by index. Strings are # sequences of characters, so index 0 refers to the first character, and # negative indices let you read characters from the end of the string. string = \"Hello, world!\" print(string[0]) # Print first character # Output: # H print(string[1]) # Print second character # Output: # e print(string[-1]) # Print last character # Output: # ! String Interpolation # String interpolation # -------------------------------------------------------------------------------- # This code uses f-strings (formatted string literals) to create strings # that include variables. Expressions inside curly braces `{}` are # evaluated in place. first_name = \"Branimir\" last_name = \"Georgiev\" age = 25 print(f\"My name is {first_name} {last_name} and I am {age} years old\") # Output: # My name is Branimir Georgiev and I am 25 years old String Joining # String joining # -------------------------------------------------------------------------------- # The `join()` method is a string method that takes an iterable (like a list) # and concatenates its elements into a single string, with a specified separator # between each element. If no separator is provided, it defaults to an empty # string, effectively concatenating the elements without any characters in # between. tokens = '1 2 3 4 5 6 7 8 9'.split() print(tokens) # Output: # ['1', '2', '3', '4', '5', '6', '7', '8', '9'] text = ''.join(tokens) print(text) # Output: # 123456789 text = ' '.join(tokens) print(text) # Output: # 1 2 3 4 5 6 7 8 9 text = ','.join(tokens) print(text) # Output: # 1,2,3,4,5,6,7,8,9 String Length # Calculate the length of a string # -------------------------------------------------------------------------------- # This snippet calculates the number of characters in a string. The # result differs from the byte length when the string contains UTF-8 # characters that use multiple bytes. text = \"0123456789\" print(len(text)) # Output: # 10 text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439!' print(len(text)) # Output: # 8 String Slicing # String slicing # -------------------------------------------------------------------------------- # This code slices strings in Python. Slicing extracts a portion of a string # by specifying a start index, an end index, and an optional step using # the syntax `string[start:end:step]`. # # The `start` index is inclusive, the `end` index is exclusive, and the `step` # determines the increment between each index in the slice. The default values # for `start` is 0, for `end` is the length of the string, and for `step` is 1. text = \"0123456789ABCDEF\" print(text[0:5]) # Output: 01234 print(text[7:]) # Output: 789ABCDEF print(text[:5]) # Output: 01234 print(text[::2]) # Output: 02468ACE print(text[::-1]) # Output: FEDCBA9876543210 print(text[1:10:2]) # Output: 13579 String Splitting # Splitting Strings # -------------------------------------------------------------------------------- # The `split()` method is used to split a string into a list of tokens based # on a specified separator. If no separator is provided, it defaults to # whitespace. The `splitlines()` method is used to split a string into a # list of lines. text = \"1 2 3 4 5 6 7 8 9 10\" print(text.split()) # Output: # ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] text = \"1, 2, 3 4 5 6 7 8 9 10\" print(text.split(', ')) # Output: # ['1', '2', '3 4 5 6 7 8 9 10'] text = \"\"\" First line Second line Third line \"\"\" print(text.splitlines()) # Output: # [' First line', 'Second line', 'Third line'] Var As Container # Variable as a container # -------------------------------------------------------------------------------- # This code uses a variable as a container for data. The variable `text` # stores a string value that can be reused multiple times, illustrating how # variables allow you to store and manipulate data efficiently. text = 'Hello world!' print(text) print(text) print(text) print(text) print(text) # Output: # Hello world! # Hello world! # Hello world! # Hello world! # Hello world! Var Bool Type # Boolean variables # -------------------------------------------------------------------------------- # This example uses boolean variables to represent truth values\u2014either # `True` or `False`. Such variables are often part of conditional # statements and logical operations. var = False print(var) # Output: # False var = True print(var) # Output: # True Var Complex Sum # Complex numbers arithmetics # -------------------------------------------------------------------------------- # The operator + can be used to add complex numbers in Python, similar to # how it is used for integers and floats and is an example of operators # overloading in Python. Complex numbers are represented as `a + bj`, where `a` # is the real part and `b` is the imaginary part. The `j` suffix indicates # the imaginary unit, which is equivalent to the square root of -1. a = 1 + 1j b = 1 + 1j print(a + b) # Output: # (2+2j) Var Complex Type # Complex variables # -------------------------------------------------------------------------------- # This code creates and manipulates complex numbers in Python. A complex # number is written as `a + bj`, where `a` is the real part and `b` is the # imaginary part. z1 = 1 + 2j z2 = 2 + 4j print(z1, z2) # Output: # (1+2j) (2+4j) Var Dict Types # Dictionary types in Python # -------------------------------------------------------------------------------- # This code creates and manipulates dictionaries in Python. A dictionary is # a collection of key\u2013value pairs where each key is unique. If a key # appears more than once, the last assigned value is retained. The # dictionary variable has the following properties: # # - Key access: You can access values using their keys # - Unique keys: Each key must be unique within the dictionary # - Mutable: Can be modified after creation # - Ordered: The order of inserted items is maintained (as of Python 3.7) # - Heterogeneous: Can contain keys and values of different types # Key access a = {'junior': 1, 'mid': 2, 'senior': 3} print(a['mid']) # Output: 2 # Unique keys b = {'junior': 1, 'mid': 2, 'senior': 3, 'senior': 4} print(b) # Output: {'junior': 1, 'mid': 2, 'senior': 4} # Mutable c = {'junior':1, 'mid': 2} c.update({'senior': 3}) print(c) # Output: {'junior': 1, 'mid': 2, 'senior': 3} # Ordered (as of Python 3.7) d = {'mid': 2, 'senior': 3, 'junior': 1} print(d) # Output: {'mid': 2, 'junior': 1, 'senior': 3} # Heterogeneous e = {'junior': 1, 'mid': 2.5, 'senior': 'three'} print(e) # Output: {'junior': 1, 'mid': 2.5, 'senior': 'three'} Var Float Sum # Floating point numbers arithmetics # -------------------------------------------------------------------------------- # The `+` operator can be used to add float numbers in Python, similar to how # it is used for integers, strings and complex numbers (operators overloading). # Standard format for float numbers a = 1.0 b = 1.0 print(a + b) # Scientific notation for float numbers c = 1.0e1 # equivalent to 10.0 or 1* 10^1 d = 1.0e-1 # equivalent to 0.1 or 1* 10^-1 print(c + d) Var Float Type # Floating point numbers in Python # -------------------------------------------------------------------------------- # Floating point numbers are used to represent real numbers and can be defined # in standard decimal format or scientific notation. Python's `float` type is # based on the IEEE 754 double-precision floating-point format, which provides # a wide range of values and precision. float_1 = 1.0 # Standard format for float numbers float_2 = 1.0e0 # Scientific notation for float numbers (equivalent to 1.0) print(float_1) # Output: 1.0 print(float_2) # Output: 1.0 Var Immutable # Immutable variables in Python # -------------------------------------------------------------------------------- # Some variables in Python are immutable, meaning their value cannot be changed # after they are created. This is in contrast to mutable variables, which can # be modified after creation. # # For example, integer constants (also known as literals) are immutable in # Python. When you create a constant, it has a unique identifier (id) # that remains constant throughout the program's execution. Trying to reassign # an immutable constant to a new value will result in a SyntaxError. test = 1 print(\"Testing immutable constant 1 (int)\") print(\"ID of test : {}\".format(id(test))) print(\"ID of 1 : {}\".format(id(1))) # Output: # Testing immutable constant 1 (int) # ID of test : 140737488346112 # ID of 1 : 140737488346112 test = \"A\" print(\"Testing immutable constant 'A' (str)\") print(\"ID of test : {}\".format(id(test))) print(\"ID of 'A' : {}\".format(id(\"A\"))) # Output: # Testing immutable constant 'A' (str) # ID of test : 140737488346112 # ID of 'A' : 140737488346112 # Trying to reassign an immutable constant will raise a SyntaxError 1 = 2 # Output: # SyntaxError: cannot assign to literal ... Var Integer Type # Integer variable types in Python # -------------------------------------------------------------------------------- # The integer type in Python is used to represent whole numbers, both # positive and negative. Python supports various bases for integers, # including decimal, binary, octal, and hexadecimal. decimal_var = 10 print(decimal_var) # Output: 10 binary_var = 0b1010 print(binary_var) # Output: 10 octal_var = 0o12 print(octal_var) # Output: 10 hexadecimal_var = 0x0A print(hexadecimal_var) # Output: 10 Var List Type # List variables in Python # -------------------------------------------------------------------------------- # The list type in Python is used to represent a collection of items. It is # important to note that lists are passed by reference (see mutability in # examples). When you assign a list to another variable, both variables point # to the same list in memory. This means that changes made to one variable # will affect the other variable as well. To create a copy of a list, you can # use the `copy()` method or the slicing (e.g. `a = b[:]`). The list has the # following properties: # # - Indexed: Elements can be accessed by their index # - Mutable: Can be modified after creation # - Ordered: Order of elements is preserved # - Heterogeneous: Can contain elements of different types # Indexed a = [1, 2, 3] print(a[0]) # Output: 1 # Mutable b = [1, 2, 3] b[0] = 4 print(b) # Output: [4, 2, 3] # Ordered c = [2, 1, 3] print(c) # Output: [2, 1, 3] # Heterogeneous d = [1, 'two', 3.0] print(d) # Output: [1, 'two', 3.0] # (!) Passing by reference (!) l1 = [1, 2, 3] l2 = l1 l2[0] = 4 print(l1, l2) # Output: [4, 2, 3] # Copying a list l3 = l1.copy() l3[0] = 5 print(l1, l3) # Output: [4, 2, 3] [5, 2, 3] Var Mutable # Mutable variables in Python # -------------------------------------------------------------------------------- # Some variables in Python are mutable, meaning their value can be changed after # they are created allowing you to dynamic modification of their contents. The # most common mutable variable types in Python are lists, dictionaries, and # sets. # # In Python mutable variables are passed by reference, meaning that if you # assign a mutable variable to another variable, both variables will refer to # the same object in memory. This is a source of confusion for many a # Python developers, as it can lead to unexpected behavior. # Create a mutable variable (list) test = [1, 2, 3, 4] print(\"ID: {}\".format(id(test))) # Output: # ID: 140123456789456 # Modify the mutable variable and prove that it is still the same object test.append(5) print(\"ID: {}\".format(id(test))) # Output: # ID: 140123456789456 # An assignment to another variable will create a reference to the same object reference = test print(\"ID: {}\".format(id(reference))) # Output: # ID: 140123456789456 Var None Type # None type in Python # -------------------------------------------------------------------------------- # The None type in Python is used to show that the variable is not assigned # any value. It is useful when you want to indicate that a variable is # intentionally left empty or when a function does not return a value, e.g. # the `print` function. a = None print(a) # Output: None # The print function returns None print(print()) # Output: None Var Reason # Reason of having variables in Python # -------------------------------------------------------------------------------- # This example explains why variables are useful. Without them we would # repeat the same value throughout the code and update each occurrence # manually. Imagine printing \"Hello world\" 1000 times and later wanting # to change it to \"Hello Python\"\u2014we would need to edit every place it was # written. print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") # Output: Hello world Var Set Type # Set type in Python # -------------------------------------------------------------------------------- # The set type in Python is a collection of elements with unique values. It # used to remove duplicates from a collection and to perform set operations like # union, intersection, and difference. The set type has the following # characteristics: # # - Unique: A set cannot contain duplicate elements. # - Mutable: You can add or remove elements from a set. # - Unordered: The elements in a set do not have a specific order. # - Heterogeneous: A set can contain elements of different data types. # - Unindexed: You cannot access elements in a set by index # Passing by reference s1 = {1, 2, 3} s2 = s1 s2.add(4) print(s1, s2) # Output: {1, 2, 3, 4} {1, 2, 3, 4} # Copying a set s3 = s1.copy() s3.add(5) print(s1, s3) # All elements are unique a = {1, 1, 2, 2, 3, 3} print(id(a), a, sep=\": \") # Output: {1, 2, 3} # Mutable: You can add and remove elements a.add(4) print(id(a), a, sep=\": \") # Output: {1, 2, 3, 4} # Unordered: The order of elements is not guaranteed b = {3, 1, 2} print(id(b), b, sep=\": \") # Output: {1, 2, 3} # Heterogeneous: A set can contain elements of different data types c = {1, \"two\", 3.0, (4, 5)} print(id(c), c, sep=\": \") # Output: {1, 'two', 3.0, (4, 5)} # Unindexed: You cannot access elements by index d = {1, 2, 3} print(d[0]) # Output: TypeError: 'set' object is not subscriptable Var String Type # String type in Python # -------------------------------------------------------------------------------- # String variables in Python can be defined using single or double quotes. # Both types of quotes are valid and can be used interchangeably. The string # has the following characteristics: # # - Immutable: Once created, the string cannot be changed. # - Ordered: The characters in the string maintain their order. # - Indexed: Each character in the string can be accessed by its index. # - Homogeneous: All characters in the string are of the same type. # Immutable (a change creates a new object) string1 = \"Hello, world!\" string2 = string1.replace(\"world\", \"Python\") print(id(string1), id(string2)) # Ordered (characters maintain their order) string3 = \"Python\" print(list(string3)) # Output: ['P', 'y', 't', 'h', 'o', 'n'] # Indexed (characters can be accessed by index) string4 = \"Hello, world!\" print(string4[0]) # Output: 'H' # Homogeneous (all characters are of the same type) string5 = \"Python\" + 3 # Output: TypeError: can only concatenate str (not \"int\") to str Var Tuple Type # Tuple type in Python # -------------------------------------------------------------------------------- # A tuple is very similar to a list that is immutable, meaning it cannot be # changed after creation. Their main advantage is the memory efficiency # and performance benefits they provide over lists, especially when dealing # with large datasets. They also can be used as keys in dictionaries. # # - Immutable: Once created, the string cannot be changed. # - Ordered: The characters in the string maintain their order. # - Indexed: Each character in the string can be accessed by its index. # - Heterogeneous: Strings can contain characters of different types # Immutable (a change creates a new object) tuple1 = (1, 2, 3) tuple2 = tuple1 + (4, 5) print(id(tuple1), id(tuple2)) # Ordered (characters maintain their order) tuple3 = (1, 2, 3) print(list(tuple3)) # Output: [1, 2, 3] # Indexed (characters can be accessed by index) tuple4 = (3, 2, 1) print(tuple4[0]) # Output: 3 # Heterogeneous (can contain different types) tuple5 = (1, \"two\", 3.0, True) print(tuple5) # Output: (1, 'two', 3.0, True) Var Types # Get the type of a variable # -------------------------------------------------------------------------------- # Python offers a way to inspect the type of a variable using `type()`. Type # is a special class in Python that servers many purposes, including # determining the type of a variable. When invoked on a variable, it returns # the type of that variable, which can be useful for debugging or understanding # the data being worked with. var = 100 print(var, type(var)) # Output: 100 <class 'int'> var = 100.0 print(var, type(var)) # Output: 100.0 <class 'float'>","title":"Variables"},{"location":"examples/02_variables/#variables","text":"","title":"Variables"},{"location":"examples/02_variables/#string-cases","text":"# String case manipulation examples # -------------------------------------------------------------------------------- # This code applies various string case manipulation methods in Python. # Store the string to be manipulated text = \"AAAA bbbb\" print(text.upper()) # Output: # AAAA BBBB print(text.lower()) # Output: # aaaa bbbb print(text.title()) # Output: # Aaaa Bbbb print(text.capitalize()) # Output: # Aaaa bbbb print(text.swapcase()) # Output: # aaaa BBBB","title":"String Cases"},{"location":"examples/02_variables/#string-concatenation","text":"# String concatenation example # -------------------------------------------------------------------------------- # This code concatenates (joins) strings using the `+` operator. This # technique is common when constructing messages or combining text from # different sources. string1 = 'Hello' string2 = \"World\" string3 = \"!\" result = string1 + \" \" + string2 + string3 print(result) # Output: # Hello World!","title":"String Concatenation"},{"location":"examples/02_variables/#string-escaping","text":"# Escape sequences in Python strings # -------------------------------------------------------------------------------- # This example uses escape sequences in strings so you can include # characters that would otherwise be difficult or impossible to type # directly. # # Special characters: # - `\\n` for new line # - `\\t` for tab # - `\\\\` for backslash # - `\\'` for single quote # - `\\\"` for double quote print(\"Hello\\nWorld\") # Print new line inside string print(\"He said, \\\"Goodbye\\\"\") # Print double quotes inside string # Output: # Hello # World # He said, \"Goodbye\"","title":"String Escaping"},{"location":"examples/02_variables/#string-indexing","text":"# String indexing # -------------------------------------------------------------------------------- # This code accesses individual characters in a string by index. Strings are # sequences of characters, so index 0 refers to the first character, and # negative indices let you read characters from the end of the string. string = \"Hello, world!\" print(string[0]) # Print first character # Output: # H print(string[1]) # Print second character # Output: # e print(string[-1]) # Print last character # Output: # !","title":"String Indexing"},{"location":"examples/02_variables/#string-interpolation","text":"# String interpolation # -------------------------------------------------------------------------------- # This code uses f-strings (formatted string literals) to create strings # that include variables. Expressions inside curly braces `{}` are # evaluated in place. first_name = \"Branimir\" last_name = \"Georgiev\" age = 25 print(f\"My name is {first_name} {last_name} and I am {age} years old\") # Output: # My name is Branimir Georgiev and I am 25 years old","title":"String Interpolation"},{"location":"examples/02_variables/#string-joining","text":"# String joining # -------------------------------------------------------------------------------- # The `join()` method is a string method that takes an iterable (like a list) # and concatenates its elements into a single string, with a specified separator # between each element. If no separator is provided, it defaults to an empty # string, effectively concatenating the elements without any characters in # between. tokens = '1 2 3 4 5 6 7 8 9'.split() print(tokens) # Output: # ['1', '2', '3', '4', '5', '6', '7', '8', '9'] text = ''.join(tokens) print(text) # Output: # 123456789 text = ' '.join(tokens) print(text) # Output: # 1 2 3 4 5 6 7 8 9 text = ','.join(tokens) print(text) # Output: # 1,2,3,4,5,6,7,8,9","title":"String Joining"},{"location":"examples/02_variables/#string-length","text":"# Calculate the length of a string # -------------------------------------------------------------------------------- # This snippet calculates the number of characters in a string. The # result differs from the byte length when the string contains UTF-8 # characters that use multiple bytes. text = \"0123456789\" print(len(text)) # Output: # 10 text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439!' print(len(text)) # Output: # 8","title":"String Length"},{"location":"examples/02_variables/#string-slicing","text":"# String slicing # -------------------------------------------------------------------------------- # This code slices strings in Python. Slicing extracts a portion of a string # by specifying a start index, an end index, and an optional step using # the syntax `string[start:end:step]`. # # The `start` index is inclusive, the `end` index is exclusive, and the `step` # determines the increment between each index in the slice. The default values # for `start` is 0, for `end` is the length of the string, and for `step` is 1. text = \"0123456789ABCDEF\" print(text[0:5]) # Output: 01234 print(text[7:]) # Output: 789ABCDEF print(text[:5]) # Output: 01234 print(text[::2]) # Output: 02468ACE print(text[::-1]) # Output: FEDCBA9876543210 print(text[1:10:2]) # Output: 13579","title":"String Slicing"},{"location":"examples/02_variables/#string-splitting","text":"# Splitting Strings # -------------------------------------------------------------------------------- # The `split()` method is used to split a string into a list of tokens based # on a specified separator. If no separator is provided, it defaults to # whitespace. The `splitlines()` method is used to split a string into a # list of lines. text = \"1 2 3 4 5 6 7 8 9 10\" print(text.split()) # Output: # ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] text = \"1, 2, 3 4 5 6 7 8 9 10\" print(text.split(', ')) # Output: # ['1', '2', '3 4 5 6 7 8 9 10'] text = \"\"\" First line Second line Third line \"\"\" print(text.splitlines()) # Output: # [' First line', 'Second line', 'Third line']","title":"String Splitting"},{"location":"examples/02_variables/#var-as-container","text":"# Variable as a container # -------------------------------------------------------------------------------- # This code uses a variable as a container for data. The variable `text` # stores a string value that can be reused multiple times, illustrating how # variables allow you to store and manipulate data efficiently. text = 'Hello world!' print(text) print(text) print(text) print(text) print(text) # Output: # Hello world! # Hello world! # Hello world! # Hello world! # Hello world!","title":"Var As Container"},{"location":"examples/02_variables/#var-bool-type","text":"# Boolean variables # -------------------------------------------------------------------------------- # This example uses boolean variables to represent truth values\u2014either # `True` or `False`. Such variables are often part of conditional # statements and logical operations. var = False print(var) # Output: # False var = True print(var) # Output: # True","title":"Var Bool Type"},{"location":"examples/02_variables/#var-complex-sum","text":"# Complex numbers arithmetics # -------------------------------------------------------------------------------- # The operator + can be used to add complex numbers in Python, similar to # how it is used for integers and floats and is an example of operators # overloading in Python. Complex numbers are represented as `a + bj`, where `a` # is the real part and `b` is the imaginary part. The `j` suffix indicates # the imaginary unit, which is equivalent to the square root of -1. a = 1 + 1j b = 1 + 1j print(a + b) # Output: # (2+2j)","title":"Var Complex Sum"},{"location":"examples/02_variables/#var-complex-type","text":"# Complex variables # -------------------------------------------------------------------------------- # This code creates and manipulates complex numbers in Python. A complex # number is written as `a + bj`, where `a` is the real part and `b` is the # imaginary part. z1 = 1 + 2j z2 = 2 + 4j print(z1, z2) # Output: # (1+2j) (2+4j)","title":"Var Complex Type"},{"location":"examples/02_variables/#var-dict-types","text":"# Dictionary types in Python # -------------------------------------------------------------------------------- # This code creates and manipulates dictionaries in Python. A dictionary is # a collection of key\u2013value pairs where each key is unique. If a key # appears more than once, the last assigned value is retained. The # dictionary variable has the following properties: # # - Key access: You can access values using their keys # - Unique keys: Each key must be unique within the dictionary # - Mutable: Can be modified after creation # - Ordered: The order of inserted items is maintained (as of Python 3.7) # - Heterogeneous: Can contain keys and values of different types # Key access a = {'junior': 1, 'mid': 2, 'senior': 3} print(a['mid']) # Output: 2 # Unique keys b = {'junior': 1, 'mid': 2, 'senior': 3, 'senior': 4} print(b) # Output: {'junior': 1, 'mid': 2, 'senior': 4} # Mutable c = {'junior':1, 'mid': 2} c.update({'senior': 3}) print(c) # Output: {'junior': 1, 'mid': 2, 'senior': 3} # Ordered (as of Python 3.7) d = {'mid': 2, 'senior': 3, 'junior': 1} print(d) # Output: {'mid': 2, 'junior': 1, 'senior': 3} # Heterogeneous e = {'junior': 1, 'mid': 2.5, 'senior': 'three'} print(e) # Output: {'junior': 1, 'mid': 2.5, 'senior': 'three'}","title":"Var Dict Types"},{"location":"examples/02_variables/#var-float-sum","text":"# Floating point numbers arithmetics # -------------------------------------------------------------------------------- # The `+` operator can be used to add float numbers in Python, similar to how # it is used for integers, strings and complex numbers (operators overloading). # Standard format for float numbers a = 1.0 b = 1.0 print(a + b) # Scientific notation for float numbers c = 1.0e1 # equivalent to 10.0 or 1* 10^1 d = 1.0e-1 # equivalent to 0.1 or 1* 10^-1 print(c + d)","title":"Var Float Sum"},{"location":"examples/02_variables/#var-float-type","text":"# Floating point numbers in Python # -------------------------------------------------------------------------------- # Floating point numbers are used to represent real numbers and can be defined # in standard decimal format or scientific notation. Python's `float` type is # based on the IEEE 754 double-precision floating-point format, which provides # a wide range of values and precision. float_1 = 1.0 # Standard format for float numbers float_2 = 1.0e0 # Scientific notation for float numbers (equivalent to 1.0) print(float_1) # Output: 1.0 print(float_2) # Output: 1.0","title":"Var Float Type"},{"location":"examples/02_variables/#var-immutable","text":"# Immutable variables in Python # -------------------------------------------------------------------------------- # Some variables in Python are immutable, meaning their value cannot be changed # after they are created. This is in contrast to mutable variables, which can # be modified after creation. # # For example, integer constants (also known as literals) are immutable in # Python. When you create a constant, it has a unique identifier (id) # that remains constant throughout the program's execution. Trying to reassign # an immutable constant to a new value will result in a SyntaxError. test = 1 print(\"Testing immutable constant 1 (int)\") print(\"ID of test : {}\".format(id(test))) print(\"ID of 1 : {}\".format(id(1))) # Output: # Testing immutable constant 1 (int) # ID of test : 140737488346112 # ID of 1 : 140737488346112 test = \"A\" print(\"Testing immutable constant 'A' (str)\") print(\"ID of test : {}\".format(id(test))) print(\"ID of 'A' : {}\".format(id(\"A\"))) # Output: # Testing immutable constant 'A' (str) # ID of test : 140737488346112 # ID of 'A' : 140737488346112 # Trying to reassign an immutable constant will raise a SyntaxError 1 = 2 # Output: # SyntaxError: cannot assign to literal ...","title":"Var Immutable"},{"location":"examples/02_variables/#var-integer-type","text":"# Integer variable types in Python # -------------------------------------------------------------------------------- # The integer type in Python is used to represent whole numbers, both # positive and negative. Python supports various bases for integers, # including decimal, binary, octal, and hexadecimal. decimal_var = 10 print(decimal_var) # Output: 10 binary_var = 0b1010 print(binary_var) # Output: 10 octal_var = 0o12 print(octal_var) # Output: 10 hexadecimal_var = 0x0A print(hexadecimal_var) # Output: 10","title":"Var Integer Type"},{"location":"examples/02_variables/#var-list-type","text":"# List variables in Python # -------------------------------------------------------------------------------- # The list type in Python is used to represent a collection of items. It is # important to note that lists are passed by reference (see mutability in # examples). When you assign a list to another variable, both variables point # to the same list in memory. This means that changes made to one variable # will affect the other variable as well. To create a copy of a list, you can # use the `copy()` method or the slicing (e.g. `a = b[:]`). The list has the # following properties: # # - Indexed: Elements can be accessed by their index # - Mutable: Can be modified after creation # - Ordered: Order of elements is preserved # - Heterogeneous: Can contain elements of different types # Indexed a = [1, 2, 3] print(a[0]) # Output: 1 # Mutable b = [1, 2, 3] b[0] = 4 print(b) # Output: [4, 2, 3] # Ordered c = [2, 1, 3] print(c) # Output: [2, 1, 3] # Heterogeneous d = [1, 'two', 3.0] print(d) # Output: [1, 'two', 3.0] # (!) Passing by reference (!) l1 = [1, 2, 3] l2 = l1 l2[0] = 4 print(l1, l2) # Output: [4, 2, 3] # Copying a list l3 = l1.copy() l3[0] = 5 print(l1, l3) # Output: [4, 2, 3] [5, 2, 3]","title":"Var List Type"},{"location":"examples/02_variables/#var-mutable","text":"# Mutable variables in Python # -------------------------------------------------------------------------------- # Some variables in Python are mutable, meaning their value can be changed after # they are created allowing you to dynamic modification of their contents. The # most common mutable variable types in Python are lists, dictionaries, and # sets. # # In Python mutable variables are passed by reference, meaning that if you # assign a mutable variable to another variable, both variables will refer to # the same object in memory. This is a source of confusion for many a # Python developers, as it can lead to unexpected behavior. # Create a mutable variable (list) test = [1, 2, 3, 4] print(\"ID: {}\".format(id(test))) # Output: # ID: 140123456789456 # Modify the mutable variable and prove that it is still the same object test.append(5) print(\"ID: {}\".format(id(test))) # Output: # ID: 140123456789456 # An assignment to another variable will create a reference to the same object reference = test print(\"ID: {}\".format(id(reference))) # Output: # ID: 140123456789456","title":"Var Mutable"},{"location":"examples/02_variables/#var-none-type","text":"# None type in Python # -------------------------------------------------------------------------------- # The None type in Python is used to show that the variable is not assigned # any value. It is useful when you want to indicate that a variable is # intentionally left empty or when a function does not return a value, e.g. # the `print` function. a = None print(a) # Output: None # The print function returns None print(print()) # Output: None","title":"Var None Type"},{"location":"examples/02_variables/#var-reason","text":"# Reason of having variables in Python # -------------------------------------------------------------------------------- # This example explains why variables are useful. Without them we would # repeat the same value throughout the code and update each occurrence # manually. Imagine printing \"Hello world\" 1000 times and later wanting # to change it to \"Hello Python\"\u2014we would need to edit every place it was # written. print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") print(\"Hello world\") # Output: Hello world","title":"Var Reason"},{"location":"examples/02_variables/#var-set-type","text":"# Set type in Python # -------------------------------------------------------------------------------- # The set type in Python is a collection of elements with unique values. It # used to remove duplicates from a collection and to perform set operations like # union, intersection, and difference. The set type has the following # characteristics: # # - Unique: A set cannot contain duplicate elements. # - Mutable: You can add or remove elements from a set. # - Unordered: The elements in a set do not have a specific order. # - Heterogeneous: A set can contain elements of different data types. # - Unindexed: You cannot access elements in a set by index # Passing by reference s1 = {1, 2, 3} s2 = s1 s2.add(4) print(s1, s2) # Output: {1, 2, 3, 4} {1, 2, 3, 4} # Copying a set s3 = s1.copy() s3.add(5) print(s1, s3) # All elements are unique a = {1, 1, 2, 2, 3, 3} print(id(a), a, sep=\": \") # Output: {1, 2, 3} # Mutable: You can add and remove elements a.add(4) print(id(a), a, sep=\": \") # Output: {1, 2, 3, 4} # Unordered: The order of elements is not guaranteed b = {3, 1, 2} print(id(b), b, sep=\": \") # Output: {1, 2, 3} # Heterogeneous: A set can contain elements of different data types c = {1, \"two\", 3.0, (4, 5)} print(id(c), c, sep=\": \") # Output: {1, 'two', 3.0, (4, 5)} # Unindexed: You cannot access elements by index d = {1, 2, 3} print(d[0]) # Output: TypeError: 'set' object is not subscriptable","title":"Var Set Type"},{"location":"examples/02_variables/#var-string-type","text":"# String type in Python # -------------------------------------------------------------------------------- # String variables in Python can be defined using single or double quotes. # Both types of quotes are valid and can be used interchangeably. The string # has the following characteristics: # # - Immutable: Once created, the string cannot be changed. # - Ordered: The characters in the string maintain their order. # - Indexed: Each character in the string can be accessed by its index. # - Homogeneous: All characters in the string are of the same type. # Immutable (a change creates a new object) string1 = \"Hello, world!\" string2 = string1.replace(\"world\", \"Python\") print(id(string1), id(string2)) # Ordered (characters maintain their order) string3 = \"Python\" print(list(string3)) # Output: ['P', 'y', 't', 'h', 'o', 'n'] # Indexed (characters can be accessed by index) string4 = \"Hello, world!\" print(string4[0]) # Output: 'H' # Homogeneous (all characters are of the same type) string5 = \"Python\" + 3 # Output: TypeError: can only concatenate str (not \"int\") to str","title":"Var String Type"},{"location":"examples/02_variables/#var-tuple-type","text":"# Tuple type in Python # -------------------------------------------------------------------------------- # A tuple is very similar to a list that is immutable, meaning it cannot be # changed after creation. Their main advantage is the memory efficiency # and performance benefits they provide over lists, especially when dealing # with large datasets. They also can be used as keys in dictionaries. # # - Immutable: Once created, the string cannot be changed. # - Ordered: The characters in the string maintain their order. # - Indexed: Each character in the string can be accessed by its index. # - Heterogeneous: Strings can contain characters of different types # Immutable (a change creates a new object) tuple1 = (1, 2, 3) tuple2 = tuple1 + (4, 5) print(id(tuple1), id(tuple2)) # Ordered (characters maintain their order) tuple3 = (1, 2, 3) print(list(tuple3)) # Output: [1, 2, 3] # Indexed (characters can be accessed by index) tuple4 = (3, 2, 1) print(tuple4[0]) # Output: 3 # Heterogeneous (can contain different types) tuple5 = (1, \"two\", 3.0, True) print(tuple5) # Output: (1, 'two', 3.0, True)","title":"Var Tuple Type"},{"location":"examples/02_variables/#var-types","text":"# Get the type of a variable # -------------------------------------------------------------------------------- # Python offers a way to inspect the type of a variable using `type()`. Type # is a special class in Python that servers many purposes, including # determining the type of a variable. When invoked on a variable, it returns # the type of that variable, which can be useful for debugging or understanding # the data being worked with. var = 100 print(var, type(var)) # Output: 100 <class 'int'> var = 100.0 print(var, type(var)) # Output: 100.0 <class 'float'>","title":"Var Types"},{"location":"examples/03_comments/","text":"Comments Comment Multi Line # Multi-line comments in Python # -------------------------------------------------------------------------------- # Multi-line comments in Python can be created using triple quotes. \"\"\" This is junior multi-line comment. The following code will print the message `Hello, world!` and then print the sum of two numbers. \"\"\" print(\"Hello world!\") print(1 + 1) Comment Single Line # Single-line comments in Python # -------------------------------------------------------------------------------- # A single-line comment in Python starts with a hash symbol (#). # This code will print junior message and the sum of two numbers print(\"Hello world!\") print(1 + 1)","title":"Comments"},{"location":"examples/03_comments/#comments","text":"","title":"Comments"},{"location":"examples/03_comments/#comment-multi-line","text":"# Multi-line comments in Python # -------------------------------------------------------------------------------- # Multi-line comments in Python can be created using triple quotes. \"\"\" This is junior multi-line comment. The following code will print the message `Hello, world!` and then print the sum of two numbers. \"\"\" print(\"Hello world!\") print(1 + 1)","title":"Comment Multi Line"},{"location":"examples/03_comments/#comment-single-line","text":"# Single-line comments in Python # -------------------------------------------------------------------------------- # A single-line comment in Python starts with a hash symbol (#). # This code will print junior message and the sum of two numbers print(\"Hello world!\") print(1 + 1)","title":"Comment Single Line"},{"location":"examples/04_operators/","text":"Operators Operators Arithmetic # Arithmetic Operators in Python # -------------------------------------------------------------------------------- # Arithmetic operators are used to perform mathematical operations on # numeric values. In Python, these operators include addition, subtraction, # multiplication, division, floor division, modulus, and exponentiation. a, b = 3, 2 # Addition print(a+b) # Output: 6 # Subtraction print(a-b) # Output: 1 # Multiplication print(a*b) # Output: 6 # Division (floating point division) print(a/b) # Output: 1.5 # Floor Division (integer division) print(a//b) # Output: 1 # Modulus (remainder) print(a % b) # Output: 1 # Exponentiation (a to the power of b) print(a**b) # Output: 9 Operators Assignment # Assignment Operators # -------------------------------------------------------------------------------- # Assignment operators are used to assign values to variables and can also # perform operations on those values. # # For example, the `+=` operator adds a value to a variable and assigns the # result back to that variable. The same applies to each of the other # arithmetic and bitwise operators (e.g., `-=`, `*=`, `/=`, `&=`, `|=`, etc.). a = 10 b = 15 # Assign test = a print(test) # Output: 10 # Add and Assign test += b print(test) # Output: 25 (same as test = test + b) Operators Bitwise # Bitwise Operators in Python # -------------------------------------------------------------------------------- # Bitwise operators are used to perform bit-level operations on integers. These # operators directly manipulate the binary representations of numbers. Each bit # is calculated independently, based on the truth table of the operation. # # Truth table: & (AND) # | A | B | A & B | # |---|---|-------| # | 0 | 0 | 0 | # | 0 | 1 | 0 | # | 1 | 0 | 0 | # | 1 | 1 | 1 | # Example: # 0xAA = 10101010 (binary) # 0x55 = 01010101 (binary) # 0xAA & 0x55 = 00000000 (binary) # Initialize variables a, b = 0xAA, 0x55 # Performs a binary AND operation between corresponding bits of a and b print(hex(a & b)) # 0x00 # Performs a binary OR operation between corresponding bits of a and b print(hex(a | b)) # 0xFF # Performs a binary XOR operation between corresponding bits of a and b print(hex(a ^ b)) # 0xFF # Inverts all the bits of a (1's complement) print(hex(~a)) # -0xAB # Shifts the bits the left by 1 position, filling with 0 on the right print(hex(a << 1)) # 0x154 # Shifts the bits the right by 1 position, discarding bits on the right print(hex(a >> 1)) # 0x55 Operators Comparison # Comparison Operators in Python # -------------------------------------------------------------------------------- # Comparison operators are used to compare two values. They return a boolean # value (True or False) based on the comparison. # Initialize variables a, b = 10, 20 # Equal print(a == b) # Output: False # Not equal print(a != b) # Output: True # Greater than print(a > b) # Output: False # Less than print(a < b) # Output: True # Greater than or equal to print(a >= b) # Output: False # Less than or equal to print(a <= b) # Output: True Operators Conditional # Conditional Expressions in Python # -------------------------------------------------------------------------------- # Conditional expressions allow you to evaluate a condition and return one # of two values based on the result of the condition. # # Syntax: [value_if_true] if [condition] else [value_if_false] a, b = 10, 20 # Find the minimum of two numbers using a conditional expression result = a if a < b else b print(result) # Output: 10 Operators Dict # Merging and updating dictionaries # -------------------------------------------------------------------------------- # Python 3.9 introduced the | and |= operators to combine dictionaries. The | # operator creates a new dictionary containing keys from both operands, while # |= updates the dictionary on the left in place. This provides a concise # alternative to using the update() method or ** unpacking for merging. a = {'a': 1, 'b': 2, 'c': 3} b = {'d': 4, 'e': 5} # Merging two dictionaries using the | operator c = a | b print(c) # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} # Updating a dictionary with another using the |= operator a |= b print(a) # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} Operators Identity # Identity Operators in Python # -------------------------------------------------------------------------------- # Identity operators are used to compare the memory locations of two objects. # If two variables point to the same object in memory, they are considered # identical. a, b, c = 10, 20, 10 print(a is b) # Output: False print(a is not b) # Output: True print(a is c) # Output: True Operators List # Common list operators in Python # -------------------------------------------------------------------------------- # This file contains examples of the most commonly used operators on lists, # including indexing, slicing, concatenation, repetition, and membership tests. my_list = [1, 2, 3, 4, 5] # Indexing print(my_list[0]) # Access the first element print(my_list[-1]) # Access the last element # Slicing print(my_list[1:4]) # Get a sublist from index 1 to 3 print(my_list[:3]) # Get the first three elements # Concatenation new_list = my_list + [6, 7, 8] print(new_list) # Combine two lists # Repetition repeated_list = my_list * 2 print(repeated_list) # Repeat the list twice # Membership test print(3 in my_list) # Check if 3 is in the list print(10 not in my_list) # Check if 10 is not in the list Operators Logical # Logical Operators in Python # -------------------------------------------------------------------------------- # Logical operators are used to combine conditional statements. They allow you # to evaluate multiple conditions and return a boolean value (True or False) # based on the evaluation. a, b = 10, 20 # AND print(a < 100 and b > 15) # Output: True # OR print(a < 100 or b > 100) # Output: True # NOT print(not(a < 100 and b > 15)) # Output: False Operators Membership # Membership Operators in Python # -------------------------------------------------------------------------------- # Membership operators are used to test whether a value is a member of a # sequence (e.g., a list, tuple, or string). a, b = 1, 5 test_list = [1, 2, 3] # in print(a in test_list) # not in print(b not in test_list) Operators Precedence Boolean # Explore the precedence of boolean operators # -------------------------------------------------------------------------------- # Boolean operators include `not`, `and`, and `or`, and their precedence # determines the order in which they are evaluated. The precedence order is: # # 1. `not` # 2. `and` # 3. `or` # # !!! WARNING !!! # Please always use parentheses to make the code more readable and # to avoid confusion with operator precedence. The examples below # are for educational purposes only and should not be used in production # code. a = not False and True or False # a = ((not False) and True) or False # 1 True and True or False # 2 True or False # 3 True print(a) # Output: True Operators Precedence Math # Mathematical Operator Precedence in Python # -------------------------------------------------------------------------------- # Mathematical operators include addition, subtraction, multiplication, and # division, and their precedence determines the order in which they are e # valuated. # # The precedence of mathematical operators in Python is as follows: # 1. Parentheses # 2. Exponentiation (**) # 3. Multiplication (*), Division (/), and Modulus (%) # 4. Addition (+) and Subtraction (-) # # !!! WARNING !!! # The precedence of operators can lead to unexpected results if not # understood correctly. Avoid using complex expressions without parentheses # to ensure clarity and correctness, especially in production code. a = 2 + 3 - 4/5 # a = 2 + 3 - (4/5) print(a) # Output: 4.2 Operators Precedence Parantheses # Parentheses to control operator precedence # -------------------------------------------------------------------------------- # The parentheses in Python can be used to control the precedence of # operators in expressions. a = 2 + 2**3 b = (2 + 2)**3 print(a) # Output: 10 print(b) # Output: 64 Operators Set # Set Operators in Python # -------------------------------------------------------------------------------- # Demonstrates fundamental set operations including union, intersection, # difference, symmetric difference, and subset/superset checks. set1 = {1, 2, 3} set2 = {3, 4, 5} set_union = set1 | set2 print(\"Union:\", set_union) # Output: {1, 2, 3, 4, 5} # Intersection set_intersection = set1 & set2 print(\"Intersection:\", set_intersection) # Output: {3} # Difference set_difference = set1 - set2 print(\"Difference:\", set_difference) # Output: {1, 2} # Symmetric Difference set_symmetric_difference = set1 ^ set2 print(\"Symmetric Difference:\", set_symmetric_difference) # Output: {1, 2, 4, 5} # Subset set3 = {1, 2} set4 = {1, 2, 3, 4, 5} is_subset = set3 <= set4 print(\"Is set3 a subset of set4?\", is_subset) # Output: True # Superset is_superset = set4 >= set3 print(\"Is set4 a superset of set3?\", is_superset) # Output: True # Proper subset is_proper_subset = set3 < set4 print(\"Is set3 a proper subset of set4?\", is_proper_subset) # Output: True # Proper superset is_proper_superset = set4 > set3 print(\"Is set4 a proper superset of set3?\", is_proper_superset) # Output: True # Disjoint set5 = {6, 7} is_disjoint = set1.isdisjoint(set5) print(\"Are set1 and set5 disjoint?\", is_disjoint) # Output: True Operators Tuples # Tuple Operators in Python # -------------------------------------------------------------------------------- # This example demonstrates common tuple operations including indexing, # slicing, concatenation, repetition, and membership tests. my_tuple = (1, 2, 3, 4, 5) # Indexing print(my_tuple[0]) # Output: 1 print(my_tuple[-1]) # Output: 5 # Slicing print(my_tuple[1:4]) # Output: (2, 3, 4) # Concatenation print(my_tuple + (6, 7)) # Output: (1, 2, 3, 4, 5, 6, 7) # Repetition print(my_tuple * 2) # Output: (1, 2, 3, 4, 5, 1, 2, 3, 4, 5) # Membership print(3 in my_tuple) # Output: True print(9 in my_tuple) # Output: False","title":"Operators"},{"location":"examples/04_operators/#operators","text":"","title":"Operators"},{"location":"examples/04_operators/#operators-arithmetic","text":"# Arithmetic Operators in Python # -------------------------------------------------------------------------------- # Arithmetic operators are used to perform mathematical operations on # numeric values. In Python, these operators include addition, subtraction, # multiplication, division, floor division, modulus, and exponentiation. a, b = 3, 2 # Addition print(a+b) # Output: 6 # Subtraction print(a-b) # Output: 1 # Multiplication print(a*b) # Output: 6 # Division (floating point division) print(a/b) # Output: 1.5 # Floor Division (integer division) print(a//b) # Output: 1 # Modulus (remainder) print(a % b) # Output: 1 # Exponentiation (a to the power of b) print(a**b) # Output: 9","title":"Operators Arithmetic"},{"location":"examples/04_operators/#operators-assignment","text":"# Assignment Operators # -------------------------------------------------------------------------------- # Assignment operators are used to assign values to variables and can also # perform operations on those values. # # For example, the `+=` operator adds a value to a variable and assigns the # result back to that variable. The same applies to each of the other # arithmetic and bitwise operators (e.g., `-=`, `*=`, `/=`, `&=`, `|=`, etc.). a = 10 b = 15 # Assign test = a print(test) # Output: 10 # Add and Assign test += b print(test) # Output: 25 (same as test = test + b)","title":"Operators Assignment"},{"location":"examples/04_operators/#operators-bitwise","text":"# Bitwise Operators in Python # -------------------------------------------------------------------------------- # Bitwise operators are used to perform bit-level operations on integers. These # operators directly manipulate the binary representations of numbers. Each bit # is calculated independently, based on the truth table of the operation. # # Truth table: & (AND) # | A | B | A & B | # |---|---|-------| # | 0 | 0 | 0 | # | 0 | 1 | 0 | # | 1 | 0 | 0 | # | 1 | 1 | 1 | # Example: # 0xAA = 10101010 (binary) # 0x55 = 01010101 (binary) # 0xAA & 0x55 = 00000000 (binary) # Initialize variables a, b = 0xAA, 0x55 # Performs a binary AND operation between corresponding bits of a and b print(hex(a & b)) # 0x00 # Performs a binary OR operation between corresponding bits of a and b print(hex(a | b)) # 0xFF # Performs a binary XOR operation between corresponding bits of a and b print(hex(a ^ b)) # 0xFF # Inverts all the bits of a (1's complement) print(hex(~a)) # -0xAB # Shifts the bits the left by 1 position, filling with 0 on the right print(hex(a << 1)) # 0x154 # Shifts the bits the right by 1 position, discarding bits on the right print(hex(a >> 1)) # 0x55","title":"Operators Bitwise"},{"location":"examples/04_operators/#operators-comparison","text":"# Comparison Operators in Python # -------------------------------------------------------------------------------- # Comparison operators are used to compare two values. They return a boolean # value (True or False) based on the comparison. # Initialize variables a, b = 10, 20 # Equal print(a == b) # Output: False # Not equal print(a != b) # Output: True # Greater than print(a > b) # Output: False # Less than print(a < b) # Output: True # Greater than or equal to print(a >= b) # Output: False # Less than or equal to print(a <= b) # Output: True","title":"Operators Comparison"},{"location":"examples/04_operators/#operators-conditional","text":"# Conditional Expressions in Python # -------------------------------------------------------------------------------- # Conditional expressions allow you to evaluate a condition and return one # of two values based on the result of the condition. # # Syntax: [value_if_true] if [condition] else [value_if_false] a, b = 10, 20 # Find the minimum of two numbers using a conditional expression result = a if a < b else b print(result) # Output: 10","title":"Operators Conditional"},{"location":"examples/04_operators/#operators-dict","text":"# Merging and updating dictionaries # -------------------------------------------------------------------------------- # Python 3.9 introduced the | and |= operators to combine dictionaries. The | # operator creates a new dictionary containing keys from both operands, while # |= updates the dictionary on the left in place. This provides a concise # alternative to using the update() method or ** unpacking for merging. a = {'a': 1, 'b': 2, 'c': 3} b = {'d': 4, 'e': 5} # Merging two dictionaries using the | operator c = a | b print(c) # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} # Updating a dictionary with another using the |= operator a |= b print(a) # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}","title":"Operators Dict"},{"location":"examples/04_operators/#operators-identity","text":"# Identity Operators in Python # -------------------------------------------------------------------------------- # Identity operators are used to compare the memory locations of two objects. # If two variables point to the same object in memory, they are considered # identical. a, b, c = 10, 20, 10 print(a is b) # Output: False print(a is not b) # Output: True print(a is c) # Output: True","title":"Operators Identity"},{"location":"examples/04_operators/#operators-list","text":"# Common list operators in Python # -------------------------------------------------------------------------------- # This file contains examples of the most commonly used operators on lists, # including indexing, slicing, concatenation, repetition, and membership tests. my_list = [1, 2, 3, 4, 5] # Indexing print(my_list[0]) # Access the first element print(my_list[-1]) # Access the last element # Slicing print(my_list[1:4]) # Get a sublist from index 1 to 3 print(my_list[:3]) # Get the first three elements # Concatenation new_list = my_list + [6, 7, 8] print(new_list) # Combine two lists # Repetition repeated_list = my_list * 2 print(repeated_list) # Repeat the list twice # Membership test print(3 in my_list) # Check if 3 is in the list print(10 not in my_list) # Check if 10 is not in the list","title":"Operators List"},{"location":"examples/04_operators/#operators-logical","text":"# Logical Operators in Python # -------------------------------------------------------------------------------- # Logical operators are used to combine conditional statements. They allow you # to evaluate multiple conditions and return a boolean value (True or False) # based on the evaluation. a, b = 10, 20 # AND print(a < 100 and b > 15) # Output: True # OR print(a < 100 or b > 100) # Output: True # NOT print(not(a < 100 and b > 15)) # Output: False","title":"Operators Logical"},{"location":"examples/04_operators/#operators-membership","text":"# Membership Operators in Python # -------------------------------------------------------------------------------- # Membership operators are used to test whether a value is a member of a # sequence (e.g., a list, tuple, or string). a, b = 1, 5 test_list = [1, 2, 3] # in print(a in test_list) # not in print(b not in test_list)","title":"Operators Membership"},{"location":"examples/04_operators/#operators-precedence-boolean","text":"# Explore the precedence of boolean operators # -------------------------------------------------------------------------------- # Boolean operators include `not`, `and`, and `or`, and their precedence # determines the order in which they are evaluated. The precedence order is: # # 1. `not` # 2. `and` # 3. `or` # # !!! WARNING !!! # Please always use parentheses to make the code more readable and # to avoid confusion with operator precedence. The examples below # are for educational purposes only and should not be used in production # code. a = not False and True or False # a = ((not False) and True) or False # 1 True and True or False # 2 True or False # 3 True print(a) # Output: True","title":"Operators Precedence Boolean"},{"location":"examples/04_operators/#operators-precedence-math","text":"# Mathematical Operator Precedence in Python # -------------------------------------------------------------------------------- # Mathematical operators include addition, subtraction, multiplication, and # division, and their precedence determines the order in which they are e # valuated. # # The precedence of mathematical operators in Python is as follows: # 1. Parentheses # 2. Exponentiation (**) # 3. Multiplication (*), Division (/), and Modulus (%) # 4. Addition (+) and Subtraction (-) # # !!! WARNING !!! # The precedence of operators can lead to unexpected results if not # understood correctly. Avoid using complex expressions without parentheses # to ensure clarity and correctness, especially in production code. a = 2 + 3 - 4/5 # a = 2 + 3 - (4/5) print(a) # Output: 4.2","title":"Operators Precedence Math"},{"location":"examples/04_operators/#operators-precedence-parantheses","text":"# Parentheses to control operator precedence # -------------------------------------------------------------------------------- # The parentheses in Python can be used to control the precedence of # operators in expressions. a = 2 + 2**3 b = (2 + 2)**3 print(a) # Output: 10 print(b) # Output: 64","title":"Operators Precedence Parantheses"},{"location":"examples/04_operators/#operators-set","text":"# Set Operators in Python # -------------------------------------------------------------------------------- # Demonstrates fundamental set operations including union, intersection, # difference, symmetric difference, and subset/superset checks. set1 = {1, 2, 3} set2 = {3, 4, 5} set_union = set1 | set2 print(\"Union:\", set_union) # Output: {1, 2, 3, 4, 5} # Intersection set_intersection = set1 & set2 print(\"Intersection:\", set_intersection) # Output: {3} # Difference set_difference = set1 - set2 print(\"Difference:\", set_difference) # Output: {1, 2} # Symmetric Difference set_symmetric_difference = set1 ^ set2 print(\"Symmetric Difference:\", set_symmetric_difference) # Output: {1, 2, 4, 5} # Subset set3 = {1, 2} set4 = {1, 2, 3, 4, 5} is_subset = set3 <= set4 print(\"Is set3 a subset of set4?\", is_subset) # Output: True # Superset is_superset = set4 >= set3 print(\"Is set4 a superset of set3?\", is_superset) # Output: True # Proper subset is_proper_subset = set3 < set4 print(\"Is set3 a proper subset of set4?\", is_proper_subset) # Output: True # Proper superset is_proper_superset = set4 > set3 print(\"Is set4 a proper superset of set3?\", is_proper_superset) # Output: True # Disjoint set5 = {6, 7} is_disjoint = set1.isdisjoint(set5) print(\"Are set1 and set5 disjoint?\", is_disjoint) # Output: True","title":"Operators Set"},{"location":"examples/04_operators/#operators-tuples","text":"# Tuple Operators in Python # -------------------------------------------------------------------------------- # This example demonstrates common tuple operations including indexing, # slicing, concatenation, repetition, and membership tests. my_tuple = (1, 2, 3, 4, 5) # Indexing print(my_tuple[0]) # Output: 1 print(my_tuple[-1]) # Output: 5 # Slicing print(my_tuple[1:4]) # Output: (2, 3, 4) # Concatenation print(my_tuple + (6, 7)) # Output: (1, 2, 3, 4, 5, 6, 7) # Repetition print(my_tuple * 2) # Output: (1, 2, 3, 4, 5, 1, 2, 3, 4, 5) # Membership print(3 in my_tuple) # Output: True print(9 in my_tuple) # Output: False","title":"Operators Tuples"},{"location":"examples/05_user_input/","text":"User Input User Input Python2 # User Input in Python 2 # -------------------------------------------------------------------------------- # Use `input()` to execute the input as Python code, or `raw_input()` to get a # string input. Please not that this example works in Python 2.x only. # Type `1+1` that will be printed as a string prompt = raw_input('Enter a string: ') print(prompt) # Output: <string entered by the user> # Type `1+1` to get the result of the expression prompt = input('Execute an expression: ') # Output: <result of the executed statement> print(\"Execute statement: {}\".format(prompt)) User Input Python3 # User Input in Python 3 # -------------------------------------------------------------------------------- # Use `input()` to get input from the user, which returns a string. Use `eval()` # to evaluate the input as a Python expression, or `int()` to convert it to # an integer. # Enter `1+1` that will be printed as a string prompt = input('Enter a string: ') print(prompt) # Output: <user input> # Enter `1+1` to get the result of the expression prompt = input('Enter an expression: ') evaluated_input = eval(prompt) print(f\"Execute statement: {evaluated_input}\") # Output: <user input evaluated as a Python expression> User Input With Six # Cross-Version User Input with six # -------------------------------------------------------------------------------- # If the code needs to work in both Python 2 and 3, you can use the `six` # library to handle user input. from six.moves import input prompt = input('Enter something: ') print(prompt) # Output: <user input in bytes>","title":"User Input"},{"location":"examples/05_user_input/#user-input","text":"","title":"User Input"},{"location":"examples/05_user_input/#user-input-python2","text":"# User Input in Python 2 # -------------------------------------------------------------------------------- # Use `input()` to execute the input as Python code, or `raw_input()` to get a # string input. Please not that this example works in Python 2.x only. # Type `1+1` that will be printed as a string prompt = raw_input('Enter a string: ') print(prompt) # Output: <string entered by the user> # Type `1+1` to get the result of the expression prompt = input('Execute an expression: ') # Output: <result of the executed statement> print(\"Execute statement: {}\".format(prompt))","title":"User Input Python2"},{"location":"examples/05_user_input/#user-input-python3","text":"# User Input in Python 3 # -------------------------------------------------------------------------------- # Use `input()` to get input from the user, which returns a string. Use `eval()` # to evaluate the input as a Python expression, or `int()` to convert it to # an integer. # Enter `1+1` that will be printed as a string prompt = input('Enter a string: ') print(prompt) # Output: <user input> # Enter `1+1` to get the result of the expression prompt = input('Enter an expression: ') evaluated_input = eval(prompt) print(f\"Execute statement: {evaluated_input}\") # Output: <user input evaluated as a Python expression>","title":"User Input Python3"},{"location":"examples/05_user_input/#user-input-with-six","text":"# Cross-Version User Input with six # -------------------------------------------------------------------------------- # If the code needs to work in both Python 2 and 3, you can use the `six` # library to handle user input. from six.moves import input prompt = input('Enter something: ') print(prompt) # Output: <user input in bytes>","title":"User Input With Six"},{"location":"examples/06_control_flow/","text":"Control Flow Control With Break Statement # Exiting loops prematurely with the `break` statement. # -------------------------------------------------------------------------------- # The `break` statement is used to exit a loop prematurely. It can be used in # both `for` and `while` loops. When the `break` statement is encountered, # the loop is terminated immediately, and control is transferred to the next # statement following the loop. # Break statement inside for loop val = int(input(\"Guess a number: \")) for i in range(1, 10): if val == i: print(\"You guessed the number!\") break else: print(\"You did not guess the number!\") # Break statement inside while loop val = int(input(\"Guess a new number: \")) i = 0 while i < 10: if val == i: print(\"You guessed the number!\") break i += 1 else: print(\"You did not guess the number!\") Control With Continue Statement # Skipping iterations in loops with the `continue` statement. # -------------------------------------------------------------------------------- # When the `continue` statement is encountered, the rest of the code # in the current iteration is skipped, and control is transferred to the next # iteration of the loop. numbers = [1, 2, 3, 4, 5, 6] # Print numbers, skipping even numbers and breaking on 5 for num in numbers: if num % 2 == 0: continue elif num == 5: break else: print(num) Control With For Statement # Iterating over sequences using `for` loops. # -------------------------------------------------------------------------------- # Loops that use the `for` statement to iterate over a sequence or other # iterable objects are useful for executing a block of code a fixed number of # times (we know the number of iterations in advance). fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit) Control With If Statement # Conditional logic using `if`, `elif`, and `else` to handle different cases based on conditions. # -------------------------------------------------------------------------------- # The conditional statements in Python allow you to control the flow of your # program based on certain conditions. This way we can execute different # blocks of code depending on the condition that is met. # # Bear in mind that if a condition is met, the code block will be executed and # the rest of the code blocks will be skipped. If no condition is met, the # code block in the `else` statement will be executed, if it exists. var = int(input('Enter value: ')) if 1 <= var <= 10: print(\"Variable is a valid positive number\") elif -10 <= var <= -1: print(\"Variable is a valid negative number\") else: print(\"Variable is not a valid positive or negative number\") Control With Pass Statement # Using `pass` as a placeholder or to handle empty code blocks. # -------------------------------------------------------------------------------- # The `pass` statement in Python is used as a placeholder for future code or # to handle empty code blocks. It allows you to write syntactically correct # code without implementing any functionality yet. val = input(\"Enter value: \") if val in ('', ' ', None): pass # Placeholder for future code else: print(val) Control With While Statement # Repeating code with `while` loops until a condition is met. # -------------------------------------------------------------------------------- # Loops that use the `while` statement to repeat a block of code as long as a # condition is true. This is useful when the number of iterations is not known # beforehand, and the loop continues until a specific condition is met. while True: cmd = input(\"Enter a command (or 'exit' to quit): \") if cmd.lower() == 'exit': print(\"Exiting the loop.\") break else: print(f\"You entered: {cmd}\")","title":"Control Flow"},{"location":"examples/06_control_flow/#control-flow","text":"","title":"Control Flow"},{"location":"examples/06_control_flow/#control-with-break-statement","text":"# Exiting loops prematurely with the `break` statement. # -------------------------------------------------------------------------------- # The `break` statement is used to exit a loop prematurely. It can be used in # both `for` and `while` loops. When the `break` statement is encountered, # the loop is terminated immediately, and control is transferred to the next # statement following the loop. # Break statement inside for loop val = int(input(\"Guess a number: \")) for i in range(1, 10): if val == i: print(\"You guessed the number!\") break else: print(\"You did not guess the number!\") # Break statement inside while loop val = int(input(\"Guess a new number: \")) i = 0 while i < 10: if val == i: print(\"You guessed the number!\") break i += 1 else: print(\"You did not guess the number!\")","title":"Control With Break Statement"},{"location":"examples/06_control_flow/#control-with-continue-statement","text":"# Skipping iterations in loops with the `continue` statement. # -------------------------------------------------------------------------------- # When the `continue` statement is encountered, the rest of the code # in the current iteration is skipped, and control is transferred to the next # iteration of the loop. numbers = [1, 2, 3, 4, 5, 6] # Print numbers, skipping even numbers and breaking on 5 for num in numbers: if num % 2 == 0: continue elif num == 5: break else: print(num)","title":"Control With Continue Statement"},{"location":"examples/06_control_flow/#control-with-for-statement","text":"# Iterating over sequences using `for` loops. # -------------------------------------------------------------------------------- # Loops that use the `for` statement to iterate over a sequence or other # iterable objects are useful for executing a block of code a fixed number of # times (we know the number of iterations in advance). fruits = [\"apple\", \"banana\", \"cherry\"] for fruit in fruits: print(fruit)","title":"Control With For Statement"},{"location":"examples/06_control_flow/#control-with-if-statement","text":"# Conditional logic using `if`, `elif`, and `else` to handle different cases based on conditions. # -------------------------------------------------------------------------------- # The conditional statements in Python allow you to control the flow of your # program based on certain conditions. This way we can execute different # blocks of code depending on the condition that is met. # # Bear in mind that if a condition is met, the code block will be executed and # the rest of the code blocks will be skipped. If no condition is met, the # code block in the `else` statement will be executed, if it exists. var = int(input('Enter value: ')) if 1 <= var <= 10: print(\"Variable is a valid positive number\") elif -10 <= var <= -1: print(\"Variable is a valid negative number\") else: print(\"Variable is not a valid positive or negative number\")","title":"Control With If Statement"},{"location":"examples/06_control_flow/#control-with-pass-statement","text":"# Using `pass` as a placeholder or to handle empty code blocks. # -------------------------------------------------------------------------------- # The `pass` statement in Python is used as a placeholder for future code or # to handle empty code blocks. It allows you to write syntactically correct # code without implementing any functionality yet. val = input(\"Enter value: \") if val in ('', ' ', None): pass # Placeholder for future code else: print(val)","title":"Control With Pass Statement"},{"location":"examples/06_control_flow/#control-with-while-statement","text":"# Repeating code with `while` loops until a condition is met. # -------------------------------------------------------------------------------- # Loops that use the `while` statement to repeat a block of code as long as a # condition is true. This is useful when the number of iterations is not known # beforehand, and the loop continues until a specific condition is met. while True: cmd = input(\"Enter a command (or 'exit' to quit): \") if cmd.lower() == 'exit': print(\"Exiting the loop.\") break else: print(f\"You entered: {cmd}\")","title":"Control With While Statement"},{"location":"examples/07_functions/","text":"Functions Func Annotations # Function annotations for parameters and return values # -------------------------------------------------------------------------------- # Annotations in Python functions allow you to specify the expected types of # parameters and the return type of the function. This can help with code # readability and static type checking. # # There are no strict rules enforced by Python regarding these annotations, # but they serve as a guide for developers and can be used by tools like # type checkers, IDEs, and documentation generators. def add(x: int, y: int) -> int: return x + y Func Attributes # Adding attributes to functions # -------------------------------------------------------------------------------- # Functions in Python are first-class objects, which means they can have # attributes just like any other object. Attributes are accessed using # the dot notation (e.g. `foo.name`), and can be used to store metadata # about the function, such as its name, description, or author. def foo(): pass foo.name = \"MyFunc\" foo.description = \"This is my function\" foo.author = \"Me\" print(foo.author) # Output: Me print(foo.name) # Output: MyFunc print(foo.description) # This is my function Func Attributes Decorator # Adding attributes to functions using decorators # -------------------------------------------------------------------------------- # Sometimes you may want to add metadata to a function, such as an author # name or version without modifying the function's code directly. A good way # to do this is by using a decorator. Decorators are functions that modify # the behavior of another function. In this case, we can create a decorator # that adds an attribute to the function it decorates. def owned(func): func.author = \"Branimir Georgiev\" return func @owned def hello(): pass print(hello.author) # Output: Branimir Georgiev Func Callback # Using callback functions to handle events # -------------------------------------------------------------------------------- # A callback function is passed as an argument to another function and executed # when a particular event occurs. This technique lets the caller customize # behavior without changing the callee. Callbacks are common in event-driven # architectures and asynchronous code. _listeners = {} def on(event_name, callback): _listeners.setdefault(event_name, []).append(callback) def emit(event_name, *args, **kwargs): for callback in _listeners.get(event_name, []): callback(*args, **kwargs) def handle_data(data): print(f\"[DATA] Received: {data!r}\") def handle_error(msg): print(f\"[ERROR] {msg}\") on(\"data\", handle_data) on(\"error\", handle_error) emit(\"data\", {\"id\": 1, \"value\": 42}) emit(\"data\", {\"id\": 2, \"value\": 99}) emit(\"error\", \"Timeout occurred\") Func Closures # Closures in Python # -------------------------------------------------------------------------------- # A closure in Python is a function object that \u201cremembers\u201d values from its # enclosing scope even when that scope has finished execution. In other # words, a closure lets you bind variables from an outer function into an # inner function, and keep using them later. def greet(message): def inner_function(name): return \"{} {}\".format(message, name) return inner_function welcome = greet(\"Welcome\") print(welcome('Branko')) # Output: Welcome Branko print(greet('Hello')('Branko')) # Output: Hello Branko Func Decorator # Decorators to modify or extend function behavior # -------------------------------------------------------------------------------- # A decorator is a function that takes another function as an argument, # modifies or extends its behavior, and returns a new function. They are # related to closures, as they can access variables from the enclosing scope. def decorate(func): \"\"\"A simple decorator function.\"\"\" def wrapper(*args, **kwargs): \"\"\"Wrapper function with additional behavior.\"\"\" result = func(*args, **kwargs) print(f\"Function '{func.__name__}' called with {args} and {kwargs}\") return result return wrapper @decorate def hello_world(): print('Hello world') hello_world() def hello_python(): print('Hello Python') hello_python = decorate(hello_python) hello_python() Func Decorator With Args # Parameterized decorators in Python # -------------------------------------------------------------------------------- # Unfortunately, Python does not support passing parameters to decorators # directly. A decorator of a function has always one argument, which is the # original function to be decorated. # # In order to pass parameters to a decorator, we need to create an enclosing # function that takes the decorator parameters and returns a decorator # function. # # The decorator function will then take the original function as an argument # and return a wrapper function modifying the behavior of the original function. def log(message=\"Operation\"): def decorator(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) print(f\"{message}: {func.__name__} called with args: {args}\") return result return wrapper return decorator @log() def add(a, b): return a + b @log(\"Custom log\") def sub(a, b): return a - b def div(a, b): return a / b add(5, 3) # Output: Operation: add called with args: (5, 3) sub(10, 4) # Output: Custom log: sub called with args: (10, 4) div = log(\"Division operation\")(div) div(10, 2) # Output: Division operation: div called with args: (10, 2) Func Default Arguments # Default arguments in functions # -------------------------------------------------------------------------------- # Functions may define default values for parameters so callers can omit those # arguments. This simplifies the call site and allows optional behavior. # Remember that default expressions are evaluated when the function is defined. def greet(name='Nemo', age=42): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) greet() # Output: Hello, Nemo! You are 42 years old. Func Factory # Function factories to create specialized functions # -------------------------------------------------------------------------------- # A function factory returns a new function tailored to the argument it # receives. It enables creation of many small functions without repeating code. # Each generated function captures the parameters provided to the factory. def power_of(n): def power(x): return x ** n return power # Square root sqrt = power_of(0.5) print(sqrt(100.0)) # Square sqr = power_of(2) print(sqr(10.0)) Func Introspection # Inspect function attributes # -------------------------------------------------------------------------------- # Python stores a variety of metadata about functions on the function object # itself. Attributes such as ``__name__``, ``__doc__`` and ``__code__`` can be # inspected at runtime to learn more about a function's definition. This # introspection ability is useful for debugging and for frameworks that # manipulate functions. def foo(a, b=10, c=20, *args, **kwargs): \"\"\"This is 'foo' function that does nothing.\"\"\" pi = 3.14 def bar(a=1, b=2, c=3, *args, **kwargs): \"\"\"This is 'bar' function that does nothing.\"\"\" print(pi) introspections = { '__globals__': bar.__globals__, '__name__': bar.__name__, '__doc__': bar.__doc__, '__code__': bar.__code__, '__defaults__': bar.__defaults__, '__closure__': bar.__closure__, '__dict__': bar.__dict__, } # A function has a name test = introspections['__name__'] print(\"Getting function attribute __name__ -> {} \".format(test)) # A function has a docstring test = introspections['__doc__'] print(\"Getting function attribute __doc__ -> {} \".format(test)) # A function has default arguments test = introspections['__defaults__'] print(\"Getting function attribute __defaults__ -> {} \".format(test)) # A function has access to the global namespace test = introspections['__globals__'] print(\"Getting function attribute __globals__ -> {} \".format(test)) # A function has a closure test = introspections['__closure__'] print(\"Getting function attribute __closure__ -> {} \".format(test)) # A function has a variables dictionary test = introspections['__dict__'] print(\"Getting function attribute __dict__ -> {} \".format(test)) # A function has a code object test = introspections['__code__'] print(\"Getting function attribute __code__ -> {} \".format(test)) # A code object has name print(test.co_name) bar() # foo(1, 2, 3, 4, 5, c=30, d=40, e=50) foo(a=1, d=40, e=50) Func Keyword Arguments # Calling functions with keyword arguments # -------------------------------------------------------------------------------- # When a function call includes parameter names, the order of those arguments no # longer matters. Keyword arguments make the call site clearer and allow some # parameters to be skipped if they have defaults. They also pair well with # functions that accept many optional settings. def greet(name, age): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) # Calling the greet() function with named arguments greet(name=\"Alice\", age=25) Func Keyword Only Arguments # Keyword-only arguments # -------------------------------------------------------------------------------- # Keyword-only parameters must be specified by name in the call. This avoids # ambiguity and makes the purpose of each argument clear. It is particularly # helpful when a function accepts many optional parameters. # The arguments a and b are keyword-only def keyword_only_arguments(*, a, b): return a + b # The argument a is positional or keyword, b is keyword-only def one_keyword_only_argument(a, *, b): return a + b # The argument a is positional only, b is keyword-only def separate_arguments(a, /, *, b): return a + b Func Lambda Arguments # Lambda functions with multiple arguments # -------------------------------------------------------------------------------- # A lambda expression can accept several parameters just like a regular # function. It is useful for short, inline operations where defining a full # function would be excessive. Here we compute a simple expression using five # arguments. # Multi-parameter lambda x = lambda a, b, c, d, e: (a + b) * (c + d) / e print(x(1, 2, 3, 4, 5)) Func Lambda Assignment # Assigning a lambda expression to a variable # -------------------------------------------------------------------------------- # Lambda expressions can be assigned to variables to create small, unnamed # functions on the fly. Doing so lets you reuse the lambda just like a regular # function object. This pattern is handy for callbacks or short computations. nop = lambda: None print(nop()) Func Lambda Bytecodes # Lambda and def produce the same bytecode # -------------------------------------------------------------------------------- # This script compiles a lambda expression and a regular function to compare # their bytecode output. Both forms compile into nearly identical instructions. # Using ``lambda`` therefore carries no extra runtime cost compared to ``def``. import dis func1 = lambda x: x * x def func2(x): return x * x print(dis.dis(func1)) print(dis.dis(func2)) Func Lambda Conditional # Conditional lambda # -------------------------------------------------------------------------------- # A lambda can contain a conditional expression to produce different values # based on its input. This one returns ``1`` when the argument is positive and # ``0`` otherwise. Such compact expressions are useful for simple # transformations. y = lambda b: 1 if b > 0 else 0 print(y(-1), y(0), y(1)) Func Lambda Nested Conditions # Lambda function with nested conditionals # -------------------------------------------------------------------------------- # This lambda expression checks two ranges using nested conditional operators. # It returns ``1`` when the argument exceeds 10 or falls below -10 and ``0`` in # all other cases. The expression remains concise despite the multiple branches. z = lambda c: 1 if c > 10 else (1 if c < -10 else 0) print(-11, -10, -1, 0, 1, 10, 11, sep='\\t') print(z(-11), z(-10), z(-1), z(0), z(1), z(10), z(11), sep='\\t') Func Lambda Recursive # Lambda function with recursion # -------------------------------------------------------------------------------- # Although lambdas are typically simple, they can also be used recursively. # The expression here computes factorial by calling itself for successive # decrements. Assigning the lambda to a variable is required so it can # reference itself. x = lambda a: a * x(a - 1) if a > 1 else 1 print(x(5)) Func Lambda Syntax # Lambda functions # -------------------------------------------------------------------------------- # Lambda expressions provide a compact way to create anonymous functions. # They consist of a parameter list, a colon and a single expression that becomes # the return value. Because they are limited to one expression, lambdas are best # suited for small operations. \"\"\" lambda [param1, param2, ..]: expression Lambda functions are one-line functions which return an expression using the pre-defined parameters param1, param2, ... paramN. Lambda functions are normally used for quick operations on data, most notably in combination with map, filter, reduce. \"\"\" # Define a list to iterate over data_in = [1, 2, 3] # Use a lambda function to square the input and then map the result to a list `data_out` data_out = list(map(lambda x: x * x, data_in)) # Print the result print(data_in, data_out) Func Memoization # Memoization with an inner function that caches results # -------------------------------------------------------------------------------- # The inner ``memoized_fibonacci`` function stores each computed Fibonacci # number in the ``cache`` dictionary. On subsequent calls with the same # argument, the cached value is returned instead of recalculating it. This # avoids redundant work and illustrates the principle of memoization. # Explicit memoization using a dictionary def fibonacci(n): cache = {} def memoized_fibonacci(n): if n in cache: return cache[n] if n <= 1: result = n else: result = memoized_fibonacci(n - 1) + memoized_fibonacci(n - 2) cache[n] = result return result return memoized_fibonacci(n) print(fibonacci(5)) print(fibonacci(10)) # Memoization using a decorator (the internal cache is a dictionary) from functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) print(fib(5)) print(fib(10)) Func Nested # Nested functions and their access to enclosing variables # -------------------------------------------------------------------------------- # Inner functions can access variables from the outer function that defines # them. This ability creates a closure which preserves the environment even # after the outer function has finished executing. It allows the inner function # to operate using data that would otherwise be out of scope. def absolute_value(x): # Emulate the built-in abs() function, e.g. abs(-1) == 1 and abs(1) == 1 def negative_value(): # An inner function can access the variables of the outer function return -x def positive_value(): # An inner function can also access the variables of the outer function return x # Use the inner functions to return the correct value return negative_value() if x < 0 else positive_value() print(absolute_value(-1)) # 1 print(absolute_value(1)) # 1 Func Positional Arguments # Using positional arguments # -------------------------------------------------------------------------------- # Each value is matched to a parameter based on where it appears, so the order # of the provided arguments matters. Positional parameters correspond directly # to the order defined in the function signature. Mixing up the order can lead # to incorrect results or errors. def greet(name, age): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) # Calling the greet() function with positional arguments greet(\"Alice\", 25) Func Positional Only Arguments # Positional-only arguments # -------------------------------------------------------------------------------- # Some parameters can be declared positional-only so they cannot be passed by # name. This keeps the API minimal and prevents accidental clashes with keyword # arguments. The syntax uses a ``/`` in the parameter list to mark the end of # positional-only parameters. # The arguments a and b are positional-only def positional_only_arguments(a, b, /): return a + b # The argument a is positional-only, b is positional or keyword def one_positional_only_argument(a, /, b): return a + b Func Recursion # Recursive functions in Python # -------------------------------------------------------------------------------- # A recursive function repeatedly calls itself with a simpler version of the # original problem. Each call works toward a base case that stops the recursion. # This technique is often used for tasks that can be defined in terms of similar # subproblems. def factorial(n): # Base case if n == 0: return 1 # Recursive case else: return n * factorial(n - 1) test_function = factorial(5) print(test_function) Func Scope # Understanding variable scope in Python # -------------------------------------------------------------------------------- # There are two types of variable scope in Python: global and local. If a # local variable has the same name as a global variable, the local variable # will take precedence within the function. # # If the function needs to use the global variable, it must declare it as # global using the `global` keyword. # # !!! WARNING !!! # Modifying a global variable inside a function can lead to unexpected behavior # and should be done with caution. A good practice is to avoid the use of # global variables altogether, unless absolutely necessary. var = 1 print(var) # Output: 1 # Local variable with the same name def func_local_var(): # Redefine the variable within the function scope var = 2 print(var) func_local_var() print(var) # Output: 1 def func_using_global_var(): # Declare that we want to use the global variable global var var = 3 print(var) func_using_global_var() Func Structure # Anatomy of a Python function # -------------------------------------------------------------------------------- # A function definition begins with the ``def`` keyword followed by its name and # parameters. The body can perform operations using those parameters and return # a value. Well-documented functions include a docstring that briefly states # their purpose. def function_name(parameter1, parameter2): \"\"\" Docstring: description of the function \"\"\" # Code to be executed when the function is called result = parameter1 + parameter2 print(result) # Return statement (optional) return result Func Unpacking Arguments # Argument unpacking with `*args` # -------------------------------------------------------------------------------- # When calling a function, the star operator can expand an iterable into # positional arguments. This allows you to store the arguments in a list or # other iterable and pass them all at once. def my_function(a, b, c): print(a, b, c) args = [1, 2, 3] my_function(*args) Func Variable Arguments Python2 # Handling a variable number of arguments in Python 2 # -------------------------------------------------------------------------------- # This code captures extra positional arguments with ``*args`` and extra # keyword arguments with ``**kwargs`` when keyword-only parameters are # unavailable. In Python 3 you can declare keyword-only parameters using the # ``*`` separator instead of relying on ``**kwargs``. See # ``func_variable_arguments_python3.py`` for comparison. def variable_number_of_arguments(a, b, *args, **kwargs): print(\"a: {a}\".format(a=a)) print(\"b: {b}\".format(b=b)) print(\"args: {args}\".format(args=args)) print(\"kwargs: {kwargs}\".format(kwargs=kwargs)) variable_number_of_arguments(1, 2, 3, c=4) Func Variable Arguments Python3 # Mixing positional arguments with keyword-only arguments # -------------------------------------------------------------------------------- # Python 3 lets you combine regular positional parameters with ``*args`` and # keyword-only parameters that have default values. The `*` separator defines # that the positional parameters until a key-value pair is encountered. def variable_number_of_arguments(a, *args, b=1, **kwargs): print(f\"a: {a}\") print(f\"b: {b}\") print(f\"args: {args}\") print(f\"kwargs: {kwargs}\") variable_number_of_arguments(1, 2, 3, c=4)","title":"Functions"},{"location":"examples/07_functions/#functions","text":"","title":"Functions"},{"location":"examples/07_functions/#func-annotations","text":"# Function annotations for parameters and return values # -------------------------------------------------------------------------------- # Annotations in Python functions allow you to specify the expected types of # parameters and the return type of the function. This can help with code # readability and static type checking. # # There are no strict rules enforced by Python regarding these annotations, # but they serve as a guide for developers and can be used by tools like # type checkers, IDEs, and documentation generators. def add(x: int, y: int) -> int: return x + y","title":"Func Annotations"},{"location":"examples/07_functions/#func-attributes","text":"# Adding attributes to functions # -------------------------------------------------------------------------------- # Functions in Python are first-class objects, which means they can have # attributes just like any other object. Attributes are accessed using # the dot notation (e.g. `foo.name`), and can be used to store metadata # about the function, such as its name, description, or author. def foo(): pass foo.name = \"MyFunc\" foo.description = \"This is my function\" foo.author = \"Me\" print(foo.author) # Output: Me print(foo.name) # Output: MyFunc print(foo.description) # This is my function","title":"Func Attributes"},{"location":"examples/07_functions/#func-attributes-decorator","text":"# Adding attributes to functions using decorators # -------------------------------------------------------------------------------- # Sometimes you may want to add metadata to a function, such as an author # name or version without modifying the function's code directly. A good way # to do this is by using a decorator. Decorators are functions that modify # the behavior of another function. In this case, we can create a decorator # that adds an attribute to the function it decorates. def owned(func): func.author = \"Branimir Georgiev\" return func @owned def hello(): pass print(hello.author) # Output: Branimir Georgiev","title":"Func Attributes Decorator"},{"location":"examples/07_functions/#func-callback","text":"# Using callback functions to handle events # -------------------------------------------------------------------------------- # A callback function is passed as an argument to another function and executed # when a particular event occurs. This technique lets the caller customize # behavior without changing the callee. Callbacks are common in event-driven # architectures and asynchronous code. _listeners = {} def on(event_name, callback): _listeners.setdefault(event_name, []).append(callback) def emit(event_name, *args, **kwargs): for callback in _listeners.get(event_name, []): callback(*args, **kwargs) def handle_data(data): print(f\"[DATA] Received: {data!r}\") def handle_error(msg): print(f\"[ERROR] {msg}\") on(\"data\", handle_data) on(\"error\", handle_error) emit(\"data\", {\"id\": 1, \"value\": 42}) emit(\"data\", {\"id\": 2, \"value\": 99}) emit(\"error\", \"Timeout occurred\")","title":"Func Callback"},{"location":"examples/07_functions/#func-closures","text":"# Closures in Python # -------------------------------------------------------------------------------- # A closure in Python is a function object that \u201cremembers\u201d values from its # enclosing scope even when that scope has finished execution. In other # words, a closure lets you bind variables from an outer function into an # inner function, and keep using them later. def greet(message): def inner_function(name): return \"{} {}\".format(message, name) return inner_function welcome = greet(\"Welcome\") print(welcome('Branko')) # Output: Welcome Branko print(greet('Hello')('Branko')) # Output: Hello Branko","title":"Func Closures"},{"location":"examples/07_functions/#func-decorator","text":"# Decorators to modify or extend function behavior # -------------------------------------------------------------------------------- # A decorator is a function that takes another function as an argument, # modifies or extends its behavior, and returns a new function. They are # related to closures, as they can access variables from the enclosing scope. def decorate(func): \"\"\"A simple decorator function.\"\"\" def wrapper(*args, **kwargs): \"\"\"Wrapper function with additional behavior.\"\"\" result = func(*args, **kwargs) print(f\"Function '{func.__name__}' called with {args} and {kwargs}\") return result return wrapper @decorate def hello_world(): print('Hello world') hello_world() def hello_python(): print('Hello Python') hello_python = decorate(hello_python) hello_python()","title":"Func Decorator"},{"location":"examples/07_functions/#func-decorator-with-args","text":"# Parameterized decorators in Python # -------------------------------------------------------------------------------- # Unfortunately, Python does not support passing parameters to decorators # directly. A decorator of a function has always one argument, which is the # original function to be decorated. # # In order to pass parameters to a decorator, we need to create an enclosing # function that takes the decorator parameters and returns a decorator # function. # # The decorator function will then take the original function as an argument # and return a wrapper function modifying the behavior of the original function. def log(message=\"Operation\"): def decorator(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) print(f\"{message}: {func.__name__} called with args: {args}\") return result return wrapper return decorator @log() def add(a, b): return a + b @log(\"Custom log\") def sub(a, b): return a - b def div(a, b): return a / b add(5, 3) # Output: Operation: add called with args: (5, 3) sub(10, 4) # Output: Custom log: sub called with args: (10, 4) div = log(\"Division operation\")(div) div(10, 2) # Output: Division operation: div called with args: (10, 2)","title":"Func Decorator With Args"},{"location":"examples/07_functions/#func-default-arguments","text":"# Default arguments in functions # -------------------------------------------------------------------------------- # Functions may define default values for parameters so callers can omit those # arguments. This simplifies the call site and allows optional behavior. # Remember that default expressions are evaluated when the function is defined. def greet(name='Nemo', age=42): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) greet() # Output: Hello, Nemo! You are 42 years old.","title":"Func Default Arguments"},{"location":"examples/07_functions/#func-factory","text":"# Function factories to create specialized functions # -------------------------------------------------------------------------------- # A function factory returns a new function tailored to the argument it # receives. It enables creation of many small functions without repeating code. # Each generated function captures the parameters provided to the factory. def power_of(n): def power(x): return x ** n return power # Square root sqrt = power_of(0.5) print(sqrt(100.0)) # Square sqr = power_of(2) print(sqr(10.0))","title":"Func Factory"},{"location":"examples/07_functions/#func-introspection","text":"# Inspect function attributes # -------------------------------------------------------------------------------- # Python stores a variety of metadata about functions on the function object # itself. Attributes such as ``__name__``, ``__doc__`` and ``__code__`` can be # inspected at runtime to learn more about a function's definition. This # introspection ability is useful for debugging and for frameworks that # manipulate functions. def foo(a, b=10, c=20, *args, **kwargs): \"\"\"This is 'foo' function that does nothing.\"\"\" pi = 3.14 def bar(a=1, b=2, c=3, *args, **kwargs): \"\"\"This is 'bar' function that does nothing.\"\"\" print(pi) introspections = { '__globals__': bar.__globals__, '__name__': bar.__name__, '__doc__': bar.__doc__, '__code__': bar.__code__, '__defaults__': bar.__defaults__, '__closure__': bar.__closure__, '__dict__': bar.__dict__, } # A function has a name test = introspections['__name__'] print(\"Getting function attribute __name__ -> {} \".format(test)) # A function has a docstring test = introspections['__doc__'] print(\"Getting function attribute __doc__ -> {} \".format(test)) # A function has default arguments test = introspections['__defaults__'] print(\"Getting function attribute __defaults__ -> {} \".format(test)) # A function has access to the global namespace test = introspections['__globals__'] print(\"Getting function attribute __globals__ -> {} \".format(test)) # A function has a closure test = introspections['__closure__'] print(\"Getting function attribute __closure__ -> {} \".format(test)) # A function has a variables dictionary test = introspections['__dict__'] print(\"Getting function attribute __dict__ -> {} \".format(test)) # A function has a code object test = introspections['__code__'] print(\"Getting function attribute __code__ -> {} \".format(test)) # A code object has name print(test.co_name) bar() # foo(1, 2, 3, 4, 5, c=30, d=40, e=50) foo(a=1, d=40, e=50)","title":"Func Introspection"},{"location":"examples/07_functions/#func-keyword-arguments","text":"# Calling functions with keyword arguments # -------------------------------------------------------------------------------- # When a function call includes parameter names, the order of those arguments no # longer matters. Keyword arguments make the call site clearer and allow some # parameters to be skipped if they have defaults. They also pair well with # functions that accept many optional settings. def greet(name, age): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) # Calling the greet() function with named arguments greet(name=\"Alice\", age=25)","title":"Func Keyword Arguments"},{"location":"examples/07_functions/#func-keyword-only-arguments","text":"# Keyword-only arguments # -------------------------------------------------------------------------------- # Keyword-only parameters must be specified by name in the call. This avoids # ambiguity and makes the purpose of each argument clear. It is particularly # helpful when a function accepts many optional parameters. # The arguments a and b are keyword-only def keyword_only_arguments(*, a, b): return a + b # The argument a is positional or keyword, b is keyword-only def one_keyword_only_argument(a, *, b): return a + b # The argument a is positional only, b is keyword-only def separate_arguments(a, /, *, b): return a + b","title":"Func Keyword Only Arguments"},{"location":"examples/07_functions/#func-lambda-arguments","text":"# Lambda functions with multiple arguments # -------------------------------------------------------------------------------- # A lambda expression can accept several parameters just like a regular # function. It is useful for short, inline operations where defining a full # function would be excessive. Here we compute a simple expression using five # arguments. # Multi-parameter lambda x = lambda a, b, c, d, e: (a + b) * (c + d) / e print(x(1, 2, 3, 4, 5))","title":"Func Lambda Arguments"},{"location":"examples/07_functions/#func-lambda-assignment","text":"# Assigning a lambda expression to a variable # -------------------------------------------------------------------------------- # Lambda expressions can be assigned to variables to create small, unnamed # functions on the fly. Doing so lets you reuse the lambda just like a regular # function object. This pattern is handy for callbacks or short computations. nop = lambda: None print(nop())","title":"Func Lambda Assignment"},{"location":"examples/07_functions/#func-lambda-bytecodes","text":"# Lambda and def produce the same bytecode # -------------------------------------------------------------------------------- # This script compiles a lambda expression and a regular function to compare # their bytecode output. Both forms compile into nearly identical instructions. # Using ``lambda`` therefore carries no extra runtime cost compared to ``def``. import dis func1 = lambda x: x * x def func2(x): return x * x print(dis.dis(func1)) print(dis.dis(func2))","title":"Func Lambda Bytecodes"},{"location":"examples/07_functions/#func-lambda-conditional","text":"# Conditional lambda # -------------------------------------------------------------------------------- # A lambda can contain a conditional expression to produce different values # based on its input. This one returns ``1`` when the argument is positive and # ``0`` otherwise. Such compact expressions are useful for simple # transformations. y = lambda b: 1 if b > 0 else 0 print(y(-1), y(0), y(1))","title":"Func Lambda Conditional"},{"location":"examples/07_functions/#func-lambda-nested-conditions","text":"# Lambda function with nested conditionals # -------------------------------------------------------------------------------- # This lambda expression checks two ranges using nested conditional operators. # It returns ``1`` when the argument exceeds 10 or falls below -10 and ``0`` in # all other cases. The expression remains concise despite the multiple branches. z = lambda c: 1 if c > 10 else (1 if c < -10 else 0) print(-11, -10, -1, 0, 1, 10, 11, sep='\\t') print(z(-11), z(-10), z(-1), z(0), z(1), z(10), z(11), sep='\\t')","title":"Func Lambda Nested Conditions"},{"location":"examples/07_functions/#func-lambda-recursive","text":"# Lambda function with recursion # -------------------------------------------------------------------------------- # Although lambdas are typically simple, they can also be used recursively. # The expression here computes factorial by calling itself for successive # decrements. Assigning the lambda to a variable is required so it can # reference itself. x = lambda a: a * x(a - 1) if a > 1 else 1 print(x(5))","title":"Func Lambda Recursive"},{"location":"examples/07_functions/#func-lambda-syntax","text":"# Lambda functions # -------------------------------------------------------------------------------- # Lambda expressions provide a compact way to create anonymous functions. # They consist of a parameter list, a colon and a single expression that becomes # the return value. Because they are limited to one expression, lambdas are best # suited for small operations. \"\"\" lambda [param1, param2, ..]: expression Lambda functions are one-line functions which return an expression using the pre-defined parameters param1, param2, ... paramN. Lambda functions are normally used for quick operations on data, most notably in combination with map, filter, reduce. \"\"\" # Define a list to iterate over data_in = [1, 2, 3] # Use a lambda function to square the input and then map the result to a list `data_out` data_out = list(map(lambda x: x * x, data_in)) # Print the result print(data_in, data_out)","title":"Func Lambda Syntax"},{"location":"examples/07_functions/#func-memoization","text":"# Memoization with an inner function that caches results # -------------------------------------------------------------------------------- # The inner ``memoized_fibonacci`` function stores each computed Fibonacci # number in the ``cache`` dictionary. On subsequent calls with the same # argument, the cached value is returned instead of recalculating it. This # avoids redundant work and illustrates the principle of memoization. # Explicit memoization using a dictionary def fibonacci(n): cache = {} def memoized_fibonacci(n): if n in cache: return cache[n] if n <= 1: result = n else: result = memoized_fibonacci(n - 1) + memoized_fibonacci(n - 2) cache[n] = result return result return memoized_fibonacci(n) print(fibonacci(5)) print(fibonacci(10)) # Memoization using a decorator (the internal cache is a dictionary) from functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n < 2: return n return fib(n-1) + fib(n-2) print(fib(5)) print(fib(10))","title":"Func Memoization"},{"location":"examples/07_functions/#func-nested","text":"# Nested functions and their access to enclosing variables # -------------------------------------------------------------------------------- # Inner functions can access variables from the outer function that defines # them. This ability creates a closure which preserves the environment even # after the outer function has finished executing. It allows the inner function # to operate using data that would otherwise be out of scope. def absolute_value(x): # Emulate the built-in abs() function, e.g. abs(-1) == 1 and abs(1) == 1 def negative_value(): # An inner function can access the variables of the outer function return -x def positive_value(): # An inner function can also access the variables of the outer function return x # Use the inner functions to return the correct value return negative_value() if x < 0 else positive_value() print(absolute_value(-1)) # 1 print(absolute_value(1)) # 1","title":"Func Nested"},{"location":"examples/07_functions/#func-positional-arguments","text":"# Using positional arguments # -------------------------------------------------------------------------------- # Each value is matched to a parameter based on where it appears, so the order # of the provided arguments matters. Positional parameters correspond directly # to the order defined in the function signature. Mixing up the order can lead # to incorrect results or errors. def greet(name, age): print(\"Hello, {0}! You are {1} years old.\".format(name, age)) # Calling the greet() function with positional arguments greet(\"Alice\", 25)","title":"Func Positional Arguments"},{"location":"examples/07_functions/#func-positional-only-arguments","text":"# Positional-only arguments # -------------------------------------------------------------------------------- # Some parameters can be declared positional-only so they cannot be passed by # name. This keeps the API minimal and prevents accidental clashes with keyword # arguments. The syntax uses a ``/`` in the parameter list to mark the end of # positional-only parameters. # The arguments a and b are positional-only def positional_only_arguments(a, b, /): return a + b # The argument a is positional-only, b is positional or keyword def one_positional_only_argument(a, /, b): return a + b","title":"Func Positional Only Arguments"},{"location":"examples/07_functions/#func-recursion","text":"# Recursive functions in Python # -------------------------------------------------------------------------------- # A recursive function repeatedly calls itself with a simpler version of the # original problem. Each call works toward a base case that stops the recursion. # This technique is often used for tasks that can be defined in terms of similar # subproblems. def factorial(n): # Base case if n == 0: return 1 # Recursive case else: return n * factorial(n - 1) test_function = factorial(5) print(test_function)","title":"Func Recursion"},{"location":"examples/07_functions/#func-scope","text":"# Understanding variable scope in Python # -------------------------------------------------------------------------------- # There are two types of variable scope in Python: global and local. If a # local variable has the same name as a global variable, the local variable # will take precedence within the function. # # If the function needs to use the global variable, it must declare it as # global using the `global` keyword. # # !!! WARNING !!! # Modifying a global variable inside a function can lead to unexpected behavior # and should be done with caution. A good practice is to avoid the use of # global variables altogether, unless absolutely necessary. var = 1 print(var) # Output: 1 # Local variable with the same name def func_local_var(): # Redefine the variable within the function scope var = 2 print(var) func_local_var() print(var) # Output: 1 def func_using_global_var(): # Declare that we want to use the global variable global var var = 3 print(var) func_using_global_var()","title":"Func Scope"},{"location":"examples/07_functions/#func-structure","text":"# Anatomy of a Python function # -------------------------------------------------------------------------------- # A function definition begins with the ``def`` keyword followed by its name and # parameters. The body can perform operations using those parameters and return # a value. Well-documented functions include a docstring that briefly states # their purpose. def function_name(parameter1, parameter2): \"\"\" Docstring: description of the function \"\"\" # Code to be executed when the function is called result = parameter1 + parameter2 print(result) # Return statement (optional) return result","title":"Func Structure"},{"location":"examples/07_functions/#func-unpacking-arguments","text":"# Argument unpacking with `*args` # -------------------------------------------------------------------------------- # When calling a function, the star operator can expand an iterable into # positional arguments. This allows you to store the arguments in a list or # other iterable and pass them all at once. def my_function(a, b, c): print(a, b, c) args = [1, 2, 3] my_function(*args)","title":"Func Unpacking Arguments"},{"location":"examples/07_functions/#func-variable-arguments-python2","text":"# Handling a variable number of arguments in Python 2 # -------------------------------------------------------------------------------- # This code captures extra positional arguments with ``*args`` and extra # keyword arguments with ``**kwargs`` when keyword-only parameters are # unavailable. In Python 3 you can declare keyword-only parameters using the # ``*`` separator instead of relying on ``**kwargs``. See # ``func_variable_arguments_python3.py`` for comparison. def variable_number_of_arguments(a, b, *args, **kwargs): print(\"a: {a}\".format(a=a)) print(\"b: {b}\".format(b=b)) print(\"args: {args}\".format(args=args)) print(\"kwargs: {kwargs}\".format(kwargs=kwargs)) variable_number_of_arguments(1, 2, 3, c=4)","title":"Func Variable Arguments Python2"},{"location":"examples/07_functions/#func-variable-arguments-python3","text":"# Mixing positional arguments with keyword-only arguments # -------------------------------------------------------------------------------- # Python 3 lets you combine regular positional parameters with ``*args`` and # keyword-only parameters that have default values. The `*` separator defines # that the positional parameters until a key-value pair is encountered. def variable_number_of_arguments(a, *args, b=1, **kwargs): print(f\"a: {a}\") print(f\"b: {b}\") print(f\"args: {args}\") print(f\"kwargs: {kwargs}\") variable_number_of_arguments(1, 2, 3, c=4)","title":"Func Variable Arguments Python3"},{"location":"examples/08_classes/","text":"Classes Class Abstract Properties # Stacking decorators # -------------------------------------------------------------------------------- # Multiple decorators can be stacked on a single attribute. In this file a # property is defined using @property together with @abstractmethod. Derived # classes must supply the concrete implementation for this decorated property. from abc import ABCMeta, abstractmethod from six import with_metaclass class DeviceAbc(with_metaclass(ABCMeta)): \"\"\"Example abstract class Usage: # Optional @property, @staticmethod, @classmethod + # Obligatory decorator @abstractmethod Example: # Defines and abstract property @property @abstractmethod def prop(self): ... \"\"\" def __init__(self): self._bar = \"bar\" @property @abstractmethod def bar(self): pass @abstractmethod def foo(self): pass class Samsung(DeviceAbc): @property def bar(self): return self._bar def foo(self): print('foo') test = Samsung() print(test.bar) test.foo() Class Abstract Python2 # Abstract class using the six library for python 2 # -------------------------------------------------------------------------------- # The six library helps define abstract base classes that remain compatible with # Python 2. The metaclass provided by six works with decorators such as # @abstractmethod so subclasses must implement the required methods. from six import with_metaclass from abc import ABCMeta, abstractmethod class CalculatorAbc(with_metaclass(ABCMeta)): def __init__(self, mode=\"basic\"): self.mode = mode @abstractmethod def add(self, *args, **kwargs): raise NotImplementedError @abstractmethod def subtract(self, *args, **kwargs): raise NotImplementedError class Calculator(CalculatorAbc): def add(self, a, b): return a + b def subtract(self, a, b): return a - b calc = Calculator() print(calc.add(1, 2)) print(calc.mode) Class Abstract Python3 # Abstract class in python 3+ # -------------------------------------------------------------------------------- # Python 3 provides native support for abstract base classes. The ABC and # abstractmethod decorators ensure that child classes implement required # behavior. Instances cannot be created until the abstract methods are # overridden. from abc import ABC, abstractmethod class CalculatorAbc(ABC): def __init__(self, mode=\"basic\"): self.mode = mode @abstractmethod def add(self, *args, **kwargs): raise NotImplementedError @abstractmethod def subtract(self, *args, **kwargs): raise NotImplementedError class Calculator(CalculatorAbc): def add(self, a, b): return a + b def subtract(self, a, b): return a - b calc = Calculator() print(calc.add(1, 2)) print(calc.mode) Class As Blueprint # Class as template # -------------------------------------------------------------------------------- # A class can act as a template from which many objects are built. This file # defines a Person blueprint containing attributes and methods that every # instance will share. class Person(object): def __init__(self, name, age): self.name = name self.age = age def say_hello(self): print(\"Hello, my name is {} and my age is {}\".format(self.name, self.age)) Class As Concrete Object # Object as concrete realization of a class # -------------------------------------------------------------------------------- # The code creates an instance of the Person class as a tangible object. # The constructor assigns initial values to the instance. After creation, the # object can call its methods and access stored data. from class_as_blueprint import Person John = Person(\"John\", 32) John.say_hello() Class Constructor Conditional Inheritance # Conditional inheritance using the __new__ method # -------------------------------------------------------------------------------- # The __new__ method can decide which subclass to instantiate. By inspecting # runtime conditions it returns objects of different types from a single # factory class. This approach allows conditional inheritance without altering # the class hierarchy. class WindowsCalculator(object): \"\"\" Windows calculator class operations \"\"\" @staticmethod def do(): print(\"Do in Windows Calculator\") class LinuxCalculator(object): \"\"\" Linux calculator class operations \"\"\" @staticmethod def do(): print(\"Do in Linux Calculator\") class Calculator(object): def __new__(cls, os=\"windows\"): # Windows base class if os == \"windows\": parents = (WindowsCalculator, ) # Linux base class elif os == \"linux\": parents = (LinuxCalculator, ) # Invalid operating system else: raise ValueError(\"Invalid operating system\") # Create a new class with the given name and bases cls = type(\"Calculator\", parents, {}) # Return an instance of the new class return cls() # Create a new instance of the Calculator class calc = Calculator(\"windows\") # Check if the Calculator class is a subclass of the WindowsCalculator class test = issubclass(type(calc), WindowsCalculator) print(\"Is subclass of WindowsCalculator? [{}]\".format(test)) # Call the do method calc.do() Class Constructor Factory # Class factory using the __new__ method # -------------------------------------------------------------------------------- # Overriding __new__ allows a class to act as a factory. The method returns an # instance of a specific subclass based on the provided parameters. This # separates the decision about which object to create from the calling code. class WindowsCalculator(object): @staticmethod def do(): print(\"Do in Windows Calculator\") class LinuxCalculator(object): @staticmethod def do(): print(\"Do in Linux Calculator\") class Calculator(object): def __new__(cls, os=\"windows\"): # An instance of the WindowsCalculator class is returned if os == \"windows\": return object.__new__(WindowsCalculator) # An instance of the LinuxCalculator class is returned elif os == \"linux\": return object.__new__(LinuxCalculator) # Invalid operating system else: raise ValueError(\"Invalid operating system\") # Create a new instance of the Calculator class calc = Calculator(\"windows\") # Check if the Calculator class is an instance of the WindowsCalculator class test = isinstance(calc, WindowsCalculator) print(\"Is instance of WindowsCalculator? [{}]\".format(test)) # Call the do method calc.do() Class Constructor Singleton # Singleton using the __new__ method # -------------------------------------------------------------------------------- # By overriding __new__, this class ensures that only one instance ever exists. # The method stores the created object and returns it on subsequent calls. # Such control over object creation implements the singleton pattern. class Singleton(object): __instance = None def __new__(cls): if cls.__instance is None: print(\"Creating singleton...\") cls.__instance = object.__new__(cls) else: print(\"Singleton already exists...\") return cls.__instance s1 = Singleton() s2 = Singleton() print(s1 == s2) print(s1 is s2) Class Constructors # How __new__ and __init__ cooperate in object creation # -------------------------------------------------------------------------------- # Object creation begins with __new__, which allocates the instance. The fresh # object is then passed to __init__ for further initialization. Separating these # steps gives developers flexibility to customize how objects come into # existence. class Calculator(object): def __new__(cls): # Use the parent class to create the object obj = object.__new__(cls) # Return the object print(\"__new__ : Created object {}\".format(obj)) return obj def __init__(self): # Self is the object that was created by __new__ print(\"__init__: Using object {}\".format(self)) # Add attributes to the object self.name = \"Cool Calculator\" calc = Calculator() print(calc.name) Class Create With Type # Using ``type`` to inspect objects and create classes # -------------------------------------------------------------------------------- # The built-in ``type`` function performs two unrelated tasks. When passed a # single object it returns that object's class, which can be handy for # inspection. When given a name, base classes and attributes it creates a new # class dynamically, allowing programs to define types at runtime. ############################################################################## # USECASE A : Get object type ############################################################################## numbers_list = [1, 2] print(type(numbers_list)) numbers_dict = {1: 'one', 2: 'two'} print(type(numbers_dict)) ############################################################################## # USECASE B : Create class with base classes, attributes and methods ############################################################################## def init(self, name): self.name = name def say_hallo_b(self): return \"Hi, my name is \" + self.name Robot2 = type(\"Robot2\", (), {\"counter\": 0, \"__init__\": init, \"func\": lambda self: \"Hi, I am \" + self.name, \"say_hello_b\": say_hallo_b } ) x = Robot2(\"Marvin\") print(x.name) print(x.func()) print(x.say_hello_b()) Class Decorator For Classes # Class as a decorator for a class # -------------------------------------------------------------------------------- # A class can implement the __call__ method and be applied as a decorator to # another class. When used this way it may attach attributes or modify the # decorated class at definition time. class Counter(object): # The constructor accepts the parameter passed to the decorator def __init__(self, start_value): self.counter = start_value # The __call__ method is called when the class is used as a decorator def __call__(self, cls): # Modify the class by adding an attribute with the specified value cls.counter = self.counter # Return the modified class return cls # Apply the class decorator with a parameter @Counter(start_value=1) class DecoratedClass(object): pass # Use the explicit decorator syntax DecoratedClass = Counter(start_value=1)(DecoratedClass) obj = DecoratedClass() print(obj.counter) # Output: 1 # Use Python's decorator syntax obj = DecoratedClass() print(obj.counter) # Output: Custom Value Class Decorator For Functions # Class as a decorator for functions and methods # -------------------------------------------------------------------------------- # Defining the __call__ method allows a class to wrap functions or methods. # The decorator can maintain state between invocations and perform actions # before or after calling the original function. class Counter(object): def __init__(self, init_value=0): \"\"\" Initialize counter.\"\"\" self._counter = init_value def __call__(self, function): \"\"\" Wrapping call to original function. \"\"\" def wrapper(*args, **kwargs): \"\"\" Wrapper function.\"\"\" try: self._counter += 1 print(\"{}\".format(self._counter)) return function(*args, **kwargs) except Exception as e: print(e) return wrapper def f(): print(\"Hello World\") @Counter(0) def g(): print(\"Hello World\") print(\"#\" * 80) # Use the explicit decorator syntax f = Counter(0)(f) # Call the decorated functions for _ in range(10): f() print(\"#\" * 80) # Use Python's decorator syntax for _ in range(10): g() Class Init State # Initialization with the __init__ method # -------------------------------------------------------------------------------- # The __init__ method runs immediately after an object is created. It assigns # the initial values for the instance and prepares it for use. class Person(object): def __init__(self, name=\"Branimir\", age=40): self.name = name self.age = age print(\"My name is {0} and I am {1} years old\".format(self.name, self.age)) p1 = Person() p2 = Person(\"John\", 30) Class Init Steps # Initialization in multiple steps # -------------------------------------------------------------------------------- # Some objects gather their initial data through a sequence of operations. This # file breaks the process into helper methods that collect the values one by # one. Each step can perform validation before returning its result. class Person(object): def __init__(self): self.name = self.step_1() self.age = self.step_2() @staticmethod def step_1(): name = input(\"Step 1: Enter the person's name: \") return name @staticmethod def step_2(): age = input(\"Step 2: Enter the person's age: \") return age john = Person() print(john.name, john.age) Class Init Validate # Initialization and validation # -------------------------------------------------------------------------------- # Initialization may involve checking that provided values meet certain rules. # The constructor validates input before assigning it to attributes. Invalid # data is rejected to keep the object's state consistent. class Person(object): def __init__(self, name, age): self.name = name self.age = age if not isinstance(self.name, str): raise TypeError(\"Name must be a string\") if not isinstance(self.age, int): raise TypeError(\"Age must be an integer\") if self.age < 0: raise ValueError(\"Age must be a positive integer\") def say_hello(self): print(\"Hello, my name is {} and my age is {}\".format(self.name, self.age)) john = Person(\"John\", 32) john.say_hello() Class Instance # Class instance with concrete values # -------------------------------------------------------------------------------- # After defining the Person class, an instance is created with explicit values. # The object stores these attributes as part of its state. Accessing them later # confirms that the information persists on the instance. class Person(object): def __init__(self): print(\"Person has ID {}\".format(id(self))) # The person object has a unique id p1 = Person() p2 = Person() Class Instance Attributes # Define and access instance attributes # -------------------------------------------------------------------------------- # Instance attributes are defined in the __init__ method. They store data # unique to each object and can be accessed through the instance of the class. # Each instance may hold different values for these attributes. class Person(object): def __init__(self): self.name = \"Branimir\" self.age = 40 # Create the instance p = Person() # Access to the instance attributes print(p.name) print(p.age) Class Instance Methods # Class instance with instance methods # -------------------------------------------------------------------------------- # Instance methods operate on a particular object and have access to its state. # They typically receive the instance as the first parameter. Calling these # methods affects only the object that invoked them. class Person(object): def do_something(self): print(\"{} is doing something\".format(self)) def do_something_with(self, something, someone): print(\"{} is doing {} with {}\".format(self, something, someone)) # Create the instance p = Person() p.do_something() p.do_something_with(\"nothing\", \"no one\") Class Method Create Instance # Class method used to create instances # -------------------------------------------------------------------------------- # A class method can serve as an alternative constructor. It receives the class # as the first argument and builds a new instance from provided data. This # approach collects creation logic in one place. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def from_string(cls, name): return cls(name) p = Person.from_string(\"John\") print(p.name) Class Method Modify Instances # Class method used to modify existing instances of the class # -------------------------------------------------------------------------------- # Class methods can operate on a collection of instances maintained by the # class. The method updates every stored object in a single call. Centralizing # the logic keeps modifications consistent across all instances. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def set_prefix(cls, prefix): cls.NAME_PREFIX = prefix @classmethod def add_prefix(cls, person): person.name = \"{} {}\".format(cls.NAME_PREFIX, person.name) p = Person(\"John\") Person.set_prefix(\"Dr.\") Person.add_prefix(p) print(p.name) Class Method Modify Itself # Class method used to modify the class itself # -------------------------------------------------------------------------------- # Because class methods receive the class as the first argument, they can change # class-level attributes. This file modifies a shared value that affects all # future instances. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def set_prefix(cls, prefix): cls.NAME_PREFIX = prefix p = Person(\"John\") Person.set_prefix(\"Dr.\") print(p.NAME_PREFIX) Class Mixin # Mixin class # -------------------------------------------------------------------------------- # A mixin provides extra methods that can be shared across multiple unrelated # classes. It relies on cooperative multiple inheritance to join its behavior # with that of the main class hierarchy. class RemoteMixin(object): def __init__(self, brand=None, volume=0, *args, **kwargs): # This syntax is required in order to guarantee that the MRO is not broken super(RemoteMixin, self).__init__(*args, **kwargs) # Mixin specific attributes self.brand = brand self.volume = volume def volume_up(self): self.volume += 1 def volume_down(self): self.volume -= 1 def status(self): print(\"Brand: {}\".format(self.brand)) print(\"Volume: {}\".format(self.volume)) class JvcRemote(RemoteMixin, object): \"\"\" Mixins should be always inherited first \"\"\" def __init__(self): super(JvcRemote, self).__init__(brand=\"JVC\", volume=10) def status(self): super(JvcRemote, self).status() @staticmethod def learn(): print(\"Learn button\") class SonyRemote(RemoteMixin, object): \"\"\" Mixins should be always inherited first \"\"\" def __init__(self): super(SonyRemote, self).__init__(brand=\"Sony\", volume=5) @staticmethod def home(): print(\"Home button\") remote = JvcRemote() actions = [\"volume_up\", \"status\", \"volume_down\", \"status\", \"learn\", \"status\"] for action in actions: print(\"Action: {}\".format(action)) func = getattr(remote, action) func() print(\"\\n\") remote = SonyRemote() actions = [\"volume_up\", \"status\", \"volume_down\", \"status\", \"home\", \"status\"] for action in actions: print(\"Action: {}\".format(action)) func = getattr(remote, action) func() Class Mro Bottom First # Mro (method resolution order) - bottom first # -------------------------------------------------------------------------------- # In this layout the interpreter begins searching for methods in the most # derived class and moves upward through the hierarchy. The arrangement helps # clarify how attribute lookup progresses when multiple parents define the same # name. class A(object): @staticmethod def process(): print('A.process()') class B(object): @staticmethod def process(): print('B.process()') class C(A, B): @staticmethod def process(): print('C.process()') obj = C() obj.process() print(C.mro()) Class Mro Complex # Mro (method resolution order) - combined bottom first and left first # -------------------------------------------------------------------------------- # Python resolves method names by considering both the depth of the inheritance # tree and the order in which bases are listed. This file sets up a hierarchy # that makes the combined bottom-first and left-first rules apparent. class A(object): @staticmethod def process(): print(\"A.process()\") class B(object): @staticmethod def process(): print(\"B.process()\") class C(A, B): pass class D(C, B): pass d = D() print(D.mro()) d.process() Class Mro Diamond # Mro (method resolution order) - diamond problem # -------------------------------------------------------------------------------- # A diamond inheritance pattern occurs when two classes share a common base # class. The method resolution order ensures that the base is initialized only # once. The classes here are organized so that each path to the base is # considered without duplication. class A(object): @staticmethod def process(): print(\"A.process()\") class B(A): @staticmethod def process(): print(\"B.process()\") class C(A): @staticmethod def process(): print(\"C.process()\") class D(B, C): pass d = D() print(D.mro()) d.process() Class Mro Left First # Mro (method resolution order) - left first # -------------------------------------------------------------------------------- # With multiple inheritance Python consults base classes from left to right. The # hierarchy in this file highlights how that ordering affects method lookup. class A(object): @staticmethod def process(): print('A.process()') class B(object): @staticmethod def process(): print('B.process()') class C(A, B): pass class D(B, A): pass # The method process is searched for until the first class having the method is found (here A) test = C() print(C.mro()) test.process() # The method process is searched for until the first class having the method is found (here B) test = D() print(D.mro()) test.process() Class Mro Unresolved # Mro (method resolution order) - unresolved # -------------------------------------------------------------------------------- # Some inheritance graphs produce conflicting search orders that Python cannot # resolve. This file sets up such a conflict and triggers an error when the # interpreter tries to build the method resolution order. Understanding this # failure helps diagnose complex inheritance issues. class Player(object): pass class Enemy(Player): pass class GameObject(Player, Enemy): pass # Explanation (see MRO rules in the documentation): # # - MRO is GameObject -> Player -> Enemy -> Player (not monotonic as Player appears twice) # - Rule 2 says Enemy should appear before Player # - Rule 3 says Player should appear before Enemy # # Rules 2 and 3 are in conflict, so the MRO algorithm cannot be applied. This is called an # \"unresolvable inheritance graph\" and Python will raise an exception in this case. g = GameObject() print(GameObject.mro()) Class Multiple Inheritance # Multiple inheritance # -------------------------------------------------------------------------------- # A single class may inherit behavior from several parents. Combining features # this way can reduce duplication but requires careful design to avoid # conflicts. class A(object): @staticmethod def process(): print(\"Class A is processing... \") class B(object): @staticmethod def process(): print(\"Class B is processing... \") class C(A, B): pass class D(B, A): pass # The method process is searched for until the first class having the method is found (here A) test = C() test.process() # The method process is searched for until the first class having the method is found (here B) test = D() test.process() Class Named Constructor Different Params # Named constructors as alternative constructors # -------------------------------------------------------------------------------- # A class can offer several named constructors for convenience. Each one accepts # parameters tailored for a specific situation and returns a configured # instance. class Rectangle(object): def __init__(self, width, height): self.width = width self.height = height @classmethod def from_diagonal(cls, x1, y1, x2, y2): width = abs(x2 - x1) height = abs(y2 - y1) return cls(width, height) # Create a square using the default constructor rect1 = Rectangle(1, 1) print(rect1.width, rect1.height) # Create the same square using the named constructor rect2 = Rectangle.from_diagonal(1, 1, 2, 2) print(rect2.width, rect2.height) Class Named Constructor Init Sources # Different sources to create and initialize objects # -------------------------------------------------------------------------------- # Objects may be constructed from data stored in several locations such as # files or environment variables. Named constructors gather that information and # return fully initialized instances. import os class Person(object): def __init__(self, name, age): self.name = name self.age = age @classmethod def from_file(cls, file): with open(file, 'r') as f: data = f.read() name, age = data.split(',') return cls(name=name, age=age) # Create a file named profile.txt with the following contents: # mayank,27 with open('profile.txt', 'w') as f: f.write('mayank,27') person = Person.from_file('profile.txt') print(person.name, person.age) # Delete the file profile.txt os.remove('profile.txt') Class Named Constructor Reduce Params # Reduce the number of parameters # -------------------------------------------------------------------------------- # When an initializer requires many arguments, a named constructor can provide a # simpler interface. It bundles related values together before delegating to # __init__. class Rectangle(object): def __init__(self, width, height): self.width = width self.height = height @classmethod def square(cls, size): return cls(size, size) # Create a square using the default constructor square1 = Rectangle(1, 1) print(square1.width, square1.height) # Create the same square using the named constructor square2 = Rectangle.square(size=1) print(square2.width, square2.height) Class Named Constructor Representation # Different internal representations of the same object # -------------------------------------------------------------------------------- # A class may provide alternate constructors that store data in various formats. # Each representation exposes the same behavior to callers. Selecting one or # another depends on the needs of the application. class Person(object): def __init__(self, name, age): self.name = name self.age = age @classmethod def from_json(cls, data): return cls(**data) @staticmethod def from_csv(data): name = data[0] age = data[1] return Person(name=name, age=age) # Mock data json_data = {'name': 'mayank', 'age': 27} csv_data = [('mayank', 27), ] person = Person.from_json(json_data) print(person.name, person.age) person = Person.from_csv(csv_data[0]) print(person.name, person.age) Class Nested # Nested classes for constants, settings, etc. # -------------------------------------------------------------------------------- # Classes can contain other classes that serve as containers for related # constants or configuration. Nesting keeps these auxiliary definitions close to # the code that uses them. class Settings: LANG = \"English\" THEME = \"Light\" IP_ADDR = \"192.168.210.10\" PORT = 8080 class AdvancedSettings: ENABLE_LOGGING = False MAX_CONNECTIONS = 10 class ExperimentalSettings: ENABLE_NEW_FEATURE = False # Access the basic settings print(Settings.THEME) # Access the b settings print(Settings.AdvancedSettings.ENABLE_LOGGING) # Output: False # Access the experimental settings print(Settings.ExperimentalSettings.ENABLE_NEW_FEATURE) # Output: False Class Properties # Property used to encapsulate an instance variable # -------------------------------------------------------------------------------- # The property decorator exposes getter and setter functions as attribute # access. This allows validation or computation while keeping the public # interface simple. class Person(object): def __init__(self, name): self.name = name @property def name(self): return self.__name @name.setter def name(self, value): if not isinstance(value, str): raise TypeError(\"Expected a string\") self.__name = value p = Person(\"John\") print(p.name) Class Single Inheritance # Multilevel inheritance # -------------------------------------------------------------------------------- # Multilevel inheritance arranges classes in a linear hierarchy. Each # subsequent class extends the one above it, accumulating behavior down the # chain. class A(object): @staticmethod def process(): print(\"Root is processing... \") class B(A): pass class C(B): pass # The method process is searched for until the first class having the method is found (here A) test = C() test.process() Class Static Methods # Static method are not bound to the class and can be used as utility functions # -------------------------------------------------------------------------------- # Static methods operate without reference to a particular instance or class. # They behave like regular functions that happen to live in the class's # namespace and are often used for related utility tasks. class Packet(object): def __init__(self, ip_addr='192.168.10.1', mask=\"255.255.255.0\", payload=()): self.payload = payload self.ip_addr = ip_addr self.mask = mask @staticmethod def dot_to_bytes(val): return bytes(map(int, val.split('.'))) @staticmethod def bytes_to_dot(val): return '.'.join(map(str, val)) # Convert IP address in dot notation to bytes addr_bytes = Packet.dot_to_bytes('192.168.1.1') print(addr_bytes) # Convert bytes to IP address in dot notation addr_dot = Packet.bytes_to_dot(addr_bytes) print(addr_dot) Class Structure # Class structure # -------------------------------------------------------------------------------- # This file outlines common elements found in many classes such as attributes, # static methods and constructors. Organizing these pieces consistently makes # new classes easier to understand and maintain. class ClassStructure(object): CLASS_VARIABLE = \"Hi, I am \" def __new__(cls, *args, **kwargs): print(\"This is the constructor method\") return object.__new__(cls) def __init__(self): print(\"This is the initialization method\") self.instance_variable = \"John\" @classmethod def class_method(cls): print(\"This is a class method, the class prefix is: {}\".format(cls.class_variable)) @staticmethod def static_method(): print(\"This is a static method, the class prefix is: {}\".format(ClassStructure.class_variable)) def instance_method(self): print(\"This is an instance method, `{} {}`\".format(self.class_variable, self.instance_variable)) Class Superclass Attributes # Call super class method and access super class attributes # -------------------------------------------------------------------------------- # Subclasses can call methods defined on their parent and access inherited # attributes. Using ``super`` keeps the code maintainable when the hierarchy # changes. class Person(object): def __init__(self, name): self.name = name class Employee(Person): def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number e = Employee(\"John\", 1234) print(e.name) print(e.id_number) Class Superclass Constructor # Call __new__ method of super class # -------------------------------------------------------------------------------- # A subclass can override __new__ while still delegating part of the creation # process to its parent. Calling the superclass method ensures base attributes # are initialized correctly. class Person(object): def __new__(cls, name): return super(Person, cls).__new__(cls) def __init__(self, name): self.name = name class Employee(Person): def __new__(cls, name, id_number): return super(Employee, cls).__new__(cls, name) def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number e = Employee(\"John\", 1234) print(e.name) print(e.id_number) Class Superclass Methods # Call super class methods # -------------------------------------------------------------------------------- # Methods in a subclass can extend behavior defined in a parent. By calling the # superclass implementation first, the subclass adds functionality without # rewriting the original logic. class Person(object): def __init__(self, name): self.name = name def get_name(self): return self.name class Employee(Person): def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number def get_id_number(self): return self.id_number e = Employee(\"John\", 1234) print(e.get_name()) print(e.get_id_number()) Class Variables # Working with class attributes # -------------------------------------------------------------------------------- # Class attributes are shared across all instances of a class. They store values # that should remain consistent, such as prefixes used by each Person object. class Person(object): # Class attributes are defined outside of any method and are shared by all instances MALE_PREFIX = \"Mr.\" FEMALE_PREFIX = \"Ms.\" def __init__(self, name, sex): self.name = name self.sex = sex def get_prefix(self): \"\"\"Return the appropriate prefix using class attributes.\"\"\" # The person is male if self.sex == \"male\": prefix = self.MALE_PREFIX # The person is female elif self.sex == \"female\": prefix = self.FEMALE_PREFIX # Others else: prefix = \"\" return prefix def get_name(self): \"\"\" Return the name with the appropriate prefix \"\"\" return \"{} {}\".format(self.get_prefix(), self.name) # Create the instances males = [Person(name=\"Branimir\", sex=\"male\"), Person(\"Dimitar\", sex=\"male\")] # Class attributes are accessible from the instance methods print(\"Default prefix...\") for male in males: print(male.get_name()) # Class attributes are accessible from the class itself and a change will affect all instances print(\"Prefix changed...\") Person.MALE_PREFIX = \"Sir\" for male in males: print(male.get_name()) Class Variables Pitfalls # Class Variables Pitfalls # -------------------------------------------------------------------------------- # Sharing state at the class level can introduce subtle bugs when instances # modify that state. This section discusses common mistakes and how to avoid # them. \"\"\"Class vs. Instance Variables -------------------------------- Class variables are shared by all instances, while instance variables belong to each object. Assigning to ``self.variable`` creates an instance attribute. If a class attribute with the same name exists, the instance attribute hides it and later reads through ``self`` return the instance value. Mixing them can be confusing because updates seem to apply only to some objects. When you read ``self.value`` and ``value`` is not defined on the instance, Python falls back to the class attribute: class A: value = 1 obj = A() print(obj.value) # 1 from the class Any assignment using ``self`` stores a value on the instance: obj.value = 2 print(A.value) # 1 print(obj.value) # 2 Here ``obj.value`` now shadows ``A.value``. To access the class attribute explicitly you must use ``A.value``. \"\"\" class TestOp(object): immutable = 1 mutable = [1, ] class Test(TestOp): def __init__(self): super(Test, self).__init__() def test_immutable(self): print(\"#\" * 80) print(\"Testing immutable class variable\") print(\"#\" * 80) # self references to the class variable print(\"\") print(\"Read value through class name and then self...\") print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) # self creates and references an instance variable (shadows the class variable) print(\"\") print(\"Change immutable type using self...\") self.immutable = 2 print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) # Changing the value of immutable class variable will create a new object print(\"\") print(\"Change the value of the class immutable variable...\") TestOp.immutable = 3 print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) print(\"\") def test_mutable(self): print(\"#\" * 80) print(\"Testing mutable class variable\") print(\"#\" * 80) # self references to the class variable print(\"\") print(\"Read value through class name and then self...\") print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) # self creates and references an instance variable (shadows the class variable) print(\"\") print(\"Change mutable type using self...\") self.mutable.append(2) print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) # self print(\"\") print(\"Change the value of the class mutable variable...\") TestOp.mutable.append(3) print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) print(\"\") if __name__ == \"__main__\": test = Test() test.test_mutable() print(\"Final value of immutable class variable is {0}:{1}\\n\".format(id(Test.immutable), Test.immutable)) test.test_immutable() print(\"Final value of mutable class variable is {0}:{1}\\n\".format(id(Test.mutable), Test.mutable))","title":"Classes"},{"location":"examples/08_classes/#classes","text":"","title":"Classes"},{"location":"examples/08_classes/#class-abstract-properties","text":"# Stacking decorators # -------------------------------------------------------------------------------- # Multiple decorators can be stacked on a single attribute. In this file a # property is defined using @property together with @abstractmethod. Derived # classes must supply the concrete implementation for this decorated property. from abc import ABCMeta, abstractmethod from six import with_metaclass class DeviceAbc(with_metaclass(ABCMeta)): \"\"\"Example abstract class Usage: # Optional @property, @staticmethod, @classmethod + # Obligatory decorator @abstractmethod Example: # Defines and abstract property @property @abstractmethod def prop(self): ... \"\"\" def __init__(self): self._bar = \"bar\" @property @abstractmethod def bar(self): pass @abstractmethod def foo(self): pass class Samsung(DeviceAbc): @property def bar(self): return self._bar def foo(self): print('foo') test = Samsung() print(test.bar) test.foo()","title":"Class Abstract Properties"},{"location":"examples/08_classes/#class-abstract-python2","text":"# Abstract class using the six library for python 2 # -------------------------------------------------------------------------------- # The six library helps define abstract base classes that remain compatible with # Python 2. The metaclass provided by six works with decorators such as # @abstractmethod so subclasses must implement the required methods. from six import with_metaclass from abc import ABCMeta, abstractmethod class CalculatorAbc(with_metaclass(ABCMeta)): def __init__(self, mode=\"basic\"): self.mode = mode @abstractmethod def add(self, *args, **kwargs): raise NotImplementedError @abstractmethod def subtract(self, *args, **kwargs): raise NotImplementedError class Calculator(CalculatorAbc): def add(self, a, b): return a + b def subtract(self, a, b): return a - b calc = Calculator() print(calc.add(1, 2)) print(calc.mode)","title":"Class Abstract Python2"},{"location":"examples/08_classes/#class-abstract-python3","text":"# Abstract class in python 3+ # -------------------------------------------------------------------------------- # Python 3 provides native support for abstract base classes. The ABC and # abstractmethod decorators ensure that child classes implement required # behavior. Instances cannot be created until the abstract methods are # overridden. from abc import ABC, abstractmethod class CalculatorAbc(ABC): def __init__(self, mode=\"basic\"): self.mode = mode @abstractmethod def add(self, *args, **kwargs): raise NotImplementedError @abstractmethod def subtract(self, *args, **kwargs): raise NotImplementedError class Calculator(CalculatorAbc): def add(self, a, b): return a + b def subtract(self, a, b): return a - b calc = Calculator() print(calc.add(1, 2)) print(calc.mode)","title":"Class Abstract Python3"},{"location":"examples/08_classes/#class-as-blueprint","text":"# Class as template # -------------------------------------------------------------------------------- # A class can act as a template from which many objects are built. This file # defines a Person blueprint containing attributes and methods that every # instance will share. class Person(object): def __init__(self, name, age): self.name = name self.age = age def say_hello(self): print(\"Hello, my name is {} and my age is {}\".format(self.name, self.age))","title":"Class As Blueprint"},{"location":"examples/08_classes/#class-as-concrete-object","text":"# Object as concrete realization of a class # -------------------------------------------------------------------------------- # The code creates an instance of the Person class as a tangible object. # The constructor assigns initial values to the instance. After creation, the # object can call its methods and access stored data. from class_as_blueprint import Person John = Person(\"John\", 32) John.say_hello()","title":"Class As Concrete Object"},{"location":"examples/08_classes/#class-constructor-conditional-inheritance","text":"# Conditional inheritance using the __new__ method # -------------------------------------------------------------------------------- # The __new__ method can decide which subclass to instantiate. By inspecting # runtime conditions it returns objects of different types from a single # factory class. This approach allows conditional inheritance without altering # the class hierarchy. class WindowsCalculator(object): \"\"\" Windows calculator class operations \"\"\" @staticmethod def do(): print(\"Do in Windows Calculator\") class LinuxCalculator(object): \"\"\" Linux calculator class operations \"\"\" @staticmethod def do(): print(\"Do in Linux Calculator\") class Calculator(object): def __new__(cls, os=\"windows\"): # Windows base class if os == \"windows\": parents = (WindowsCalculator, ) # Linux base class elif os == \"linux\": parents = (LinuxCalculator, ) # Invalid operating system else: raise ValueError(\"Invalid operating system\") # Create a new class with the given name and bases cls = type(\"Calculator\", parents, {}) # Return an instance of the new class return cls() # Create a new instance of the Calculator class calc = Calculator(\"windows\") # Check if the Calculator class is a subclass of the WindowsCalculator class test = issubclass(type(calc), WindowsCalculator) print(\"Is subclass of WindowsCalculator? [{}]\".format(test)) # Call the do method calc.do()","title":"Class Constructor Conditional Inheritance"},{"location":"examples/08_classes/#class-constructor-factory","text":"# Class factory using the __new__ method # -------------------------------------------------------------------------------- # Overriding __new__ allows a class to act as a factory. The method returns an # instance of a specific subclass based on the provided parameters. This # separates the decision about which object to create from the calling code. class WindowsCalculator(object): @staticmethod def do(): print(\"Do in Windows Calculator\") class LinuxCalculator(object): @staticmethod def do(): print(\"Do in Linux Calculator\") class Calculator(object): def __new__(cls, os=\"windows\"): # An instance of the WindowsCalculator class is returned if os == \"windows\": return object.__new__(WindowsCalculator) # An instance of the LinuxCalculator class is returned elif os == \"linux\": return object.__new__(LinuxCalculator) # Invalid operating system else: raise ValueError(\"Invalid operating system\") # Create a new instance of the Calculator class calc = Calculator(\"windows\") # Check if the Calculator class is an instance of the WindowsCalculator class test = isinstance(calc, WindowsCalculator) print(\"Is instance of WindowsCalculator? [{}]\".format(test)) # Call the do method calc.do()","title":"Class Constructor Factory"},{"location":"examples/08_classes/#class-constructor-singleton","text":"# Singleton using the __new__ method # -------------------------------------------------------------------------------- # By overriding __new__, this class ensures that only one instance ever exists. # The method stores the created object and returns it on subsequent calls. # Such control over object creation implements the singleton pattern. class Singleton(object): __instance = None def __new__(cls): if cls.__instance is None: print(\"Creating singleton...\") cls.__instance = object.__new__(cls) else: print(\"Singleton already exists...\") return cls.__instance s1 = Singleton() s2 = Singleton() print(s1 == s2) print(s1 is s2)","title":"Class Constructor Singleton"},{"location":"examples/08_classes/#class-constructors","text":"# How __new__ and __init__ cooperate in object creation # -------------------------------------------------------------------------------- # Object creation begins with __new__, which allocates the instance. The fresh # object is then passed to __init__ for further initialization. Separating these # steps gives developers flexibility to customize how objects come into # existence. class Calculator(object): def __new__(cls): # Use the parent class to create the object obj = object.__new__(cls) # Return the object print(\"__new__ : Created object {}\".format(obj)) return obj def __init__(self): # Self is the object that was created by __new__ print(\"__init__: Using object {}\".format(self)) # Add attributes to the object self.name = \"Cool Calculator\" calc = Calculator() print(calc.name)","title":"Class Constructors"},{"location":"examples/08_classes/#class-create-with-type","text":"# Using ``type`` to inspect objects and create classes # -------------------------------------------------------------------------------- # The built-in ``type`` function performs two unrelated tasks. When passed a # single object it returns that object's class, which can be handy for # inspection. When given a name, base classes and attributes it creates a new # class dynamically, allowing programs to define types at runtime. ############################################################################## # USECASE A : Get object type ############################################################################## numbers_list = [1, 2] print(type(numbers_list)) numbers_dict = {1: 'one', 2: 'two'} print(type(numbers_dict)) ############################################################################## # USECASE B : Create class with base classes, attributes and methods ############################################################################## def init(self, name): self.name = name def say_hallo_b(self): return \"Hi, my name is \" + self.name Robot2 = type(\"Robot2\", (), {\"counter\": 0, \"__init__\": init, \"func\": lambda self: \"Hi, I am \" + self.name, \"say_hello_b\": say_hallo_b } ) x = Robot2(\"Marvin\") print(x.name) print(x.func()) print(x.say_hello_b())","title":"Class Create With Type"},{"location":"examples/08_classes/#class-decorator-for-classes","text":"# Class as a decorator for a class # -------------------------------------------------------------------------------- # A class can implement the __call__ method and be applied as a decorator to # another class. When used this way it may attach attributes or modify the # decorated class at definition time. class Counter(object): # The constructor accepts the parameter passed to the decorator def __init__(self, start_value): self.counter = start_value # The __call__ method is called when the class is used as a decorator def __call__(self, cls): # Modify the class by adding an attribute with the specified value cls.counter = self.counter # Return the modified class return cls # Apply the class decorator with a parameter @Counter(start_value=1) class DecoratedClass(object): pass # Use the explicit decorator syntax DecoratedClass = Counter(start_value=1)(DecoratedClass) obj = DecoratedClass() print(obj.counter) # Output: 1 # Use Python's decorator syntax obj = DecoratedClass() print(obj.counter) # Output: Custom Value","title":"Class Decorator For Classes"},{"location":"examples/08_classes/#class-decorator-for-functions","text":"# Class as a decorator for functions and methods # -------------------------------------------------------------------------------- # Defining the __call__ method allows a class to wrap functions or methods. # The decorator can maintain state between invocations and perform actions # before or after calling the original function. class Counter(object): def __init__(self, init_value=0): \"\"\" Initialize counter.\"\"\" self._counter = init_value def __call__(self, function): \"\"\" Wrapping call to original function. \"\"\" def wrapper(*args, **kwargs): \"\"\" Wrapper function.\"\"\" try: self._counter += 1 print(\"{}\".format(self._counter)) return function(*args, **kwargs) except Exception as e: print(e) return wrapper def f(): print(\"Hello World\") @Counter(0) def g(): print(\"Hello World\") print(\"#\" * 80) # Use the explicit decorator syntax f = Counter(0)(f) # Call the decorated functions for _ in range(10): f() print(\"#\" * 80) # Use Python's decorator syntax for _ in range(10): g()","title":"Class Decorator For Functions"},{"location":"examples/08_classes/#class-init-state","text":"# Initialization with the __init__ method # -------------------------------------------------------------------------------- # The __init__ method runs immediately after an object is created. It assigns # the initial values for the instance and prepares it for use. class Person(object): def __init__(self, name=\"Branimir\", age=40): self.name = name self.age = age print(\"My name is {0} and I am {1} years old\".format(self.name, self.age)) p1 = Person() p2 = Person(\"John\", 30)","title":"Class Init State"},{"location":"examples/08_classes/#class-init-steps","text":"# Initialization in multiple steps # -------------------------------------------------------------------------------- # Some objects gather their initial data through a sequence of operations. This # file breaks the process into helper methods that collect the values one by # one. Each step can perform validation before returning its result. class Person(object): def __init__(self): self.name = self.step_1() self.age = self.step_2() @staticmethod def step_1(): name = input(\"Step 1: Enter the person's name: \") return name @staticmethod def step_2(): age = input(\"Step 2: Enter the person's age: \") return age john = Person() print(john.name, john.age)","title":"Class Init Steps"},{"location":"examples/08_classes/#class-init-validate","text":"# Initialization and validation # -------------------------------------------------------------------------------- # Initialization may involve checking that provided values meet certain rules. # The constructor validates input before assigning it to attributes. Invalid # data is rejected to keep the object's state consistent. class Person(object): def __init__(self, name, age): self.name = name self.age = age if not isinstance(self.name, str): raise TypeError(\"Name must be a string\") if not isinstance(self.age, int): raise TypeError(\"Age must be an integer\") if self.age < 0: raise ValueError(\"Age must be a positive integer\") def say_hello(self): print(\"Hello, my name is {} and my age is {}\".format(self.name, self.age)) john = Person(\"John\", 32) john.say_hello()","title":"Class Init Validate"},{"location":"examples/08_classes/#class-instance","text":"# Class instance with concrete values # -------------------------------------------------------------------------------- # After defining the Person class, an instance is created with explicit values. # The object stores these attributes as part of its state. Accessing them later # confirms that the information persists on the instance. class Person(object): def __init__(self): print(\"Person has ID {}\".format(id(self))) # The person object has a unique id p1 = Person() p2 = Person()","title":"Class Instance"},{"location":"examples/08_classes/#class-instance-attributes","text":"# Define and access instance attributes # -------------------------------------------------------------------------------- # Instance attributes are defined in the __init__ method. They store data # unique to each object and can be accessed through the instance of the class. # Each instance may hold different values for these attributes. class Person(object): def __init__(self): self.name = \"Branimir\" self.age = 40 # Create the instance p = Person() # Access to the instance attributes print(p.name) print(p.age)","title":"Class Instance Attributes"},{"location":"examples/08_classes/#class-instance-methods","text":"# Class instance with instance methods # -------------------------------------------------------------------------------- # Instance methods operate on a particular object and have access to its state. # They typically receive the instance as the first parameter. Calling these # methods affects only the object that invoked them. class Person(object): def do_something(self): print(\"{} is doing something\".format(self)) def do_something_with(self, something, someone): print(\"{} is doing {} with {}\".format(self, something, someone)) # Create the instance p = Person() p.do_something() p.do_something_with(\"nothing\", \"no one\")","title":"Class Instance Methods"},{"location":"examples/08_classes/#class-method-create-instance","text":"# Class method used to create instances # -------------------------------------------------------------------------------- # A class method can serve as an alternative constructor. It receives the class # as the first argument and builds a new instance from provided data. This # approach collects creation logic in one place. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def from_string(cls, name): return cls(name) p = Person.from_string(\"John\") print(p.name)","title":"Class Method Create Instance"},{"location":"examples/08_classes/#class-method-modify-instances","text":"# Class method used to modify existing instances of the class # -------------------------------------------------------------------------------- # Class methods can operate on a collection of instances maintained by the # class. The method updates every stored object in a single call. Centralizing # the logic keeps modifications consistent across all instances. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def set_prefix(cls, prefix): cls.NAME_PREFIX = prefix @classmethod def add_prefix(cls, person): person.name = \"{} {}\".format(cls.NAME_PREFIX, person.name) p = Person(\"John\") Person.set_prefix(\"Dr.\") Person.add_prefix(p) print(p.name)","title":"Class Method Modify Instances"},{"location":"examples/08_classes/#class-method-modify-itself","text":"# Class method used to modify the class itself # -------------------------------------------------------------------------------- # Because class methods receive the class as the first argument, they can change # class-level attributes. This file modifies a shared value that affects all # future instances. class Person(object): NAME_PREFIX = \"Mr.\" def __init__(self, name): self.name = name @classmethod def set_prefix(cls, prefix): cls.NAME_PREFIX = prefix p = Person(\"John\") Person.set_prefix(\"Dr.\") print(p.NAME_PREFIX)","title":"Class Method Modify Itself"},{"location":"examples/08_classes/#class-mixin","text":"# Mixin class # -------------------------------------------------------------------------------- # A mixin provides extra methods that can be shared across multiple unrelated # classes. It relies on cooperative multiple inheritance to join its behavior # with that of the main class hierarchy. class RemoteMixin(object): def __init__(self, brand=None, volume=0, *args, **kwargs): # This syntax is required in order to guarantee that the MRO is not broken super(RemoteMixin, self).__init__(*args, **kwargs) # Mixin specific attributes self.brand = brand self.volume = volume def volume_up(self): self.volume += 1 def volume_down(self): self.volume -= 1 def status(self): print(\"Brand: {}\".format(self.brand)) print(\"Volume: {}\".format(self.volume)) class JvcRemote(RemoteMixin, object): \"\"\" Mixins should be always inherited first \"\"\" def __init__(self): super(JvcRemote, self).__init__(brand=\"JVC\", volume=10) def status(self): super(JvcRemote, self).status() @staticmethod def learn(): print(\"Learn button\") class SonyRemote(RemoteMixin, object): \"\"\" Mixins should be always inherited first \"\"\" def __init__(self): super(SonyRemote, self).__init__(brand=\"Sony\", volume=5) @staticmethod def home(): print(\"Home button\") remote = JvcRemote() actions = [\"volume_up\", \"status\", \"volume_down\", \"status\", \"learn\", \"status\"] for action in actions: print(\"Action: {}\".format(action)) func = getattr(remote, action) func() print(\"\\n\") remote = SonyRemote() actions = [\"volume_up\", \"status\", \"volume_down\", \"status\", \"home\", \"status\"] for action in actions: print(\"Action: {}\".format(action)) func = getattr(remote, action) func()","title":"Class Mixin"},{"location":"examples/08_classes/#class-mro-bottom-first","text":"# Mro (method resolution order) - bottom first # -------------------------------------------------------------------------------- # In this layout the interpreter begins searching for methods in the most # derived class and moves upward through the hierarchy. The arrangement helps # clarify how attribute lookup progresses when multiple parents define the same # name. class A(object): @staticmethod def process(): print('A.process()') class B(object): @staticmethod def process(): print('B.process()') class C(A, B): @staticmethod def process(): print('C.process()') obj = C() obj.process() print(C.mro())","title":"Class Mro Bottom First"},{"location":"examples/08_classes/#class-mro-complex","text":"# Mro (method resolution order) - combined bottom first and left first # -------------------------------------------------------------------------------- # Python resolves method names by considering both the depth of the inheritance # tree and the order in which bases are listed. This file sets up a hierarchy # that makes the combined bottom-first and left-first rules apparent. class A(object): @staticmethod def process(): print(\"A.process()\") class B(object): @staticmethod def process(): print(\"B.process()\") class C(A, B): pass class D(C, B): pass d = D() print(D.mro()) d.process()","title":"Class Mro Complex"},{"location":"examples/08_classes/#class-mro-diamond","text":"# Mro (method resolution order) - diamond problem # -------------------------------------------------------------------------------- # A diamond inheritance pattern occurs when two classes share a common base # class. The method resolution order ensures that the base is initialized only # once. The classes here are organized so that each path to the base is # considered without duplication. class A(object): @staticmethod def process(): print(\"A.process()\") class B(A): @staticmethod def process(): print(\"B.process()\") class C(A): @staticmethod def process(): print(\"C.process()\") class D(B, C): pass d = D() print(D.mro()) d.process()","title":"Class Mro Diamond"},{"location":"examples/08_classes/#class-mro-left-first","text":"# Mro (method resolution order) - left first # -------------------------------------------------------------------------------- # With multiple inheritance Python consults base classes from left to right. The # hierarchy in this file highlights how that ordering affects method lookup. class A(object): @staticmethod def process(): print('A.process()') class B(object): @staticmethod def process(): print('B.process()') class C(A, B): pass class D(B, A): pass # The method process is searched for until the first class having the method is found (here A) test = C() print(C.mro()) test.process() # The method process is searched for until the first class having the method is found (here B) test = D() print(D.mro()) test.process()","title":"Class Mro Left First"},{"location":"examples/08_classes/#class-mro-unresolved","text":"# Mro (method resolution order) - unresolved # -------------------------------------------------------------------------------- # Some inheritance graphs produce conflicting search orders that Python cannot # resolve. This file sets up such a conflict and triggers an error when the # interpreter tries to build the method resolution order. Understanding this # failure helps diagnose complex inheritance issues. class Player(object): pass class Enemy(Player): pass class GameObject(Player, Enemy): pass # Explanation (see MRO rules in the documentation): # # - MRO is GameObject -> Player -> Enemy -> Player (not monotonic as Player appears twice) # - Rule 2 says Enemy should appear before Player # - Rule 3 says Player should appear before Enemy # # Rules 2 and 3 are in conflict, so the MRO algorithm cannot be applied. This is called an # \"unresolvable inheritance graph\" and Python will raise an exception in this case. g = GameObject() print(GameObject.mro())","title":"Class Mro Unresolved"},{"location":"examples/08_classes/#class-multiple-inheritance","text":"# Multiple inheritance # -------------------------------------------------------------------------------- # A single class may inherit behavior from several parents. Combining features # this way can reduce duplication but requires careful design to avoid # conflicts. class A(object): @staticmethod def process(): print(\"Class A is processing... \") class B(object): @staticmethod def process(): print(\"Class B is processing... \") class C(A, B): pass class D(B, A): pass # The method process is searched for until the first class having the method is found (here A) test = C() test.process() # The method process is searched for until the first class having the method is found (here B) test = D() test.process()","title":"Class Multiple Inheritance"},{"location":"examples/08_classes/#class-named-constructor-different-params","text":"# Named constructors as alternative constructors # -------------------------------------------------------------------------------- # A class can offer several named constructors for convenience. Each one accepts # parameters tailored for a specific situation and returns a configured # instance. class Rectangle(object): def __init__(self, width, height): self.width = width self.height = height @classmethod def from_diagonal(cls, x1, y1, x2, y2): width = abs(x2 - x1) height = abs(y2 - y1) return cls(width, height) # Create a square using the default constructor rect1 = Rectangle(1, 1) print(rect1.width, rect1.height) # Create the same square using the named constructor rect2 = Rectangle.from_diagonal(1, 1, 2, 2) print(rect2.width, rect2.height)","title":"Class Named Constructor Different Params"},{"location":"examples/08_classes/#class-named-constructor-init-sources","text":"# Different sources to create and initialize objects # -------------------------------------------------------------------------------- # Objects may be constructed from data stored in several locations such as # files or environment variables. Named constructors gather that information and # return fully initialized instances. import os class Person(object): def __init__(self, name, age): self.name = name self.age = age @classmethod def from_file(cls, file): with open(file, 'r') as f: data = f.read() name, age = data.split(',') return cls(name=name, age=age) # Create a file named profile.txt with the following contents: # mayank,27 with open('profile.txt', 'w') as f: f.write('mayank,27') person = Person.from_file('profile.txt') print(person.name, person.age) # Delete the file profile.txt os.remove('profile.txt')","title":"Class Named Constructor Init Sources"},{"location":"examples/08_classes/#class-named-constructor-reduce-params","text":"# Reduce the number of parameters # -------------------------------------------------------------------------------- # When an initializer requires many arguments, a named constructor can provide a # simpler interface. It bundles related values together before delegating to # __init__. class Rectangle(object): def __init__(self, width, height): self.width = width self.height = height @classmethod def square(cls, size): return cls(size, size) # Create a square using the default constructor square1 = Rectangle(1, 1) print(square1.width, square1.height) # Create the same square using the named constructor square2 = Rectangle.square(size=1) print(square2.width, square2.height)","title":"Class Named Constructor Reduce Params"},{"location":"examples/08_classes/#class-named-constructor-representation","text":"# Different internal representations of the same object # -------------------------------------------------------------------------------- # A class may provide alternate constructors that store data in various formats. # Each representation exposes the same behavior to callers. Selecting one or # another depends on the needs of the application. class Person(object): def __init__(self, name, age): self.name = name self.age = age @classmethod def from_json(cls, data): return cls(**data) @staticmethod def from_csv(data): name = data[0] age = data[1] return Person(name=name, age=age) # Mock data json_data = {'name': 'mayank', 'age': 27} csv_data = [('mayank', 27), ] person = Person.from_json(json_data) print(person.name, person.age) person = Person.from_csv(csv_data[0]) print(person.name, person.age)","title":"Class Named Constructor Representation"},{"location":"examples/08_classes/#class-nested","text":"# Nested classes for constants, settings, etc. # -------------------------------------------------------------------------------- # Classes can contain other classes that serve as containers for related # constants or configuration. Nesting keeps these auxiliary definitions close to # the code that uses them. class Settings: LANG = \"English\" THEME = \"Light\" IP_ADDR = \"192.168.210.10\" PORT = 8080 class AdvancedSettings: ENABLE_LOGGING = False MAX_CONNECTIONS = 10 class ExperimentalSettings: ENABLE_NEW_FEATURE = False # Access the basic settings print(Settings.THEME) # Access the b settings print(Settings.AdvancedSettings.ENABLE_LOGGING) # Output: False # Access the experimental settings print(Settings.ExperimentalSettings.ENABLE_NEW_FEATURE) # Output: False","title":"Class Nested"},{"location":"examples/08_classes/#class-properties","text":"# Property used to encapsulate an instance variable # -------------------------------------------------------------------------------- # The property decorator exposes getter and setter functions as attribute # access. This allows validation or computation while keeping the public # interface simple. class Person(object): def __init__(self, name): self.name = name @property def name(self): return self.__name @name.setter def name(self, value): if not isinstance(value, str): raise TypeError(\"Expected a string\") self.__name = value p = Person(\"John\") print(p.name)","title":"Class Properties"},{"location":"examples/08_classes/#class-single-inheritance","text":"# Multilevel inheritance # -------------------------------------------------------------------------------- # Multilevel inheritance arranges classes in a linear hierarchy. Each # subsequent class extends the one above it, accumulating behavior down the # chain. class A(object): @staticmethod def process(): print(\"Root is processing... \") class B(A): pass class C(B): pass # The method process is searched for until the first class having the method is found (here A) test = C() test.process()","title":"Class Single Inheritance"},{"location":"examples/08_classes/#class-static-methods","text":"# Static method are not bound to the class and can be used as utility functions # -------------------------------------------------------------------------------- # Static methods operate without reference to a particular instance or class. # They behave like regular functions that happen to live in the class's # namespace and are often used for related utility tasks. class Packet(object): def __init__(self, ip_addr='192.168.10.1', mask=\"255.255.255.0\", payload=()): self.payload = payload self.ip_addr = ip_addr self.mask = mask @staticmethod def dot_to_bytes(val): return bytes(map(int, val.split('.'))) @staticmethod def bytes_to_dot(val): return '.'.join(map(str, val)) # Convert IP address in dot notation to bytes addr_bytes = Packet.dot_to_bytes('192.168.1.1') print(addr_bytes) # Convert bytes to IP address in dot notation addr_dot = Packet.bytes_to_dot(addr_bytes) print(addr_dot)","title":"Class Static Methods"},{"location":"examples/08_classes/#class-structure","text":"# Class structure # -------------------------------------------------------------------------------- # This file outlines common elements found in many classes such as attributes, # static methods and constructors. Organizing these pieces consistently makes # new classes easier to understand and maintain. class ClassStructure(object): CLASS_VARIABLE = \"Hi, I am \" def __new__(cls, *args, **kwargs): print(\"This is the constructor method\") return object.__new__(cls) def __init__(self): print(\"This is the initialization method\") self.instance_variable = \"John\" @classmethod def class_method(cls): print(\"This is a class method, the class prefix is: {}\".format(cls.class_variable)) @staticmethod def static_method(): print(\"This is a static method, the class prefix is: {}\".format(ClassStructure.class_variable)) def instance_method(self): print(\"This is an instance method, `{} {}`\".format(self.class_variable, self.instance_variable))","title":"Class Structure"},{"location":"examples/08_classes/#class-superclass-attributes","text":"# Call super class method and access super class attributes # -------------------------------------------------------------------------------- # Subclasses can call methods defined on their parent and access inherited # attributes. Using ``super`` keeps the code maintainable when the hierarchy # changes. class Person(object): def __init__(self, name): self.name = name class Employee(Person): def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number e = Employee(\"John\", 1234) print(e.name) print(e.id_number)","title":"Class Superclass Attributes"},{"location":"examples/08_classes/#class-superclass-constructor","text":"# Call __new__ method of super class # -------------------------------------------------------------------------------- # A subclass can override __new__ while still delegating part of the creation # process to its parent. Calling the superclass method ensures base attributes # are initialized correctly. class Person(object): def __new__(cls, name): return super(Person, cls).__new__(cls) def __init__(self, name): self.name = name class Employee(Person): def __new__(cls, name, id_number): return super(Employee, cls).__new__(cls, name) def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number e = Employee(\"John\", 1234) print(e.name) print(e.id_number)","title":"Class Superclass Constructor"},{"location":"examples/08_classes/#class-superclass-methods","text":"# Call super class methods # -------------------------------------------------------------------------------- # Methods in a subclass can extend behavior defined in a parent. By calling the # superclass implementation first, the subclass adds functionality without # rewriting the original logic. class Person(object): def __init__(self, name): self.name = name def get_name(self): return self.name class Employee(Person): def __init__(self, name, id_number): super(Employee, self).__init__(name) self.id_number = id_number def get_id_number(self): return self.id_number e = Employee(\"John\", 1234) print(e.get_name()) print(e.get_id_number())","title":"Class Superclass Methods"},{"location":"examples/08_classes/#class-variables","text":"# Working with class attributes # -------------------------------------------------------------------------------- # Class attributes are shared across all instances of a class. They store values # that should remain consistent, such as prefixes used by each Person object. class Person(object): # Class attributes are defined outside of any method and are shared by all instances MALE_PREFIX = \"Mr.\" FEMALE_PREFIX = \"Ms.\" def __init__(self, name, sex): self.name = name self.sex = sex def get_prefix(self): \"\"\"Return the appropriate prefix using class attributes.\"\"\" # The person is male if self.sex == \"male\": prefix = self.MALE_PREFIX # The person is female elif self.sex == \"female\": prefix = self.FEMALE_PREFIX # Others else: prefix = \"\" return prefix def get_name(self): \"\"\" Return the name with the appropriate prefix \"\"\" return \"{} {}\".format(self.get_prefix(), self.name) # Create the instances males = [Person(name=\"Branimir\", sex=\"male\"), Person(\"Dimitar\", sex=\"male\")] # Class attributes are accessible from the instance methods print(\"Default prefix...\") for male in males: print(male.get_name()) # Class attributes are accessible from the class itself and a change will affect all instances print(\"Prefix changed...\") Person.MALE_PREFIX = \"Sir\" for male in males: print(male.get_name())","title":"Class Variables"},{"location":"examples/08_classes/#class-variables-pitfalls","text":"# Class Variables Pitfalls # -------------------------------------------------------------------------------- # Sharing state at the class level can introduce subtle bugs when instances # modify that state. This section discusses common mistakes and how to avoid # them. \"\"\"Class vs. Instance Variables -------------------------------- Class variables are shared by all instances, while instance variables belong to each object. Assigning to ``self.variable`` creates an instance attribute. If a class attribute with the same name exists, the instance attribute hides it and later reads through ``self`` return the instance value. Mixing them can be confusing because updates seem to apply only to some objects. When you read ``self.value`` and ``value`` is not defined on the instance, Python falls back to the class attribute: class A: value = 1 obj = A() print(obj.value) # 1 from the class Any assignment using ``self`` stores a value on the instance: obj.value = 2 print(A.value) # 1 print(obj.value) # 2 Here ``obj.value`` now shadows ``A.value``. To access the class attribute explicitly you must use ``A.value``. \"\"\" class TestOp(object): immutable = 1 mutable = [1, ] class Test(TestOp): def __init__(self): super(Test, self).__init__() def test_immutable(self): print(\"#\" * 80) print(\"Testing immutable class variable\") print(\"#\" * 80) # self references to the class variable print(\"\") print(\"Read value through class name and then self...\") print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) # self creates and references an instance variable (shadows the class variable) print(\"\") print(\"Change immutable type using self...\") self.immutable = 2 print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) # Changing the value of immutable class variable will create a new object print(\"\") print(\"Change the value of the class immutable variable...\") TestOp.immutable = 3 print(\"CLS => {0}:{1}\".format(id(TestOp.immutable), TestOp.immutable)) print(\"SELF => {0}:{1}\".format(id(self.immutable), self.immutable)) print(\"\") def test_mutable(self): print(\"#\" * 80) print(\"Testing mutable class variable\") print(\"#\" * 80) # self references to the class variable print(\"\") print(\"Read value through class name and then self...\") print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) # self creates and references an instance variable (shadows the class variable) print(\"\") print(\"Change mutable type using self...\") self.mutable.append(2) print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) # self print(\"\") print(\"Change the value of the class mutable variable...\") TestOp.mutable.append(3) print(\"CLS => {0}:{1}\".format(id(TestOp.mutable), TestOp.mutable)) print(\"SELF => {0}:{1}\".format(id(self.mutable), self.mutable)) print(\"\") if __name__ == \"__main__\": test = Test() test.test_mutable() print(\"Final value of immutable class variable is {0}:{1}\\n\".format(id(Test.immutable), Test.immutable)) test.test_immutable() print(\"Final value of mutable class variable is {0}:{1}\\n\".format(id(Test.mutable), Test.mutable))","title":"Class Variables Pitfalls"},{"location":"examples/09_docstrings/","text":"Docstrings Docstring Class # Docstrings for Classes # Difficulty: intermediate # -------------------------------------------------------------------------------- # Docstrings explain the intent of the following class and how it can be # extended. They also clarify the purpose of individual methods and # properties. class TestClass(object): \"\"\"Demonstration docstring for the class Args: test (int): Constructor argument documented for clarity Example: >>> test_class = TestClass(1) >>> test_class.test_function(1) 'This is a test function with argument 1' \"\"\" def __init__(self, test): \"\"\"Docstring for the constructor\"\"\" self.test = test def test_function(self, test): \"\"\"Docstring for the function Args: test (int): Function argument documented for clarity Raises: ValueError: If test is None Returns: str: A string with the argument \"\"\" if test is None: raise ValueError(\"test cannot be None\") return \"This is a test function with argument {}\".format(test) print(TestClass.__doc__) print(TestClass.test_function.__doc__) Docstring Function # Docstring for a Function # Difficulty: intermediate # -------------------------------------------------------------------------------- # Documenting a function with a docstring explains its purpose and how it # should be used. The description lists the expected arguments as well as the # return value. Such documentation also enables automated tools to generate # helpful references. def myfunction(a, b, c): \"\"\"This is a demonstration docstring for myfunction Args: a (int): This is the first argument b (int): This is the second argument c (int): This is the third argument Raises: ValueError: If a is less than 0 Returns: int: This is the return value Example: >>> myfunction(1, 2, 3) 6 \"\"\" if a < 0: raise ValueError('a must be greater than 0') return a + b + c print(myfunction.__doc__) Docstring Module # Docstrings for modules # -------------------------------------------------------------------------------- # Copyright 2023 by <Author> # # All Rights Reserved # # Permission to use, copy, modify, and distribute this software and # its documentation for any purpose and without fee is hereby # granted, provided that the above copyright notice appear in all # copies and that both that copyright notice and this permission # notice appear in supporting documentation, and that the name of # <AUTHOR> not be used in advertising or publicity pertaining to # distribution of the software without specific, written prior # permission. # # <AUTHOR> DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, # INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN # NO EVENT SHALL <AUTHOR> BE LIABLE FOR ANY SPECIAL, INDIRECT OR # CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS # OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, # NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. # ====================================================================== \"\"\" Math Operations Module This module provides junior set of mathematical operations, including addition, subtraction, multiplication, and division. Usage: - Import this module using 'import math_operations'. - Call functions using 'math_operations.add()', 'math_operations.subtract()', 'math_operations.multiply()', and 'math_operations.divide()'. Example: >>> import math >>> \"{:.2f}\".format(math.sin(math.radians(90))) '1.00' >>> \"{:.2f}\".format(math.cos(math.radians(90))) '0.00' \"\"\" class HelperClass(object): \"\"\"This is junior helper class for the module\"\"\" pass def add(x, y): \"\"\"Add two numbers.\"\"\" return x + y def subtract(x, y): \"\"\"Subtract one number from another.\"\"\" return x - y def multiply(x, y): \"\"\"Multiply two numbers.\"\"\" return x * y def divide(x, y): \"\"\"Divide one number by another.\"\"\" if y == 0: raise ValueError(\"Division by zero is not allowed.\") return x / y if __name__ == \"__main__\": # Example usage of the module's functions result = add(5, 3) print(\"Result of addition:\", result)","title":"Docstrings"},{"location":"examples/09_docstrings/#docstrings","text":"","title":"Docstrings"},{"location":"examples/09_docstrings/#docstring-class","text":"# Docstrings for Classes # Difficulty: intermediate # -------------------------------------------------------------------------------- # Docstrings explain the intent of the following class and how it can be # extended. They also clarify the purpose of individual methods and # properties. class TestClass(object): \"\"\"Demonstration docstring for the class Args: test (int): Constructor argument documented for clarity Example: >>> test_class = TestClass(1) >>> test_class.test_function(1) 'This is a test function with argument 1' \"\"\" def __init__(self, test): \"\"\"Docstring for the constructor\"\"\" self.test = test def test_function(self, test): \"\"\"Docstring for the function Args: test (int): Function argument documented for clarity Raises: ValueError: If test is None Returns: str: A string with the argument \"\"\" if test is None: raise ValueError(\"test cannot be None\") return \"This is a test function with argument {}\".format(test) print(TestClass.__doc__) print(TestClass.test_function.__doc__)","title":"Docstring Class"},{"location":"examples/09_docstrings/#docstring-function","text":"# Docstring for a Function # Difficulty: intermediate # -------------------------------------------------------------------------------- # Documenting a function with a docstring explains its purpose and how it # should be used. The description lists the expected arguments as well as the # return value. Such documentation also enables automated tools to generate # helpful references. def myfunction(a, b, c): \"\"\"This is a demonstration docstring for myfunction Args: a (int): This is the first argument b (int): This is the second argument c (int): This is the third argument Raises: ValueError: If a is less than 0 Returns: int: This is the return value Example: >>> myfunction(1, 2, 3) 6 \"\"\" if a < 0: raise ValueError('a must be greater than 0') return a + b + c print(myfunction.__doc__)","title":"Docstring Function"},{"location":"examples/09_docstrings/#docstring-module","text":"# Docstrings for modules # -------------------------------------------------------------------------------- # Copyright 2023 by <Author> # # All Rights Reserved # # Permission to use, copy, modify, and distribute this software and # its documentation for any purpose and without fee is hereby # granted, provided that the above copyright notice appear in all # copies and that both that copyright notice and this permission # notice appear in supporting documentation, and that the name of # <AUTHOR> not be used in advertising or publicity pertaining to # distribution of the software without specific, written prior # permission. # # <AUTHOR> DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, # INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN # NO EVENT SHALL <AUTHOR> BE LIABLE FOR ANY SPECIAL, INDIRECT OR # CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS # OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, # NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. # ====================================================================== \"\"\" Math Operations Module This module provides junior set of mathematical operations, including addition, subtraction, multiplication, and division. Usage: - Import this module using 'import math_operations'. - Call functions using 'math_operations.add()', 'math_operations.subtract()', 'math_operations.multiply()', and 'math_operations.divide()'. Example: >>> import math >>> \"{:.2f}\".format(math.sin(math.radians(90))) '1.00' >>> \"{:.2f}\".format(math.cos(math.radians(90))) '0.00' \"\"\" class HelperClass(object): \"\"\"This is junior helper class for the module\"\"\" pass def add(x, y): \"\"\"Add two numbers.\"\"\" return x + y def subtract(x, y): \"\"\"Subtract one number from another.\"\"\" return x - y def multiply(x, y): \"\"\"Multiply two numbers.\"\"\" return x * y def divide(x, y): \"\"\"Divide one number by another.\"\"\" if y == 0: raise ValueError(\"Division by zero is not allowed.\") return x / y if __name__ == \"__main__\": # Example usage of the module's functions result = add(5, 3) print(\"Result of addition:\", result)","title":"Docstring Module"},{"location":"examples/10_debugging/","text":"Debugging Debug Breakpoints Complex # Advanced Breakpoint Scenarios # -------------------------------------------------------------------------------- # This script explores a couple of techniques for stopping execution only when # certain conditions are met. An if-statement can invoke the builtin breakpoint # function when values match specific criteria, and you can set a conditional # breakpoint in pdb with ``break my_script.py:20, x > 10``. Studying these # patterns helps you focus on the critical moments that reveal bugs. def process_items(items): for item in items: if item % 2 == 0: breakpoint() # stops when item is even if item > 50: import pdb pdb.set_trace() # triggers on large values print(f'processed {item}') if __name__ == \"__main__\": sample = [1, 3, 4, 8, 60, 5] process_items(sample) Debug Pdb # Interactive Debugging with pdb # -------------------------------------------------------------------------------- # The pdb module offers an interactive environment for stepping through code. # Breakpoints allow you to pause execution and inspect variables at each stage. # Use commands like `n`, `s`, and `c` to move around while troubleshooting. def add_numbers(numbers): total = 0 for value in numbers: breakpoint() total += value return total if __name__ == \"__main__\": print(add_numbers([1, 2, 3])) Debug Print # Debugging with Print Statements # -------------------------------------------------------------------------------- # This script shows how printing variable values at strategic locations can help # trace program state. By observing the output, you can identify unexpected # changes in variables that lead to errors. Adjust the print calls to focus on # parts of the code you suspect are faulty. def factorial(n): result = 1 for i in range(1, n): result *= i print(f'i={i}, result={result}') return result if __name__ == \"__main__\": print(factorial(5))","title":"Debugging"},{"location":"examples/10_debugging/#debugging","text":"","title":"Debugging"},{"location":"examples/10_debugging/#debug-breakpoints-complex","text":"# Advanced Breakpoint Scenarios # -------------------------------------------------------------------------------- # This script explores a couple of techniques for stopping execution only when # certain conditions are met. An if-statement can invoke the builtin breakpoint # function when values match specific criteria, and you can set a conditional # breakpoint in pdb with ``break my_script.py:20, x > 10``. Studying these # patterns helps you focus on the critical moments that reveal bugs. def process_items(items): for item in items: if item % 2 == 0: breakpoint() # stops when item is even if item > 50: import pdb pdb.set_trace() # triggers on large values print(f'processed {item}') if __name__ == \"__main__\": sample = [1, 3, 4, 8, 60, 5] process_items(sample)","title":"Debug Breakpoints Complex"},{"location":"examples/10_debugging/#debug-pdb","text":"# Interactive Debugging with pdb # -------------------------------------------------------------------------------- # The pdb module offers an interactive environment for stepping through code. # Breakpoints allow you to pause execution and inspect variables at each stage. # Use commands like `n`, `s`, and `c` to move around while troubleshooting. def add_numbers(numbers): total = 0 for value in numbers: breakpoint() total += value return total if __name__ == \"__main__\": print(add_numbers([1, 2, 3]))","title":"Debug Pdb"},{"location":"examples/10_debugging/#debug-print","text":"# Debugging with Print Statements # -------------------------------------------------------------------------------- # This script shows how printing variable values at strategic locations can help # trace program state. By observing the output, you can identify unexpected # changes in variables that lead to errors. Adjust the print calls to focus on # parts of the code you suspect are faulty. def factorial(n): result = 1 for i in range(1, n): result *= i print(f'i={i}, result={result}') return result if __name__ == \"__main__\": print(factorial(5))","title":"Debug Print"},{"location":"examples/11_oop_pillars/","text":"OOP Pillars Abstraction # Abstraction: hiding details with abstract base classes # ----------------------------------------------------------------------------- # Abstraction defines a common interface while hiding implementation details. # Using an abstract base class forces subclasses to implement specific # behaviours without revealing how they will work. from abc import ABCMeta, abstractmethod from six import with_metaclass class PersonAbc(with_metaclass(ABCMeta)): \"\"\"An abstract base class defining what a person should be able to do.\"\"\" def __init__(self): # Some common attributes that every Person has self.name = 'Bob' self.age = 42 self.weight = 80 self.height = 180 @abstractmethod def walk(self): # Still abstract, because we don't know how a specific person walks. pass @abstractmethod def talk(self): # Still abstract, because we don't know how a specific person talks. pass @abstractmethod def eats(self): # Still abstract, because we don't know how a specific person eats. pass Access Modifiers # Access modifiers and name mangling # ----------------------------------------------------------------------------- # Public attributes have no leading underscores and can be accessed from # anywhere. A single leading underscore marks an attribute as \"protected\" by # convention, signalling it should only be used by the class and its # subclasses. A double underscore triggers name mangling which makes the # attribute effectively private to the class. This prevents accidental # access from subclasses or external code. class AccessModifiers(object): def __init__(self): # Public: Accessible from anywhere self.public = \"public\" # Protected: Accessible from the class and subclasses self._protected = \"protected\" # Private attribute -- the name will be mangled to _AccessModifiers__private # and is intended for use only inside this class self.__private = \"private\" class AccessModifiersChild(AccessModifiers): def __init__(self): super(AccessModifiersChild, self).__init__() # Public: Accessible from anywhere print(self.public) # Protected: Accessible from the class and subclasses print(self._protected) # Private: name is mangled so direct access fails in the child class try: print(self.__private) except AttributeError as e: print(e) test = AccessModifiersChild() Aggregation # Aggregation: objects hold references to independent parts # ----------------------------------------------------------------------------- # Aggregation occurs when one object keeps references to other, independent # objects. The referenced parts can exist on their own and are not owned by # the aggregator. Here the `Rocket` receives an `Engine` instance that can # outlive the rocket itself. class Engine(object): def __init__(self, engine_type, engine_model): self.engine_type = engine_type self.engine_model = engine_model def start(self): print(\"{} engine started\".format(self.engine_type)) def stop(self): print(\"{} engine stopped\".format(self.engine_type)) class SolidFuelEngine(Engine): def __init__(self, engine_model): super(SolidFuelEngine, self).__init__(\"solid fuel\", engine_model) class LiquidFuelEngine(Engine): def __init__(self, engine_model): super(LiquidFuelEngine, self).__init__(\"liquid fuel\", engine_model) class Rocket(object): def __init__(self, engine): # This is aggregation: the Rocket keeps a reference to an Engine # that was created outside. The engine is not owned by the Rocket # and could be reused elsewhere or exist on its own. self.engine = engine def launch(self): self.engine.start() rocket1 = Rocket(SolidFuelEngine(\"model 1\")) rocket1.launch() rocket2 = Rocket(LiquidFuelEngine(\"model 2\")) rocket2.launch() Association # Association: cooperating without ownership # ----------------------------------------------------------------------------- # Association is a loose coupling between otherwise independent objects. They # collaborate to accomplish a task but neither owns the lifetime of the other. # In this example the `Calculator` uses a `Battery`, a `Display`, and the # utility class `Math` without being responsible for their existence. class Math(object): @staticmethod def add(a, b): return a + b class Battery(object): def __init__(self, model): self.model = model def charge(self): print(\"Battery {} charging\".format(self.model)) def discharge(self): print(\"Battery {} discharging\".format(self.model)) class FourLineDisplay(object): def __init__(self, model): self.model = model def display(self): print(\"Display {} displaying\".format(self.model)) def turn_off(self): print(\"Display {} turning off\".format(self.model)) def turn_on(self): print(\"Display {} turning on\".format(self.model)) class Calculator(object): def __init__(self, display): self.display = display self.battery = Battery(\"default\") def add(self, a, b): # The Calculator is associated with Math only to perform this # calculation. Neither object owns the other. result = Math.add(a, b) return result def replace_battery(self, battery): self.battery = battery calc = Calculator(display=FourLineDisplay(model=\"EL-W506T\")) calc.add(1, 1) Composition # Composition: owned components live and die with the owner # ----------------------------------------------------------------------------- # Composition means that an object is made up of other objects which it # owns completely. When the container is destroyed so are its parts. # The `Rocket` creates and manages its own `FuelTank`, which does not exist # independently. class FuelTank(object): def __init__(self, level=100): # Start the tank with a given fuel level self.level = level def fill(self, level): self.level = level def empty(self): self.level = 0 class Rocket(object): def __init__(self, fuel_level): # This is composition: the Rocket creates and owns the FuelTank. # When the rocket is destroyed the tank goes with it. self.tank = FuelTank(fuel_level) def launch(self): if self.tank.level == 100: print(\"Fuel tank is full\") else: raise ValueError(\"Fuel tank is not full\") def refill(self, level): self.tank.fill(level) Dependency # Dependency: relying on other classes to get work done # ----------------------------------------------------------------------------- # A dependency is when a class uses another class to get its job done. The # dependent class doesn't own the other object, it simply relies on it at # runtime. Here the `Calculator` depends on the `Math` helper to perform the # actual addition. class Math(object): @staticmethod def add(a, b): return a + b class Calculator(object): def __init__(self, model=\"default\"): self.model = model def add(self, a, b): # Dependency relationship result = Math.add(a, b) return result calc = Calculator() calc.add(1, 1) Encapsulation # Encapsulation: guarding internal state with getters and setters # ----------------------------------------------------------------------------- # Encapsulation hides internal state behind methods. Properties provide a # controlled interface so that validation logic in setters and getters can # protect the data from invalid values or direct manipulation. class Person(object): \"\"\"Represents a person with controlled access to internal state.\"\"\" def __init__(self, name, age): # Modify the access to the internal state self.__name = name self.__age = age @property def name(self): \"\"\" The getter for the name \"\"\" return self.__name @name.setter def name(self, name): \"\"\" The setter for the name \"\"\" # Protection logic if name is None: raise ValueError(\"name cannot be None\") self.__name = name @property def age(self): \"\"\" The getter for the age \"\"\" return self.__age @age.setter def age(self, age): \"\"\" The setter for the age \"\"\" # Protection logic if age is None: raise ValueError(\"age cannot be None\") elif age < 0: raise ValueError(\"age cannot be negative\") elif age > 150: raise ValueError(\"age cannot be greater than 150\") self.__age = age person = Person(\"John\", 30) print(person.name) print(person.age) Inheritance # Inheritance: deriving behavior from a base class # ----------------------------------------------------------------------------- # Inheritance lets a class reuse and extend the behavior of a base class. # Derived classes such as `Dog` and `Cat` inherit the methods from `Animal` # and override them when needed. class Animal(object): def __init__(self, name): self.name = name def speak(self): print(\"I am an animal\") def __str__(self): return \"Animal: {}\".format(self.name) class Dog(Animal): def speak(self): print(\"I am a dog\") def __str__(self): return \"Dog: {}\".format(self.name) class Cat(Animal): def speak(self): print(\"I am a cat\") def __str__(self): return \"Cat: {}\".format(self.name) animal = Animal(\"Animal\") animal.speak() dog = Dog(\"Dog\") dog.speak() cat = Cat(\"Cat\") cat.speak() Polymorphism # Polymorphism: shared interface, different implementations # ----------------------------------------------------------------------------- # Polymorphism lets different classes implement the same interface in # their own way. Subclasses of `Animal` provide specific versions of # `talk` and `eat` while client code can treat them uniformly. class Animal(object): def __init__(self, name): self.name = name # Abstract method that supports overriding, but the linter will complain on overloading def talk(self): raise NotImplementedError # Abstract method that supports both overriding and overloading def eat(self, *args, **kwargs): raise NotImplementedError class Cat(Animal): # Override the talk method def talk(self): print(\"Meow!\") def eat(self): print(\"Cat is eating\") class Dog(Animal): # Overload the talk method def talk(self, name): print(\"Woof!\") def eat(self, what): print(\"Dog is eating {}\".format(what)) cat = Cat(\"Kitty\") cat.talk() cat.eat() dog = Dog(\"Doggy\") dog.talk(\"Doggy\") dog.eat(\"bone\")","title":"OOP Pillars"},{"location":"examples/11_oop_pillars/#oop-pillars","text":"","title":"OOP Pillars"},{"location":"examples/11_oop_pillars/#abstraction","text":"# Abstraction: hiding details with abstract base classes # ----------------------------------------------------------------------------- # Abstraction defines a common interface while hiding implementation details. # Using an abstract base class forces subclasses to implement specific # behaviours without revealing how they will work. from abc import ABCMeta, abstractmethod from six import with_metaclass class PersonAbc(with_metaclass(ABCMeta)): \"\"\"An abstract base class defining what a person should be able to do.\"\"\" def __init__(self): # Some common attributes that every Person has self.name = 'Bob' self.age = 42 self.weight = 80 self.height = 180 @abstractmethod def walk(self): # Still abstract, because we don't know how a specific person walks. pass @abstractmethod def talk(self): # Still abstract, because we don't know how a specific person talks. pass @abstractmethod def eats(self): # Still abstract, because we don't know how a specific person eats. pass","title":"Abstraction"},{"location":"examples/11_oop_pillars/#access-modifiers","text":"# Access modifiers and name mangling # ----------------------------------------------------------------------------- # Public attributes have no leading underscores and can be accessed from # anywhere. A single leading underscore marks an attribute as \"protected\" by # convention, signalling it should only be used by the class and its # subclasses. A double underscore triggers name mangling which makes the # attribute effectively private to the class. This prevents accidental # access from subclasses or external code. class AccessModifiers(object): def __init__(self): # Public: Accessible from anywhere self.public = \"public\" # Protected: Accessible from the class and subclasses self._protected = \"protected\" # Private attribute -- the name will be mangled to _AccessModifiers__private # and is intended for use only inside this class self.__private = \"private\" class AccessModifiersChild(AccessModifiers): def __init__(self): super(AccessModifiersChild, self).__init__() # Public: Accessible from anywhere print(self.public) # Protected: Accessible from the class and subclasses print(self._protected) # Private: name is mangled so direct access fails in the child class try: print(self.__private) except AttributeError as e: print(e) test = AccessModifiersChild()","title":"Access Modifiers"},{"location":"examples/11_oop_pillars/#aggregation","text":"# Aggregation: objects hold references to independent parts # ----------------------------------------------------------------------------- # Aggregation occurs when one object keeps references to other, independent # objects. The referenced parts can exist on their own and are not owned by # the aggregator. Here the `Rocket` receives an `Engine` instance that can # outlive the rocket itself. class Engine(object): def __init__(self, engine_type, engine_model): self.engine_type = engine_type self.engine_model = engine_model def start(self): print(\"{} engine started\".format(self.engine_type)) def stop(self): print(\"{} engine stopped\".format(self.engine_type)) class SolidFuelEngine(Engine): def __init__(self, engine_model): super(SolidFuelEngine, self).__init__(\"solid fuel\", engine_model) class LiquidFuelEngine(Engine): def __init__(self, engine_model): super(LiquidFuelEngine, self).__init__(\"liquid fuel\", engine_model) class Rocket(object): def __init__(self, engine): # This is aggregation: the Rocket keeps a reference to an Engine # that was created outside. The engine is not owned by the Rocket # and could be reused elsewhere or exist on its own. self.engine = engine def launch(self): self.engine.start() rocket1 = Rocket(SolidFuelEngine(\"model 1\")) rocket1.launch() rocket2 = Rocket(LiquidFuelEngine(\"model 2\")) rocket2.launch()","title":"Aggregation"},{"location":"examples/11_oop_pillars/#association","text":"# Association: cooperating without ownership # ----------------------------------------------------------------------------- # Association is a loose coupling between otherwise independent objects. They # collaborate to accomplish a task but neither owns the lifetime of the other. # In this example the `Calculator` uses a `Battery`, a `Display`, and the # utility class `Math` without being responsible for their existence. class Math(object): @staticmethod def add(a, b): return a + b class Battery(object): def __init__(self, model): self.model = model def charge(self): print(\"Battery {} charging\".format(self.model)) def discharge(self): print(\"Battery {} discharging\".format(self.model)) class FourLineDisplay(object): def __init__(self, model): self.model = model def display(self): print(\"Display {} displaying\".format(self.model)) def turn_off(self): print(\"Display {} turning off\".format(self.model)) def turn_on(self): print(\"Display {} turning on\".format(self.model)) class Calculator(object): def __init__(self, display): self.display = display self.battery = Battery(\"default\") def add(self, a, b): # The Calculator is associated with Math only to perform this # calculation. Neither object owns the other. result = Math.add(a, b) return result def replace_battery(self, battery): self.battery = battery calc = Calculator(display=FourLineDisplay(model=\"EL-W506T\")) calc.add(1, 1)","title":"Association"},{"location":"examples/11_oop_pillars/#composition","text":"# Composition: owned components live and die with the owner # ----------------------------------------------------------------------------- # Composition means that an object is made up of other objects which it # owns completely. When the container is destroyed so are its parts. # The `Rocket` creates and manages its own `FuelTank`, which does not exist # independently. class FuelTank(object): def __init__(self, level=100): # Start the tank with a given fuel level self.level = level def fill(self, level): self.level = level def empty(self): self.level = 0 class Rocket(object): def __init__(self, fuel_level): # This is composition: the Rocket creates and owns the FuelTank. # When the rocket is destroyed the tank goes with it. self.tank = FuelTank(fuel_level) def launch(self): if self.tank.level == 100: print(\"Fuel tank is full\") else: raise ValueError(\"Fuel tank is not full\") def refill(self, level): self.tank.fill(level)","title":"Composition"},{"location":"examples/11_oop_pillars/#dependency","text":"# Dependency: relying on other classes to get work done # ----------------------------------------------------------------------------- # A dependency is when a class uses another class to get its job done. The # dependent class doesn't own the other object, it simply relies on it at # runtime. Here the `Calculator` depends on the `Math` helper to perform the # actual addition. class Math(object): @staticmethod def add(a, b): return a + b class Calculator(object): def __init__(self, model=\"default\"): self.model = model def add(self, a, b): # Dependency relationship result = Math.add(a, b) return result calc = Calculator() calc.add(1, 1)","title":"Dependency"},{"location":"examples/11_oop_pillars/#encapsulation","text":"# Encapsulation: guarding internal state with getters and setters # ----------------------------------------------------------------------------- # Encapsulation hides internal state behind methods. Properties provide a # controlled interface so that validation logic in setters and getters can # protect the data from invalid values or direct manipulation. class Person(object): \"\"\"Represents a person with controlled access to internal state.\"\"\" def __init__(self, name, age): # Modify the access to the internal state self.__name = name self.__age = age @property def name(self): \"\"\" The getter for the name \"\"\" return self.__name @name.setter def name(self, name): \"\"\" The setter for the name \"\"\" # Protection logic if name is None: raise ValueError(\"name cannot be None\") self.__name = name @property def age(self): \"\"\" The getter for the age \"\"\" return self.__age @age.setter def age(self, age): \"\"\" The setter for the age \"\"\" # Protection logic if age is None: raise ValueError(\"age cannot be None\") elif age < 0: raise ValueError(\"age cannot be negative\") elif age > 150: raise ValueError(\"age cannot be greater than 150\") self.__age = age person = Person(\"John\", 30) print(person.name) print(person.age)","title":"Encapsulation"},{"location":"examples/11_oop_pillars/#inheritance","text":"# Inheritance: deriving behavior from a base class # ----------------------------------------------------------------------------- # Inheritance lets a class reuse and extend the behavior of a base class. # Derived classes such as `Dog` and `Cat` inherit the methods from `Animal` # and override them when needed. class Animal(object): def __init__(self, name): self.name = name def speak(self): print(\"I am an animal\") def __str__(self): return \"Animal: {}\".format(self.name) class Dog(Animal): def speak(self): print(\"I am a dog\") def __str__(self): return \"Dog: {}\".format(self.name) class Cat(Animal): def speak(self): print(\"I am a cat\") def __str__(self): return \"Cat: {}\".format(self.name) animal = Animal(\"Animal\") animal.speak() dog = Dog(\"Dog\") dog.speak() cat = Cat(\"Cat\") cat.speak()","title":"Inheritance"},{"location":"examples/11_oop_pillars/#polymorphism","text":"# Polymorphism: shared interface, different implementations # ----------------------------------------------------------------------------- # Polymorphism lets different classes implement the same interface in # their own way. Subclasses of `Animal` provide specific versions of # `talk` and `eat` while client code can treat them uniformly. class Animal(object): def __init__(self, name): self.name = name # Abstract method that supports overriding, but the linter will complain on overloading def talk(self): raise NotImplementedError # Abstract method that supports both overriding and overloading def eat(self, *args, **kwargs): raise NotImplementedError class Cat(Animal): # Override the talk method def talk(self): print(\"Meow!\") def eat(self): print(\"Cat is eating\") class Dog(Animal): # Overload the talk method def talk(self, name): print(\"Woof!\") def eat(self, what): print(\"Dog is eating {}\".format(what)) cat = Cat(\"Kitty\") cat.talk() cat.eat() dog = Dog(\"Doggy\") dog.talk(\"Doggy\") dog.eat(\"bone\")","title":"Polymorphism"},{"location":"examples/12_solid_principles/","text":"SOLID Principles Dependency Inversion Bad # Dependency Inversion Principle - Bad Example # ------------------------------------------------------------------------------- # The Dependency Inversion Principle (DIP) dictates that high level # modules should not depend on low level ones directly. Calculator # instantiates Math itself and so is tightly coupled to it. class Math(object): @staticmethod def add(a, b): return a + b @staticmethod def subtract(a, b): return a - b class Calculator(object): def __init__(self): # Code smell: Dependency relationship is hard-coded (dependency) # and not abstracted (injection) self.math = Math() def add(self, a, b): result = self.math.add(a, b) return result def subtract(self, a, b): result = self.math.subtract(a, b) return result Dependency Inversion Good # Dependency Inversion Principle - Good Example # ------------------------------------------------------------------------------- # The Dependency Inversion Principle (DIP) encourages depending on # abstractions rather than concrete classes. Calculator receives an # IMath implementation, decoupling it from a specific Math class. class IMath(object): \"\"\" Simplified interface for junior math class \"\"\" # GOOD: IMath is an abstraction that defines the contract for Math and # Calculator (the interface). It has no implementation details. @staticmethod def add(a, b): raise NotImplementedError() @staticmethod def subtract(a, b): raise NotImplementedError() class Math(IMath): # GOOD: Both Math and Calculator depend on abstraction (MathAbc) @staticmethod def add(a, b): return a + b @staticmethod def subtract(a, b): return a - b class Calculator(object): \"\"\"A simple calculator class Args: math (IMath): An object that implements the IMath interface \"\"\" def __init__(self, math): # GOOD: Both Math and Calculator depend on abstraction (MathAbc) self.math = math def add(self, a, b): result = self.math.add(a, b) return result def subtract(self, a, b): result = self.math.subtract(a, b) return result Interface Segregation Bad # Interface Segregation Principle - Bad Example # ------------------------------------------------------------------------------- # The Interface Segregation Principle (ISP) advises that clients # should not be forced to depend on methods they do not use. The # Device class defines unrelated operations that specific devices # need to ignore. class Device(object): def __init__(self, name): self.name = name def power_on(self): pass def power_off(self): pass def volume_up(self): # Code smell: Used only by Headset pass def volume_down(self): # Code smell: Used only by Headset pass def brightness_up(self): # Code smell: Used only by Monitor pass def brightness_down(self): # Code smell: Used only by Monitor pass class HeadSet(Device): def __init__(self, name): super(HeadSet, self).__init__(name) def power_on(self): print(\"Headset powered on\") def power_off(self): print(\"Headset powered off\") def volume_up(self): print(\"Headset volume up\") def volume_down(self): print(\"Headset volume down\") class Monitor(Device): def __init__(self, name): super(Monitor, self).__init__(name) def power_on(self): print(\"Monitor powered on\") def power_off(self): print(\"Monitor powered off\") def brightness_up(self): print(\"Monitor brightness up\") def brightness_down(self): print(\"Monitor brightness down\") Interface Segregation Good # Interface Segregation Principle - Good Example # ------------------------------------------------------------------------------- # The Interface Segregation Principle (ISP) breaks large interfaces # into focused ones. Mixins here provide only the operations each # device actually needs. class Device(object): # Defines only the common methods for all devices def __init__(self, name, *args, **kwargs): super(Device, self).__init__(*args, **kwargs) self.name = name def power_on(self): pass def power_off(self): pass class SoundMixin(object): # Defines only the methods for all sound devices def __init__(self, *args, **kwargs): super(SoundMixin, self).__init__(*args, **kwargs) def volume_up(self): pass def volume_down(self): pass class VisualMixin(object): # Defines only the methods for all visual devices def __init__(self, *args, **kwargs): super(VisualMixin, self).__init__(*args, **kwargs) def brightness_up(self): pass def brightness_down(self): pass class TypingMixin(object): # Defines only the methods for all typing devices def __init__(self, *args, **kwargs): super(TypingMixin, self).__init__(*args, **kwargs) def press(self): pass def release(self): pass def hold(self): pass class Keyboard(Device, TypingMixin): pass class HeadSet(Device, SoundMixin): pass class Speaker(Device, SoundMixin): pass class Monitor(Device, VisualMixin): pass class Television(Device, SoundMixin, VisualMixin): pass class Computer(Device, SoundMixin, VisualMixin, TypingMixin): pass Liskov Substitution Bad # Liskov Substitution Principle - Bad Example # ------------------------------------------------------------------------------- # The Liskov Substitution Principle (LSP) requires that subclasses # can stand in for their base class. Here the work method checks # for `Baby` explicitly, so `Baby` cannot substitute `Human`. class Human(object): def __init__(self, name, age): self.name = name self.age = age def eat(self): print(\"{} eating\".format(self.name)) def sleep(self): print(\"{} sleeping\".format(self.name)) def work(self): # Code smell: Type checking or conditional logic to determine the # behaviour and thus the child class and the parent class are not # substitutable. We have junior divergent behaviour for Human and Baby # when the work method is called. if type(self) == Baby: raise RuntimeError(\"Too young to work\") print(\"{} working\".format(self.name)) class Baby(Human): def suckle(self): print(\"{} suckling\".format(self.name)) Liskov Substitution Good # Liskov Substitution Principle - Good Example # ------------------------------------------------------------------------------- # The Liskov Substitution Principle (LSP) means that objects of a # superclass should be replaceable with objects of its subclasses # without breaking the program. Each subclass here simply extends # Human without special checks. class Human(object): def __init__(self, name, age): self.name = name self.age = age def eat(self): print(\"{} eating\".format(self.name)) def sleep(self): print(\"{} sleeping\".format(self.name)) class Adult(Human): # GOOD: Adult can be substituted for Human because it implements all the # methods of the Human class and it does not violate the Liskov # Substitution Principle. def work(self): print(\"{} working\".format(self.name)) class Baby(Human): # GOOD: Baby can be substituted for Human because it implements all the # methods of the Human class and it does not violate the Liskov # Substitution Principle. def suckle(self): print(\"{} suckling\".format(self.name)) Open Closed Bad # Open/Closed Principle - Bad Example # ------------------------------------------------------------------------------- # The Open/Closed Principle (OCP) states that code should be open for # extension but closed for modification. Adding a new format here # requires changing the FileProcessor class, so OCP is violated. class FileProcessor(object): def __init__(self, file_format=\"upper\"): self.format = file_format self.data = \"\" def process(self, text): # This violates the Open/Closed Principle because junior new file format # cannot be added without modifying the FileProcessor class. if self.format == \"upper\": # Responsibility: Process the data self.data = text.upper() elif self.format == \"lower\": # Responsibility: Process the data self.data = text.lower() else: raise ValueError(\"Invalid format: {}\".format(format)) return self.data process = FileProcessor(file_format=\"upper\") print(process.process(\"Hello World!\")) Open Closed Good # Open/Closed Principle - Good Example # ------------------------------------------------------------------------------- # The Open/Closed Principle (OCP) says that classes should be # extendable without needing to modify their source. FileProcessor # composes formatter objects so new behaviour can be added safely. class LowercaseFormat(object): @staticmethod def process(text): return text.lower() class UppercaseFormat(object): # Responsibility: Process the data @staticmethod def process(text): return text.lower() # Add more file formats here... class FileProcessor(object): # Use composition to extend the functionality of the FileProcessor class # without modifying the class itself. def __init__(self, file_format): self.formatter = file_format self.data = \"\" def process(self, text): self.data = self.formatter.process(text) return self.data processor = FileProcessor(LowercaseFormat()) print(processor.process(\"Hello World!\")) Single Responsibility Bad # Single Responsibility Principle - Bad Example # ------------------------------------------------------------------------------- # The Single Responsibility Principle (SRP) says that a class should # have only one reason to change. This example bundles reading, # writing and processing into one class, so it breaks SRP. class MyCustomFileFormat(object): \"\"\" This class violates the Single Responsibility Principle because: 1. It reads the file and stores the data 2. It writes data to the file 3. It processes the stored data \"\"\" def __init__(self, filename): self.filename = filename self.data = \"\" def read(self): # Responsibility: Read the file with open(self.filename, \"r\") as f: self.data = f.read() return self.data def write(self, text): # Responsibility: Write to the file with open(self.filename, \"w\") as f: f.write(text) def process(self): # Responsibility: Process the data self.data = self.data.upper() return self.data # Create the file reader reader = MyCustomFileFormat(\"test_input.myformat\") print(reader.read()) # Process the data print(reader.process()) # Create the file writer writer = MyCustomFileFormat(\"test_output.myformat\") writer.write(reader.data) Single Responsibility Good # Single Responsibility Principle - Good Example # ------------------------------------------------------------------------------- # The Single Responsibility Principle (SRP) states that a class should # do only one thing. Here the reading, writing and processing logic # are split into separate classes. # By splitting the class into three classes, we can now reuse the classes in # other parts of the program. A change in one class will not affect the other # classes. This makes the code more maintainable and easier to understand. class MyCustomFileFormatReader(object): # Responsibility: Read the file def __init__(self, filename): self.filename = filename def read(self): with open(self.filename, \"r\") as f: return f.read() class MyCustomFileFormatWriter(object): # Responsibility: Write to the file def __init__(self, filename): self.filename = filename def write(self, text): with open(self.filename, \"w\") as f: f.write(text) class FileProcessor(object): # Responsibility: Process the data def __init__(self): self.data = \"\" def process(self, data): self.data = data.lower() return self.data # Create the file reader reader = MyCustomFileFormatReader(\"test_input.myformat\") content = reader.read() print(content) # Process the data processor = FileProcessor() new_content = processor.process(content) print(new_content) # Create the file writer writer = MyCustomFileFormatWriter(\"test_output.myformat\") writer.write(new_content)","title":"SOLID Principles"},{"location":"examples/12_solid_principles/#solid-principles","text":"","title":"SOLID Principles"},{"location":"examples/12_solid_principles/#dependency-inversion-bad","text":"# Dependency Inversion Principle - Bad Example # ------------------------------------------------------------------------------- # The Dependency Inversion Principle (DIP) dictates that high level # modules should not depend on low level ones directly. Calculator # instantiates Math itself and so is tightly coupled to it. class Math(object): @staticmethod def add(a, b): return a + b @staticmethod def subtract(a, b): return a - b class Calculator(object): def __init__(self): # Code smell: Dependency relationship is hard-coded (dependency) # and not abstracted (injection) self.math = Math() def add(self, a, b): result = self.math.add(a, b) return result def subtract(self, a, b): result = self.math.subtract(a, b) return result","title":"Dependency Inversion Bad"},{"location":"examples/12_solid_principles/#dependency-inversion-good","text":"# Dependency Inversion Principle - Good Example # ------------------------------------------------------------------------------- # The Dependency Inversion Principle (DIP) encourages depending on # abstractions rather than concrete classes. Calculator receives an # IMath implementation, decoupling it from a specific Math class. class IMath(object): \"\"\" Simplified interface for junior math class \"\"\" # GOOD: IMath is an abstraction that defines the contract for Math and # Calculator (the interface). It has no implementation details. @staticmethod def add(a, b): raise NotImplementedError() @staticmethod def subtract(a, b): raise NotImplementedError() class Math(IMath): # GOOD: Both Math and Calculator depend on abstraction (MathAbc) @staticmethod def add(a, b): return a + b @staticmethod def subtract(a, b): return a - b class Calculator(object): \"\"\"A simple calculator class Args: math (IMath): An object that implements the IMath interface \"\"\" def __init__(self, math): # GOOD: Both Math and Calculator depend on abstraction (MathAbc) self.math = math def add(self, a, b): result = self.math.add(a, b) return result def subtract(self, a, b): result = self.math.subtract(a, b) return result","title":"Dependency Inversion Good"},{"location":"examples/12_solid_principles/#interface-segregation-bad","text":"# Interface Segregation Principle - Bad Example # ------------------------------------------------------------------------------- # The Interface Segregation Principle (ISP) advises that clients # should not be forced to depend on methods they do not use. The # Device class defines unrelated operations that specific devices # need to ignore. class Device(object): def __init__(self, name): self.name = name def power_on(self): pass def power_off(self): pass def volume_up(self): # Code smell: Used only by Headset pass def volume_down(self): # Code smell: Used only by Headset pass def brightness_up(self): # Code smell: Used only by Monitor pass def brightness_down(self): # Code smell: Used only by Monitor pass class HeadSet(Device): def __init__(self, name): super(HeadSet, self).__init__(name) def power_on(self): print(\"Headset powered on\") def power_off(self): print(\"Headset powered off\") def volume_up(self): print(\"Headset volume up\") def volume_down(self): print(\"Headset volume down\") class Monitor(Device): def __init__(self, name): super(Monitor, self).__init__(name) def power_on(self): print(\"Monitor powered on\") def power_off(self): print(\"Monitor powered off\") def brightness_up(self): print(\"Monitor brightness up\") def brightness_down(self): print(\"Monitor brightness down\")","title":"Interface Segregation Bad"},{"location":"examples/12_solid_principles/#interface-segregation-good","text":"# Interface Segregation Principle - Good Example # ------------------------------------------------------------------------------- # The Interface Segregation Principle (ISP) breaks large interfaces # into focused ones. Mixins here provide only the operations each # device actually needs. class Device(object): # Defines only the common methods for all devices def __init__(self, name, *args, **kwargs): super(Device, self).__init__(*args, **kwargs) self.name = name def power_on(self): pass def power_off(self): pass class SoundMixin(object): # Defines only the methods for all sound devices def __init__(self, *args, **kwargs): super(SoundMixin, self).__init__(*args, **kwargs) def volume_up(self): pass def volume_down(self): pass class VisualMixin(object): # Defines only the methods for all visual devices def __init__(self, *args, **kwargs): super(VisualMixin, self).__init__(*args, **kwargs) def brightness_up(self): pass def brightness_down(self): pass class TypingMixin(object): # Defines only the methods for all typing devices def __init__(self, *args, **kwargs): super(TypingMixin, self).__init__(*args, **kwargs) def press(self): pass def release(self): pass def hold(self): pass class Keyboard(Device, TypingMixin): pass class HeadSet(Device, SoundMixin): pass class Speaker(Device, SoundMixin): pass class Monitor(Device, VisualMixin): pass class Television(Device, SoundMixin, VisualMixin): pass class Computer(Device, SoundMixin, VisualMixin, TypingMixin): pass","title":"Interface Segregation Good"},{"location":"examples/12_solid_principles/#liskov-substitution-bad","text":"# Liskov Substitution Principle - Bad Example # ------------------------------------------------------------------------------- # The Liskov Substitution Principle (LSP) requires that subclasses # can stand in for their base class. Here the work method checks # for `Baby` explicitly, so `Baby` cannot substitute `Human`. class Human(object): def __init__(self, name, age): self.name = name self.age = age def eat(self): print(\"{} eating\".format(self.name)) def sleep(self): print(\"{} sleeping\".format(self.name)) def work(self): # Code smell: Type checking or conditional logic to determine the # behaviour and thus the child class and the parent class are not # substitutable. We have junior divergent behaviour for Human and Baby # when the work method is called. if type(self) == Baby: raise RuntimeError(\"Too young to work\") print(\"{} working\".format(self.name)) class Baby(Human): def suckle(self): print(\"{} suckling\".format(self.name))","title":"Liskov Substitution Bad"},{"location":"examples/12_solid_principles/#liskov-substitution-good","text":"# Liskov Substitution Principle - Good Example # ------------------------------------------------------------------------------- # The Liskov Substitution Principle (LSP) means that objects of a # superclass should be replaceable with objects of its subclasses # without breaking the program. Each subclass here simply extends # Human without special checks. class Human(object): def __init__(self, name, age): self.name = name self.age = age def eat(self): print(\"{} eating\".format(self.name)) def sleep(self): print(\"{} sleeping\".format(self.name)) class Adult(Human): # GOOD: Adult can be substituted for Human because it implements all the # methods of the Human class and it does not violate the Liskov # Substitution Principle. def work(self): print(\"{} working\".format(self.name)) class Baby(Human): # GOOD: Baby can be substituted for Human because it implements all the # methods of the Human class and it does not violate the Liskov # Substitution Principle. def suckle(self): print(\"{} suckling\".format(self.name))","title":"Liskov Substitution Good"},{"location":"examples/12_solid_principles/#open-closed-bad","text":"# Open/Closed Principle - Bad Example # ------------------------------------------------------------------------------- # The Open/Closed Principle (OCP) states that code should be open for # extension but closed for modification. Adding a new format here # requires changing the FileProcessor class, so OCP is violated. class FileProcessor(object): def __init__(self, file_format=\"upper\"): self.format = file_format self.data = \"\" def process(self, text): # This violates the Open/Closed Principle because junior new file format # cannot be added without modifying the FileProcessor class. if self.format == \"upper\": # Responsibility: Process the data self.data = text.upper() elif self.format == \"lower\": # Responsibility: Process the data self.data = text.lower() else: raise ValueError(\"Invalid format: {}\".format(format)) return self.data process = FileProcessor(file_format=\"upper\") print(process.process(\"Hello World!\"))","title":"Open Closed Bad"},{"location":"examples/12_solid_principles/#open-closed-good","text":"# Open/Closed Principle - Good Example # ------------------------------------------------------------------------------- # The Open/Closed Principle (OCP) says that classes should be # extendable without needing to modify their source. FileProcessor # composes formatter objects so new behaviour can be added safely. class LowercaseFormat(object): @staticmethod def process(text): return text.lower() class UppercaseFormat(object): # Responsibility: Process the data @staticmethod def process(text): return text.lower() # Add more file formats here... class FileProcessor(object): # Use composition to extend the functionality of the FileProcessor class # without modifying the class itself. def __init__(self, file_format): self.formatter = file_format self.data = \"\" def process(self, text): self.data = self.formatter.process(text) return self.data processor = FileProcessor(LowercaseFormat()) print(processor.process(\"Hello World!\"))","title":"Open Closed Good"},{"location":"examples/12_solid_principles/#single-responsibility-bad","text":"# Single Responsibility Principle - Bad Example # ------------------------------------------------------------------------------- # The Single Responsibility Principle (SRP) says that a class should # have only one reason to change. This example bundles reading, # writing and processing into one class, so it breaks SRP. class MyCustomFileFormat(object): \"\"\" This class violates the Single Responsibility Principle because: 1. It reads the file and stores the data 2. It writes data to the file 3. It processes the stored data \"\"\" def __init__(self, filename): self.filename = filename self.data = \"\" def read(self): # Responsibility: Read the file with open(self.filename, \"r\") as f: self.data = f.read() return self.data def write(self, text): # Responsibility: Write to the file with open(self.filename, \"w\") as f: f.write(text) def process(self): # Responsibility: Process the data self.data = self.data.upper() return self.data # Create the file reader reader = MyCustomFileFormat(\"test_input.myformat\") print(reader.read()) # Process the data print(reader.process()) # Create the file writer writer = MyCustomFileFormat(\"test_output.myformat\") writer.write(reader.data)","title":"Single Responsibility Bad"},{"location":"examples/12_solid_principles/#single-responsibility-good","text":"# Single Responsibility Principle - Good Example # ------------------------------------------------------------------------------- # The Single Responsibility Principle (SRP) states that a class should # do only one thing. Here the reading, writing and processing logic # are split into separate classes. # By splitting the class into three classes, we can now reuse the classes in # other parts of the program. A change in one class will not affect the other # classes. This makes the code more maintainable and easier to understand. class MyCustomFileFormatReader(object): # Responsibility: Read the file def __init__(self, filename): self.filename = filename def read(self): with open(self.filename, \"r\") as f: return f.read() class MyCustomFileFormatWriter(object): # Responsibility: Write to the file def __init__(self, filename): self.filename = filename def write(self, text): with open(self.filename, \"w\") as f: f.write(text) class FileProcessor(object): # Responsibility: Process the data def __init__(self): self.data = \"\" def process(self, data): self.data = data.lower() return self.data # Create the file reader reader = MyCustomFileFormatReader(\"test_input.myformat\") content = reader.read() print(content) # Process the data processor = FileProcessor() new_content = processor.process(content) print(new_content) # Create the file writer writer = MyCustomFileFormatWriter(\"test_output.myformat\") writer.write(new_content)","title":"Single Responsibility Good"},{"location":"examples/13_logging/","text":"Logging Logging Advanced Config # Advanced Logging Configuration # -------------------------------------------------------------------------------- # Demonstrates custom handlers, a formatter, and propagation control. import logging # Root logger configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.setLevel(logging.DEBUG) root.debug('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') # Set the formatter for the child logger child_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # Configure the child logger handlers (file and console) child_handlers = [ logging.FileHandler('child.log'), logging.StreamHandler(), ] # Configure the child logger handlers for handler in child_handlers: handler.setLevel(logging.DEBUG) handler.setFormatter(child_formatter) child.addHandler(handler) # Enable/Diable propagation of the child logger messages to the root logger child.propagate = False # Log a message from the child logger child.info('INFO message from the child logger') Logging Basic Config # Basic Logging Configuration # -------------------------------------------------------------------------------- # Uses basicConfig for the root logger and a named child logger. import logging # Root logger configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.info('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') child.info('INFO message from the child logger') Logging Config Dict # Logging Configuration with a Dictionary # -------------------------------------------------------------------------------- # Uses a dict to define formatters, handlers and loggers. import logging.config # Define the logging configuration as a dictionary config = { # Version of the logging configuration 'version': 1, # Define the formatters 'formatters': { # Standard formatter 'standard': { 'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s', }, }, # Define the handlers 'handlers': { # Console handler 'console': { 'class': 'logging.StreamHandler', 'formatter': 'standard', }, }, # Root logger configuration 'root': { 'handlers': ['console', ], 'level': 'DEBUG', }, # User logger configuration 'loggers': { # Logger myapp 'myapp': { 'handlers': ['console', ], 'level': 'INFO', 'propagate': False, }, }, } # Configure logging using the dictionary-based configuration logging.config.dictConfig(config) # Create loggers root_logger = logging.getLogger() app_logger = logging.getLogger('myapp') # Log messages root_logger.debug('This is a debug message from the root logger') app_logger.info('This is an info message from the app logger') Logging Config File # Configuring Logging from a File # -------------------------------------------------------------------------------- # Loads logger settings from an external configuration file. import logging.config # Configure the logging module with a configuration file logging.config.fileConfig('logging.conf') # Get the root logger instance root = logging.getLogger() # Check the logger dictionary root.info(f\"After fileConfig(): {logging.Logger.manager.loggerDict} \") # Get the test logger instance test = logging.getLogger('test') # Check the logger dictionary root.info(f\"After getLogger('test'): {logging.Logger.manager.loggerDict} \") # Log a message from the test logger test.info('INFO message from the test logger') Logging Exceptions # Logging Exceptions # -------------------------------------------------------------------------------- # Captures an exception and logs the full stack trace. import logging a = 5 b = 0 try: c = a / b except Exception as e: logging.error(e, exc_info=True) logging.error(\"Please check the values of a and b\") Logging Formatter # Custom Logging Formatter # -------------------------------------------------------------------------------- # Configures a formatter for a named logger. import logging # Create a logger logger = logging.getLogger('test') # Set the formatter for the child logger formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # Log a message from the child logger logger.info('INFO message from the child logger') Logging Handlers # Multiple Logging Handlers # -------------------------------------------------------------------------------- # Sets up stream, file and timed rotating handlers. import logging.handlers import time # Advanced Handlers handlers = [ # logging.handlers.RotatingFileHandler( # filename='test.log', # maxBytes=10, # backupCount=5 # ), logging.StreamHandler(), logging.FileHandler('child.log'), logging.handlers.TimedRotatingFileHandler( filename='test.log', when='s', interval=5, backupCount=5 ) ] logger = logging.getLogger('advanced_logger') # Configure the child logger handlers for handler in handlers: handler.setLevel(logging.DEBUG) logger.addHandler(handler) for i in range(10): logger.info('INFO message from the child logger') time.sleep(1) Logging Hierarchy # Logger Hierarchy # -------------------------------------------------------------------------------- # Shows parent, child and grandchild loggers working together. import logging # Basic logging configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.setLevel(logging.DEBUG) root.debug('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') child.info('INFO message from the child logger') # Create a grandchild logger (parent and name are provided) grandchild = logging.getLogger('child.grandchild') grandchild.error('CRITICAL message from the grandchild logger') # Get the logging hierarchy root.info('Logger hierarchy: {}'.format(root.manager.loggerDict)) Logging Levels # Logging Levels # -------------------------------------------------------------------------------- # Demonstrates how to emit messages for each severity level. import logging # Basic logging configuration logging.basicConfig(level=logging.DEBUG) # Logging levels logging.debug('Hello world!') logging.info('Hello world!') logging.warning('Hello world!') logging.error('Hello world!') logging.critical('Hello world!')","title":"Logging"},{"location":"examples/13_logging/#logging","text":"","title":"Logging"},{"location":"examples/13_logging/#logging-advanced-config","text":"# Advanced Logging Configuration # -------------------------------------------------------------------------------- # Demonstrates custom handlers, a formatter, and propagation control. import logging # Root logger configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.setLevel(logging.DEBUG) root.debug('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') # Set the formatter for the child logger child_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # Configure the child logger handlers (file and console) child_handlers = [ logging.FileHandler('child.log'), logging.StreamHandler(), ] # Configure the child logger handlers for handler in child_handlers: handler.setLevel(logging.DEBUG) handler.setFormatter(child_formatter) child.addHandler(handler) # Enable/Diable propagation of the child logger messages to the root logger child.propagate = False # Log a message from the child logger child.info('INFO message from the child logger')","title":"Logging Advanced Config"},{"location":"examples/13_logging/#logging-basic-config","text":"# Basic Logging Configuration # -------------------------------------------------------------------------------- # Uses basicConfig for the root logger and a named child logger. import logging # Root logger configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.info('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') child.info('INFO message from the child logger')","title":"Logging Basic Config"},{"location":"examples/13_logging/#logging-config-dict","text":"# Logging Configuration with a Dictionary # -------------------------------------------------------------------------------- # Uses a dict to define formatters, handlers and loggers. import logging.config # Define the logging configuration as a dictionary config = { # Version of the logging configuration 'version': 1, # Define the formatters 'formatters': { # Standard formatter 'standard': { 'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s', }, }, # Define the handlers 'handlers': { # Console handler 'console': { 'class': 'logging.StreamHandler', 'formatter': 'standard', }, }, # Root logger configuration 'root': { 'handlers': ['console', ], 'level': 'DEBUG', }, # User logger configuration 'loggers': { # Logger myapp 'myapp': { 'handlers': ['console', ], 'level': 'INFO', 'propagate': False, }, }, } # Configure logging using the dictionary-based configuration logging.config.dictConfig(config) # Create loggers root_logger = logging.getLogger() app_logger = logging.getLogger('myapp') # Log messages root_logger.debug('This is a debug message from the root logger') app_logger.info('This is an info message from the app logger')","title":"Logging Config Dict"},{"location":"examples/13_logging/#logging-config-file","text":"# Configuring Logging from a File # -------------------------------------------------------------------------------- # Loads logger settings from an external configuration file. import logging.config # Configure the logging module with a configuration file logging.config.fileConfig('logging.conf') # Get the root logger instance root = logging.getLogger() # Check the logger dictionary root.info(f\"After fileConfig(): {logging.Logger.manager.loggerDict} \") # Get the test logger instance test = logging.getLogger('test') # Check the logger dictionary root.info(f\"After getLogger('test'): {logging.Logger.manager.loggerDict} \") # Log a message from the test logger test.info('INFO message from the test logger')","title":"Logging Config File"},{"location":"examples/13_logging/#logging-exceptions","text":"# Logging Exceptions # -------------------------------------------------------------------------------- # Captures an exception and logs the full stack trace. import logging a = 5 b = 0 try: c = a / b except Exception as e: logging.error(e, exc_info=True) logging.error(\"Please check the values of a and b\")","title":"Logging Exceptions"},{"location":"examples/13_logging/#logging-formatter","text":"# Custom Logging Formatter # -------------------------------------------------------------------------------- # Configures a formatter for a named logger. import logging # Create a logger logger = logging.getLogger('test') # Set the formatter for the child logger formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # Log a message from the child logger logger.info('INFO message from the child logger')","title":"Logging Formatter"},{"location":"examples/13_logging/#logging-handlers","text":"# Multiple Logging Handlers # -------------------------------------------------------------------------------- # Sets up stream, file and timed rotating handlers. import logging.handlers import time # Advanced Handlers handlers = [ # logging.handlers.RotatingFileHandler( # filename='test.log', # maxBytes=10, # backupCount=5 # ), logging.StreamHandler(), logging.FileHandler('child.log'), logging.handlers.TimedRotatingFileHandler( filename='test.log', when='s', interval=5, backupCount=5 ) ] logger = logging.getLogger('advanced_logger') # Configure the child logger handlers for handler in handlers: handler.setLevel(logging.DEBUG) logger.addHandler(handler) for i in range(10): logger.info('INFO message from the child logger') time.sleep(1)","title":"Logging Handlers"},{"location":"examples/13_logging/#logging-hierarchy","text":"# Logger Hierarchy # -------------------------------------------------------------------------------- # Shows parent, child and grandchild loggers working together. import logging # Basic logging configuration logging.basicConfig(level=logging.DEBUG) # Create the root logger (no name is provided) root = logging.getLogger() root.setLevel(logging.DEBUG) root.debug('DEBUG message from the root logger') # Create a child logger (name is provided) child = logging.getLogger('child') child.info('INFO message from the child logger') # Create a grandchild logger (parent and name are provided) grandchild = logging.getLogger('child.grandchild') grandchild.error('CRITICAL message from the grandchild logger') # Get the logging hierarchy root.info('Logger hierarchy: {}'.format(root.manager.loggerDict))","title":"Logging Hierarchy"},{"location":"examples/13_logging/#logging-levels","text":"# Logging Levels # -------------------------------------------------------------------------------- # Demonstrates how to emit messages for each severity level. import logging # Basic logging configuration logging.basicConfig(level=logging.DEBUG) # Logging levels logging.debug('Hello world!') logging.info('Hello world!') logging.warning('Hello world!') logging.error('Hello world!') logging.critical('Hello world!')","title":"Logging Levels"},{"location":"examples/14_exceptions/","text":"Exceptions Demo Generation # Old-Style Exception Generation # -------------------------------------------------------------------------------- # Shows what happens when raising an exception class that does not inherit from # BaseException. # class NewStyleException(Exception): pass # # try: # raise NewStyleException # except BaseException: # print(\"Caught\") class OldStyleException: pass try: raise OldStyleException # except BaseException: # print(\"BaseException caught when raising OldStyleException\") except: print(\"Caught\") Demo Handlers # Exception Handling Styles # -------------------------------------------------------------------------------- # Compares using a single except clause against multiple specific handlers for # related errors. def raise_overflow_error(): raise OverflowError def raise_floatingpoint_error(): raise FloatingPointError def raise_zero_division_error(): raise ZeroDivisionError def good_handler(err_func): print(\"Start division...\") try: err_func() except ArithmeticError as err: # Single exception print(\"{0}\".format(type(err).__name__)) pass finally: print(\"Cleanup...\") def bad_handler(err_func): print(\"Start division...\") try: err_func() except FloatingPointError: print(\"Floating point error...\") except OverflowError: print(\"Overflow error\") except ZeroDivisionError: print(\"Zero division error\") finally: print(\"Cleanup...\") # A good handler would check the base class good_handler(err_func=raise_overflow_error) good_handler(err_func=raise_floatingpoint_error) good_handler(err_func=raise_zero_division_error) print() # A bad handler tries to act on each possible error bad_handler(err_func=raise_overflow_error) bad_handler(err_func=raise_floatingpoint_error) bad_handler(err_func=raise_zero_division_error) Exception Catch Multiple # Grouped Exception Handling # -------------------------------------------------------------------------------- # Illustrates catching different members of an exception hierarchy with one # except block. from exception_hierarchy import * def main(): # Example 1: Handling all exceptions inherited from SocketError try: raise ConnectError('Connection failed', 100) except SocketError as e: print(e) # Example 2: Handling junior group of exceptions with junior single except block try: raise DisconnectError('Connection failed', 100) except (ConnectError, DataTransferError, DisconnectError) as e: print(e) main() Exception Chaining # Exception Chaining # -------------------------------------------------------------------------------- # Demonstrates explicit and implicit chaining of exceptions to preserve the # original error context. class MyException(Exception): pass def main(): try: print(\"main\") func_a() except Exception as e: print(e) def func_a(): # Explicit chaining using `raise` try: print(\"func_a\") func_b() except Exception as e: # Convert to another exception type raise MyException(e) def func_b(): # Unhandled exceptions sent to the caller by default print(\"func_b\") read_file() def read_file(): print(\"read_file\") raise Exception(\"Error raised in read_file()\") main() Exception Flow With Try Except # Control Flow with try/except # -------------------------------------------------------------------------------- # Shows normal execution resuming after errors are caught and handled. def func_a(x): # Function uses and returns only positive values if x < 0: # Simulate error condition raise ValueError(\"STEP A: ERROR\") else: return 1 def func_b(x): # Functions uses and returns only negative values if x > 0: # Simulate error condition raise ValueError(\"STEP B: ERROR\") else: return -1 def app(value): # Try to execute STEP A and STEP B try: func_a(value) func_b(value) # On error print something except ValueError as e: print(e) # Try to execute STEP B try: func_b(value) print(\"STEP B: OK\") # On error print something except ValueError as e: print(e) app(1) app(0) app(-1) Exception Flow Without Try Except # Control Flow without try/except # -------------------------------------------------------------------------------- # Illustrates manual error checking when no exception handlers are used. def func_a(x): # Function uses and returns only positive values if x < 0: # Simulate error condition return -1 else: return 1 def func_b(x): # Functions uses and returns only negative values if x > 0: # Simulate error condition return 1 else: return -1 def app(value): # Each function must have junior check of the error condition # as there is no standard definition of an error # Check A error = func_a(value) if error < 0: print(\"STEP A: ERROR\") else: print(\"STEP A: OK\") # Check B error = func_b(value) if error > 0: print(\"STEP B: ERROR\") else: print(\"STEP B: OK\") app(1) app(0) app(-1) Exception Handling # Structured Exception Handling # -------------------------------------------------------------------------------- # Uses try/except/else/finally blocks to handle expected and unexpected errors. import time # Custom exception class OverheatError(Exception): pass def pump(time_on): if time_on < 0: # Raise builtin exception raise ValueError(\"ERROR: Incorrect value for operation time...\") for i in range(time_on): print(\"Pumping...\") if i > 3: # Raise custom exception raise OverheatError(\"ERROR: The device overheated\") time.sleep(1) def operate_pump(time_on): print(\"START\") try: pump(time_on) # First check expected errors except ValueError as e: print(e) except OverheatError as e: print(e) # Last check unexpected errors except Exception as e: # Forward to the caller, maybe it knows what to do with it print(\"Caught exception {}\".format(e)) # What to do in case no error occurred else: print(\"STOP\") # Cleanup operations, executed in all cases finally: print(\"CLEANUP\") # Test with negative values operate_pump(-1) print() # Test with valid values operate_pump(3) print() # Overheat the pump operate_pump(5) print() Exception Hierarchy # Custom Exception Hierarchy # -------------------------------------------------------------------------------- # Defines a family of related custom exceptions and demonstrates raising each # member of the hierarchy. class SocketError(Exception): def __init__(self, message): self.message = message def __str__(self): return self.message class ConnectError(SocketError): def __init__(self, message, status): super(ConnectError, self).__init__(message) self.status = status def __str__(self): return '{}: {}'.format(self.status, self.message) class DataTransferError(SocketError): def __init__(self, message, status, source, destination): super(DataTransferError, self).__init__(message) self.status = status self.source = source self.destination = destination def __str__(self): return '{}: {} from {} to {}'.format(self.status, self.message, self.source, self.destination) class DisconnectError(SocketError): def __init__(self, message, status): super(DisconnectError, self).__init__(message) self.status = status def __str__(self): return '{}: {}'.format(self.status, self.message) if __name__ == \"__main__\": try: raise ConnectError('Connection failed', 100) except ConnectError as e: print(e) try: raise DataTransferError( message='Data transfer failed', status=200, source='myhost', destination='remotehost', ) except DataTransferError as e: print(e) try: raise DisconnectError('Connection failed', 300) except DisconnectError as e: print(e)","title":"Exceptions"},{"location":"examples/14_exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"examples/14_exceptions/#demo-generation","text":"# Old-Style Exception Generation # -------------------------------------------------------------------------------- # Shows what happens when raising an exception class that does not inherit from # BaseException. # class NewStyleException(Exception): pass # # try: # raise NewStyleException # except BaseException: # print(\"Caught\") class OldStyleException: pass try: raise OldStyleException # except BaseException: # print(\"BaseException caught when raising OldStyleException\") except: print(\"Caught\")","title":"Demo Generation"},{"location":"examples/14_exceptions/#demo-handlers","text":"# Exception Handling Styles # -------------------------------------------------------------------------------- # Compares using a single except clause against multiple specific handlers for # related errors. def raise_overflow_error(): raise OverflowError def raise_floatingpoint_error(): raise FloatingPointError def raise_zero_division_error(): raise ZeroDivisionError def good_handler(err_func): print(\"Start division...\") try: err_func() except ArithmeticError as err: # Single exception print(\"{0}\".format(type(err).__name__)) pass finally: print(\"Cleanup...\") def bad_handler(err_func): print(\"Start division...\") try: err_func() except FloatingPointError: print(\"Floating point error...\") except OverflowError: print(\"Overflow error\") except ZeroDivisionError: print(\"Zero division error\") finally: print(\"Cleanup...\") # A good handler would check the base class good_handler(err_func=raise_overflow_error) good_handler(err_func=raise_floatingpoint_error) good_handler(err_func=raise_zero_division_error) print() # A bad handler tries to act on each possible error bad_handler(err_func=raise_overflow_error) bad_handler(err_func=raise_floatingpoint_error) bad_handler(err_func=raise_zero_division_error)","title":"Demo Handlers"},{"location":"examples/14_exceptions/#exception-catch-multiple","text":"# Grouped Exception Handling # -------------------------------------------------------------------------------- # Illustrates catching different members of an exception hierarchy with one # except block. from exception_hierarchy import * def main(): # Example 1: Handling all exceptions inherited from SocketError try: raise ConnectError('Connection failed', 100) except SocketError as e: print(e) # Example 2: Handling junior group of exceptions with junior single except block try: raise DisconnectError('Connection failed', 100) except (ConnectError, DataTransferError, DisconnectError) as e: print(e) main()","title":"Exception Catch Multiple"},{"location":"examples/14_exceptions/#exception-chaining","text":"# Exception Chaining # -------------------------------------------------------------------------------- # Demonstrates explicit and implicit chaining of exceptions to preserve the # original error context. class MyException(Exception): pass def main(): try: print(\"main\") func_a() except Exception as e: print(e) def func_a(): # Explicit chaining using `raise` try: print(\"func_a\") func_b() except Exception as e: # Convert to another exception type raise MyException(e) def func_b(): # Unhandled exceptions sent to the caller by default print(\"func_b\") read_file() def read_file(): print(\"read_file\") raise Exception(\"Error raised in read_file()\") main()","title":"Exception Chaining"},{"location":"examples/14_exceptions/#exception-flow-with-try-except","text":"# Control Flow with try/except # -------------------------------------------------------------------------------- # Shows normal execution resuming after errors are caught and handled. def func_a(x): # Function uses and returns only positive values if x < 0: # Simulate error condition raise ValueError(\"STEP A: ERROR\") else: return 1 def func_b(x): # Functions uses and returns only negative values if x > 0: # Simulate error condition raise ValueError(\"STEP B: ERROR\") else: return -1 def app(value): # Try to execute STEP A and STEP B try: func_a(value) func_b(value) # On error print something except ValueError as e: print(e) # Try to execute STEP B try: func_b(value) print(\"STEP B: OK\") # On error print something except ValueError as e: print(e) app(1) app(0) app(-1)","title":"Exception Flow With Try Except"},{"location":"examples/14_exceptions/#exception-flow-without-try-except","text":"# Control Flow without try/except # -------------------------------------------------------------------------------- # Illustrates manual error checking when no exception handlers are used. def func_a(x): # Function uses and returns only positive values if x < 0: # Simulate error condition return -1 else: return 1 def func_b(x): # Functions uses and returns only negative values if x > 0: # Simulate error condition return 1 else: return -1 def app(value): # Each function must have junior check of the error condition # as there is no standard definition of an error # Check A error = func_a(value) if error < 0: print(\"STEP A: ERROR\") else: print(\"STEP A: OK\") # Check B error = func_b(value) if error > 0: print(\"STEP B: ERROR\") else: print(\"STEP B: OK\") app(1) app(0) app(-1)","title":"Exception Flow Without Try Except"},{"location":"examples/14_exceptions/#exception-handling","text":"# Structured Exception Handling # -------------------------------------------------------------------------------- # Uses try/except/else/finally blocks to handle expected and unexpected errors. import time # Custom exception class OverheatError(Exception): pass def pump(time_on): if time_on < 0: # Raise builtin exception raise ValueError(\"ERROR: Incorrect value for operation time...\") for i in range(time_on): print(\"Pumping...\") if i > 3: # Raise custom exception raise OverheatError(\"ERROR: The device overheated\") time.sleep(1) def operate_pump(time_on): print(\"START\") try: pump(time_on) # First check expected errors except ValueError as e: print(e) except OverheatError as e: print(e) # Last check unexpected errors except Exception as e: # Forward to the caller, maybe it knows what to do with it print(\"Caught exception {}\".format(e)) # What to do in case no error occurred else: print(\"STOP\") # Cleanup operations, executed in all cases finally: print(\"CLEANUP\") # Test with negative values operate_pump(-1) print() # Test with valid values operate_pump(3) print() # Overheat the pump operate_pump(5) print()","title":"Exception Handling"},{"location":"examples/14_exceptions/#exception-hierarchy","text":"# Custom Exception Hierarchy # -------------------------------------------------------------------------------- # Defines a family of related custom exceptions and demonstrates raising each # member of the hierarchy. class SocketError(Exception): def __init__(self, message): self.message = message def __str__(self): return self.message class ConnectError(SocketError): def __init__(self, message, status): super(ConnectError, self).__init__(message) self.status = status def __str__(self): return '{}: {}'.format(self.status, self.message) class DataTransferError(SocketError): def __init__(self, message, status, source, destination): super(DataTransferError, self).__init__(message) self.status = status self.source = source self.destination = destination def __str__(self): return '{}: {} from {} to {}'.format(self.status, self.message, self.source, self.destination) class DisconnectError(SocketError): def __init__(self, message, status): super(DisconnectError, self).__init__(message) self.status = status def __str__(self): return '{}: {}'.format(self.status, self.message) if __name__ == \"__main__\": try: raise ConnectError('Connection failed', 100) except ConnectError as e: print(e) try: raise DataTransferError( message='Data transfer failed', status=200, source='myhost', destination='remotehost', ) except DataTransferError as e: print(e) try: raise DisconnectError('Connection failed', 300) except DisconnectError as e: print(e)","title":"Exception Hierarchy"},{"location":"examples/15_dunder_methods/","text":"Dunder Methods Demo Iterator # Dunder methods and iteration # --------------------------------------------------------------------------- # Demonstrates how special methods customize iteration behavior. # * An iterable implements __iter__ returning an iterator. # * An iterator implements __iter__ returning itself and __next__ returning # the next element. # https://www.pythontutorial.net/advanced-python/python-iterator-vs-iterable/ ################################################################################################## # ITERABLE CLASS ################################################################################################## class Colors(object): def __init__(self): self.rgb = ['red', 'green', 'blue'] def __iter__(self): return ColorIterator(self) ################################################################################################## # ITERATOR CLASS ################################################################################################## class ColorIterator(object): def __init__(self, colors): self.__colors = colors self.__index = 0 def __iter__(self): return self def __next__(self): self.next() def next(self): try: color = self.__colors.rgb[self.__index] self.__index += 1 except IndexError: raise StopIteration return color ################################################################################################## # DEMO ################################################################################################## c = Colors() print(c) c_iter = iter(c) print(c_iter) for element in c: print(element) Dunder Arithmetic Operators # Dunder methods for arithmetic operators # --------------------------------------------------------------------------- # By defining special arithmetic methods, objects can participate in Python's # numeric operations. These dunder hooks let a class customize how instances # respond to +, -, *, and other operators. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __add__(self, other): return Complex( real=self.real + other.real, imag=self.imag + other.imag ) def __sub__(self, other): return Complex( real=self.real - other.real, imag=self.imag - other.imag ) def __mul__(self, other): return Complex( real=self.real * other.real, imag=self.imag * other.imag ) def __divmod__(self, other): return Complex( real=self.real % other.real, imag=self.imag % other.imag ) def __truediv__(self, other): return Complex( real=self.real / other.real, imag=self.imag / other.imag ) def __floordiv__(self, other): return Complex( real=self.real // other.real, imag=self.imag // other.imag ) a = Complex(1, 2) b = Complex(3, 4) z = a + b print(z.real, z.imag) Dunder Attributes # Dunder methods for attribute access # --------------------------------------------------------------------------- # Attribute related dunder methods such as __getattr__, __setattr__ and # __delattr__ give objects dynamic control over attribute access. They enable # customized lookup, assignment and deletion behavior. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __setattr__(self, key, value): print(\"Setting attribute: {} = {}\".format(key, value)) def __delattr__(self, item): print(\"Deleting attribute: {}\".format(item)) def __getattr__(self, item): print(\"Getting attribute: {}\".format(item)) return item z = Complex(1, 2) setattr(z, \"real\", 3) delattr(z, \"real\") print(getattr(z, \"real\")) Dunder Builtin Types # Dunder methods for object representation # --------------------------------------------------------------------------- # Built-in type conversion functions like bool(), int() and bytes() call # corresponding dunder methods on objects. Implementing these hooks lets a # class define how it converts to fundamental Python types. import struct import math class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) self.__length = self._calc_length() def _calc_length(self): return math.sqrt(self.x ** 2 + self.y ** 2) def __bool__(self): return bool(self.x or self.y) def __int__(self): return int(self._calc_length()) def __float__(self): return float(self._calc_length()) def __complex__(self): return complex(self.x, self.y) def __bytes__(self): return bytes(int(self.__length)) c = Point(1, 2) print(\"Point({}, {})\".format(c.x, c.y)) print(\"bool(c) : {}\".format(bool(c))) print(\"int(c) : {}\".format(int(c))) print(\"float(c) : {}\".format(float(c))) print(\"complex(c) : {}\".format(complex(c))) print(\"bytes(c) : {}\".format(bytes(c))) Dunder Context Manager # Dunder methods for context manager # --------------------------------------------------------------------------- # The __enter__ and __exit__ methods allow an object to define its own # setup and teardown logic when used in a with-statement. This example shows # how implementing these hooks customizes resource management behavior. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __enter__(self): print(\">>> Inside __enter__\") return self def __exit__(self, exc_type, exc_val, exc_tb): print(\">>> Inside __exit__\") print(\" Execution type:\", exc_type) print(\" Execution value:\", exc_val) print(\" Traceback:\", exc_tb) if exc_type is not None: print(\"\\nException occurred\") return True else: print(\"\\nNo exception occurred\") return False with Complex(1, 0) as c: print(\">>> Inside with block\") print(c.real, c.imag) print(c.real / 0) Dunder Customize Behavior # Dunder methods for customizing object behavior # --------------------------------------------------------------------------- # This script demonstrates several special methods that hook into object # creation, calling and destruction. Implementing these dunder methods lets a # class take control over how instances are created, invoked and cleaned up. class TestClass(object): def __init__(self): print(\"I'm initialized!\") self.name = \"DunderClass\" def __new__(cls, *args, **kwargs): print(\"I'm created!\") return super(TestClass, cls).__new__(cls) def __call__(self, *args, **kwargs): print(\"I'm called! My name is {}\".format(self.name)) def __del__(self): print(\"I'm deleted!\") # Create and initialize an instance of DunderClass test = TestClass() # Call the instance test() # Delete the instance del test Dunder Iterator Protocol # Dunder methods for the iterator protocol # --------------------------------------------------------------------------- # Special (dunder) methods allow objects to integrate with Python features. # By implementing __iter__ and __next__, this class customizes iteration # behavior so that instances work seamlessly in for-loops and other iterable # contexts. class Stack(object): def __init__(self): self._items = [] self._index = -1 def push(self, item): self._items.append(item) def pop(self): try: return self._items.pop() except IndexError: raise IndexError(\"Pop from an empty stack\") def __iter__(self): return self def __next__(self): try: next_item = self._items[self._index] self._index -= 1 return next_item except IndexError: raise StopIteration s = Stack() s.push(1) s.push(2) s.push(3) for item in s: print(item) Dunder Object Representation # Dunder methods for object representation # --------------------------------------------------------------------------- # Special representation methods like __repr__ and __str__ let objects control # how they are displayed. This example highlights how these hooks customize the # string and byte output of a class. import struct class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) def __repr__(self): return \"Point(x={}, y={})\".format(self.x, self.y) def __str__(self): return \"({}, {})\".format(self.x, self.y) def __format__(self, format_spec): fmt = \"({:\" + format_spec + \"} + {:\" + format_spec + \"})\" fmt = fmt.format(self.x, self.y) return fmt def __hash__(self): return hash((self.x, self.y)) def __bytes__(self): result = [] for item in (self.x, self.y): result.extend(struct.pack(\"!f\", item)) return bytes(result) p = Point(1, 2) print(hash(p)) print(repr(p)) print(str(p)) print(\"{:.3f}\".format(p)) print(bytes(p)) Dunder Operator Overloading # Dunder methods for operator overloading # --------------------------------------------------------------------------- # Overloading arithmetic operators with dunder methods allows custom classes # to behave like built-in numeric types. The following Point class defines # how instances react to +, -, * and other operations. class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) def __add__(self, other): return Point( x=self.x + other.x, y=self.y + other.y ) def __sub__(self, other): return Point( x=self.x - other.x, y=self.y - other.y ) def __mul__(self, other): return Point( x=self.x * other.x, y=self.y * other.y ) def __divmod__(self, other): return Point( x=self.x % other.x, y=self.y % other.y ) def __truediv__(self, other): return Point( x=self.x / other.x, y=self.y / other.y ) def __floordiv__(self, other): return Point( x=self.x // other.x, y=self.y // other.y ) a = Point(1, 2) b = Point(3, 4) z = a + b print(z.x, z.y) Snippets # Demonstration of special methods # --------------------------------------------------------------------------- # Various dunder methods show how objects integrate with Python features class DunderClass(object): def __init__(self): pass def __new__(cls, *args, **kwargs): pass def __call__(self, *args, **kwargs): pass # --------------------------------------------------------------------------------------------- # - Context manager # --------------------------------------------------------------------------------------------- def __enter__(self): pass def __exit__(self, exc_type, exc_val, exc_tb): pass # --------------------------------------------------------------------------------------------- # - Iterator protocol # --------------------------------------------------------------------------------------------- def __iter__(self): pass def __next__(self): pass # --------------------------------------------------------------------------------------------- # - Class decorators # --------------------------------------------------------------------------------------------- def __setattr__(self, key, value): pass def __delattr__(self, item): pass def __getattr__(self, item): pass # --------------------------------------------------------------------------------------------- # - Class representation # --------------------------------------------------------------------------------------------- def __str__(self): pass def __repr__(self): pass def __bytes__(self): pass def __sizeof__(self): pass # --------------------------------------------------------------------------------------------- # - Overload comparison operators # --------------------------------------------------------------------------------------------- def __eq__(self, other): pass def __gt__(self, other): pass def __ge__(self, other): pass def __lt__(self, other): pass def __le__(self, other): pass # --------------------------------------------------------------------------------------------- # - Overload arithmetic operators # --------------------------------------------------------------------------------------------- def __add__(self, other): pass def __sub__(self, other): pass def __mul__(self, other): pass def __divmod__(self, other): pass def __truediv__(self, other): pass def __floordiv__(self, other): pass","title":"Dunder Methods"},{"location":"examples/15_dunder_methods/#dunder-methods","text":"","title":"Dunder Methods"},{"location":"examples/15_dunder_methods/#demo-iterator","text":"# Dunder methods and iteration # --------------------------------------------------------------------------- # Demonstrates how special methods customize iteration behavior. # * An iterable implements __iter__ returning an iterator. # * An iterator implements __iter__ returning itself and __next__ returning # the next element. # https://www.pythontutorial.net/advanced-python/python-iterator-vs-iterable/ ################################################################################################## # ITERABLE CLASS ################################################################################################## class Colors(object): def __init__(self): self.rgb = ['red', 'green', 'blue'] def __iter__(self): return ColorIterator(self) ################################################################################################## # ITERATOR CLASS ################################################################################################## class ColorIterator(object): def __init__(self, colors): self.__colors = colors self.__index = 0 def __iter__(self): return self def __next__(self): self.next() def next(self): try: color = self.__colors.rgb[self.__index] self.__index += 1 except IndexError: raise StopIteration return color ################################################################################################## # DEMO ################################################################################################## c = Colors() print(c) c_iter = iter(c) print(c_iter) for element in c: print(element)","title":"Demo Iterator"},{"location":"examples/15_dunder_methods/#dunder-arithmetic-operators","text":"# Dunder methods for arithmetic operators # --------------------------------------------------------------------------- # By defining special arithmetic methods, objects can participate in Python's # numeric operations. These dunder hooks let a class customize how instances # respond to +, -, *, and other operators. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __add__(self, other): return Complex( real=self.real + other.real, imag=self.imag + other.imag ) def __sub__(self, other): return Complex( real=self.real - other.real, imag=self.imag - other.imag ) def __mul__(self, other): return Complex( real=self.real * other.real, imag=self.imag * other.imag ) def __divmod__(self, other): return Complex( real=self.real % other.real, imag=self.imag % other.imag ) def __truediv__(self, other): return Complex( real=self.real / other.real, imag=self.imag / other.imag ) def __floordiv__(self, other): return Complex( real=self.real // other.real, imag=self.imag // other.imag ) a = Complex(1, 2) b = Complex(3, 4) z = a + b print(z.real, z.imag)","title":"Dunder Arithmetic Operators"},{"location":"examples/15_dunder_methods/#dunder-attributes","text":"# Dunder methods for attribute access # --------------------------------------------------------------------------- # Attribute related dunder methods such as __getattr__, __setattr__ and # __delattr__ give objects dynamic control over attribute access. They enable # customized lookup, assignment and deletion behavior. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __setattr__(self, key, value): print(\"Setting attribute: {} = {}\".format(key, value)) def __delattr__(self, item): print(\"Deleting attribute: {}\".format(item)) def __getattr__(self, item): print(\"Getting attribute: {}\".format(item)) return item z = Complex(1, 2) setattr(z, \"real\", 3) delattr(z, \"real\") print(getattr(z, \"real\"))","title":"Dunder Attributes"},{"location":"examples/15_dunder_methods/#dunder-builtin-types","text":"# Dunder methods for object representation # --------------------------------------------------------------------------- # Built-in type conversion functions like bool(), int() and bytes() call # corresponding dunder methods on objects. Implementing these hooks lets a # class define how it converts to fundamental Python types. import struct import math class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) self.__length = self._calc_length() def _calc_length(self): return math.sqrt(self.x ** 2 + self.y ** 2) def __bool__(self): return bool(self.x or self.y) def __int__(self): return int(self._calc_length()) def __float__(self): return float(self._calc_length()) def __complex__(self): return complex(self.x, self.y) def __bytes__(self): return bytes(int(self.__length)) c = Point(1, 2) print(\"Point({}, {})\".format(c.x, c.y)) print(\"bool(c) : {}\".format(bool(c))) print(\"int(c) : {}\".format(int(c))) print(\"float(c) : {}\".format(float(c))) print(\"complex(c) : {}\".format(complex(c))) print(\"bytes(c) : {}\".format(bytes(c)))","title":"Dunder Builtin Types"},{"location":"examples/15_dunder_methods/#dunder-context-manager","text":"# Dunder methods for context manager # --------------------------------------------------------------------------- # The __enter__ and __exit__ methods allow an object to define its own # setup and teardown logic when used in a with-statement. This example shows # how implementing these hooks customizes resource management behavior. class Complex(object): def __init__(self, real, imag): self.real = float(real) self.imag = float(imag) def __enter__(self): print(\">>> Inside __enter__\") return self def __exit__(self, exc_type, exc_val, exc_tb): print(\">>> Inside __exit__\") print(\" Execution type:\", exc_type) print(\" Execution value:\", exc_val) print(\" Traceback:\", exc_tb) if exc_type is not None: print(\"\\nException occurred\") return True else: print(\"\\nNo exception occurred\") return False with Complex(1, 0) as c: print(\">>> Inside with block\") print(c.real, c.imag) print(c.real / 0)","title":"Dunder Context Manager"},{"location":"examples/15_dunder_methods/#dunder-customize-behavior","text":"# Dunder methods for customizing object behavior # --------------------------------------------------------------------------- # This script demonstrates several special methods that hook into object # creation, calling and destruction. Implementing these dunder methods lets a # class take control over how instances are created, invoked and cleaned up. class TestClass(object): def __init__(self): print(\"I'm initialized!\") self.name = \"DunderClass\" def __new__(cls, *args, **kwargs): print(\"I'm created!\") return super(TestClass, cls).__new__(cls) def __call__(self, *args, **kwargs): print(\"I'm called! My name is {}\".format(self.name)) def __del__(self): print(\"I'm deleted!\") # Create and initialize an instance of DunderClass test = TestClass() # Call the instance test() # Delete the instance del test","title":"Dunder Customize Behavior"},{"location":"examples/15_dunder_methods/#dunder-iterator-protocol","text":"# Dunder methods for the iterator protocol # --------------------------------------------------------------------------- # Special (dunder) methods allow objects to integrate with Python features. # By implementing __iter__ and __next__, this class customizes iteration # behavior so that instances work seamlessly in for-loops and other iterable # contexts. class Stack(object): def __init__(self): self._items = [] self._index = -1 def push(self, item): self._items.append(item) def pop(self): try: return self._items.pop() except IndexError: raise IndexError(\"Pop from an empty stack\") def __iter__(self): return self def __next__(self): try: next_item = self._items[self._index] self._index -= 1 return next_item except IndexError: raise StopIteration s = Stack() s.push(1) s.push(2) s.push(3) for item in s: print(item)","title":"Dunder Iterator Protocol"},{"location":"examples/15_dunder_methods/#dunder-object-representation","text":"# Dunder methods for object representation # --------------------------------------------------------------------------- # Special representation methods like __repr__ and __str__ let objects control # how they are displayed. This example highlights how these hooks customize the # string and byte output of a class. import struct class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) def __repr__(self): return \"Point(x={}, y={})\".format(self.x, self.y) def __str__(self): return \"({}, {})\".format(self.x, self.y) def __format__(self, format_spec): fmt = \"({:\" + format_spec + \"} + {:\" + format_spec + \"})\" fmt = fmt.format(self.x, self.y) return fmt def __hash__(self): return hash((self.x, self.y)) def __bytes__(self): result = [] for item in (self.x, self.y): result.extend(struct.pack(\"!f\", item)) return bytes(result) p = Point(1, 2) print(hash(p)) print(repr(p)) print(str(p)) print(\"{:.3f}\".format(p)) print(bytes(p))","title":"Dunder Object Representation"},{"location":"examples/15_dunder_methods/#dunder-operator-overloading","text":"# Dunder methods for operator overloading # --------------------------------------------------------------------------- # Overloading arithmetic operators with dunder methods allows custom classes # to behave like built-in numeric types. The following Point class defines # how instances react to +, -, * and other operations. class Point(object): def __init__(self, x, y): self.x = float(x) self.y = float(y) def __add__(self, other): return Point( x=self.x + other.x, y=self.y + other.y ) def __sub__(self, other): return Point( x=self.x - other.x, y=self.y - other.y ) def __mul__(self, other): return Point( x=self.x * other.x, y=self.y * other.y ) def __divmod__(self, other): return Point( x=self.x % other.x, y=self.y % other.y ) def __truediv__(self, other): return Point( x=self.x / other.x, y=self.y / other.y ) def __floordiv__(self, other): return Point( x=self.x // other.x, y=self.y // other.y ) a = Point(1, 2) b = Point(3, 4) z = a + b print(z.x, z.y)","title":"Dunder Operator Overloading"},{"location":"examples/15_dunder_methods/#snippets","text":"# Demonstration of special methods # --------------------------------------------------------------------------- # Various dunder methods show how objects integrate with Python features class DunderClass(object): def __init__(self): pass def __new__(cls, *args, **kwargs): pass def __call__(self, *args, **kwargs): pass # --------------------------------------------------------------------------------------------- # - Context manager # --------------------------------------------------------------------------------------------- def __enter__(self): pass def __exit__(self, exc_type, exc_val, exc_tb): pass # --------------------------------------------------------------------------------------------- # - Iterator protocol # --------------------------------------------------------------------------------------------- def __iter__(self): pass def __next__(self): pass # --------------------------------------------------------------------------------------------- # - Class decorators # --------------------------------------------------------------------------------------------- def __setattr__(self, key, value): pass def __delattr__(self, item): pass def __getattr__(self, item): pass # --------------------------------------------------------------------------------------------- # - Class representation # --------------------------------------------------------------------------------------------- def __str__(self): pass def __repr__(self): pass def __bytes__(self): pass def __sizeof__(self): pass # --------------------------------------------------------------------------------------------- # - Overload comparison operators # --------------------------------------------------------------------------------------------- def __eq__(self, other): pass def __gt__(self, other): pass def __ge__(self, other): pass def __lt__(self, other): pass def __le__(self, other): pass # --------------------------------------------------------------------------------------------- # - Overload arithmetic operators # --------------------------------------------------------------------------------------------- def __add__(self, other): pass def __sub__(self, other): pass def __mul__(self, other): pass def __divmod__(self, other): pass def __truediv__(self, other): pass def __floordiv__(self, other): pass","title":"Snippets"},{"location":"examples/16_data_types/","text":"Data Types Comprehension Dictionary # Dictionary comprehensions # ----------------------------------------------------------------------------- # Dictionary comprehensions let you construct mappings concisely. They are ideal for transforming one form of data into key/value pairs. existing_list = [1, 2, 3, 4, 5] existing_dictionary = {1: \"junior\", 2: \"mid\", 3: \"c\", 4: \"d\", 5: \"e\"} # Dictionary comprehension with list new_dictionary_1 = {number: number**2 for number in existing_list} # Dictionary comprehension with existing dictionary new_dictionary_2 = {key: \"_\"+value+\"_\" for (key, value) in existing_dictionary.items()} # Dictionary comprehension with existing dictionary and conditions new_dictionary_3 = {key: \"_\"+value+\"_\" for (key, value) in existing_dictionary.items() if key < 5 if value != \"mid\"} print(new_dictionary_1) print(new_dictionary_2) print(new_dictionary_3) Comprehension List # List comprehensions # ----------------------------------------------------------------------------- # List comprehensions allow you to create or filter lists concisely without explicit loops. existing_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # List comprehension without condition new_list_1 = [number**2 for number in existing_list] # List comprehension with condition new_list_2 = [number**2 for number in existing_list if number < 6] print(new_list_1) print(new_list_2) Data Array # Efficient arrays # ----------------------------------------------------------------------------- # The array module stores numeric values more efficiently than lists because all elements share the same type. import array def test_int(): # Create an array of integers int_array = array.array('i', [1, 2, 3, 4, 5]) # Convert the array to a bytes object (useful for binary data) bytes_data = int_array.tobytes() print(bytes_data) # Convert a bytes object back to an array new_array = array.array('i') new_array.frombytes(bytes_data) print(new_array) print() def test_unicode(): # Use unicode characters unicode_array = array.array('u', \"\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!\") # Convert the array to a bytes object (useful for binary data) bytes_data = unicode_array.tobytes() print(bytes_data) # Convert a bytes object back to an array new_array = array.array('u') new_array.frombytes(bytes_data) print(new_array) print() if __name__ == \"__main__\": test_int() test_unicode() Data Base64 # Base64 encoding # ----------------------------------------------------------------------------- # Base64 converts binary data to ASCII text. This is handy when transmitting bytes over text-based protocols. import base64 # Convert the string to bytes text_expected = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_expected.encode('utf-8') # Encode the byte stream in Base64 encoded = base64.b64encode(text_stream) print(encoded) # Decode the byte stream from Base64 decoded = base64.b64decode(encoded) # Print the decoded string text_obtained = decoded.decode('utf-8') print(text_obtained) # Assert that the expected and obtained strings are equal assert text_expected == text_obtained Data Binascii # Binary-to-ASCII conversions # ----------------------------------------------------------------------------- # The binascii module exposes low-level routines for converting between binary data and various ASCII encodings. import binascii def test_base64(): print(\"Test Base64\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in Base64 encoded = binascii.b2a_base64(text_stream) print(encoded) # Decode the byte stream from Base64 decoded = binascii.a2b_base64(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() def test_hex(): print(\"Test Hex\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in hexadecimal encoded = binascii.b2a_hex(text_stream) print(encoded) # Decode the byte stream from hexadecimal decoded = binascii.a2b_hex(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() def test_uu(): print(\"Test UUEncode\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in uuencode encoded = binascii.b2a_uu(text_stream) print(encoded) # Decode the byte stream from uuencode decoded = binascii.a2b_uu(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() if __name__ == \"__main__\": test_base64() test_hex() test_uu() Data Chainmap # Combining dictionaries with ChainMap # ----------------------------------------------------------------------------- # ChainMap lets you combine several dictionaries into a single view without copying them. from collections import ChainMap # Create two dictionaries dict1 = {'junior': 1, 'mid': 2} dict2 = {'c': 3, 'd': 4} # Create a ChainMap chain = ChainMap(dict1, dict2) # Print the ChainMap print(chain) # Print elements print(list(chain.items())) # Find value of a key from dict1 print(chain['a']) # Find value of a key from dict2 print(chain['c']) Data Codecs # Encoding text with codecs # ----------------------------------------------------------------------------- # The codecs module provides tools for encoding and decoding streams of text in different character sets. import codecs import pprint def test_utf8(): print(\"Test UTF-8\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text, 'utf-8') print(encoded) decoded = codecs.decode(encoded, 'utf-8') print(decoded) info = codecs.lookup('utf-8') print(\"lookup() -> \", info) print() def test_utf16(): print(\"Test UTF-16\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text, 'utf-16') print(encoded) decoded = codecs.decode(encoded, 'utf-16') print(decoded) info = codecs.lookup('utf-16') print(\"lookup() -> \", info) print() def test_base64(): print(\"Test Base64\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text.encode('utf-8'), 'base64') print(encoded) decoded = codecs.decode(encoded, 'base64') print(decoded.decode('utf-8')) info = codecs.lookup('base64') print(\"lookup() -> \", info) print() if __name__ == \"__main__\": test_utf8() test_utf16() test_base64() Data Codecs Custom # Custom codecs # ----------------------------------------------------------------------------- # Registering a custom codec allows you to handle data stored in a specialized encoding. import codecs class ROT13Codec(codecs.Codec): # ROT13 Cipher - see https://en.wikipedia.org/wiki/ROT13 def encode(self, stream, errors='strict'): # Result is a list of characters encoded = [] # Iterate over the input stream for char in stream: # Encode lower case letters if 'a' <= char <= 'z': offset = ord('a') encoded_char = chr(((ord(char) - offset + 13) % 26) + offset) # Encode upper case letters elif 'A' <= char <= 'Z': offset = ord('A') encoded_char = chr(((ord(char) - offset + 13) % 26) + offset) # Other characters are not encoded else: encoded_char = char # Append encoded character to the resulting list encoded.append(encoded_char) # Return the encoded bytes and the length of the input stream return ''.join(encoded), len(stream) def decode(self, stream, errors='strict'): # ROT13 is its own inverse return self.encode(stream, errors) def lookup(self, encoding): if encoding == 'rot13': codec = codecs.CodecInfo( name='rot13', encode=self.encode, decode=self.decode, ) else: codec = None return codec # Register the codec with the codecs module before using it codecs.register(ROT13Codec().lookup) # Usage encoded_text = codecs.encode(\"Hello, World!\", encoding='rot13') print(encoded_text) # Output: \"Uryyb, Jbeyq!\" decoded_text = codecs.decode(encoded_text, encoding='rot13') print(decoded_text) # Output: \"Hello, World!\" Data Copying # Deep and shallow copying # ----------------------------------------------------------------------------- # Shallow and deep copying let you duplicate complex objects without affecting the originals. import copy # Create a deeply nested dictionary numbers_dict = { \"numbers\": { \"integers\": [1, 2, 3, 4, 5], \"floats\": [1.1, 2.2, 3.3, 4.4, 5.5] } } # Create a shallow copy of the dictionary shallow_copy = copy.copy(numbers_dict) # Create a deep copy of the dictionary deep_copy = copy.deepcopy(numbers_dict) # Modify the original dictionary numbers_dict[\"numbers\"][\"integers\"].append(6) numbers_dict[\"numbers\"][\"floats\"].append(6.6) # Print the original dictionary (modified) print(\"Original\", numbers_dict) # Print the shallow copy (modified) print(\"Shallow\", shallow_copy) # Print the deep copy (not modified) print(\"Deep\", deep_copy) Data Counter Class # Counting with Counter # ----------------------------------------------------------------------------- # A Counter is a dictionary subclass for tallying hashable objects quickly. from collections import Counter # Create a Counter object a = Counter('abcdeabcdabcaba') b = Counter(reversed(\"abcdeabcdabcaba\")) # Print the Counter object print(a) print(b) # Print the three most common element print(a.most_common(3)) print(b.most_common(3)) # Add two Counter objects c = a + b print(c) # Subtract two Counter objects d = a - b print(d) Data Dataclass # Lightweight data classes # ----------------------------------------------------------------------------- # Dataclasses eliminate boilerplate when defining classes meant primarily to store data. import dataclasses from dataclasses import dataclass, field from typing import List @dataclass class DataClass(object): name: str value: int def __post_init__(self): self.value = self.value * 2 def __str__(self): return f\"{self.name}: {self.value}\" @dataclass class DataClassWithDefaults(DataClass): name: str = \"MyData with defaults\" value: int = 0 data: List[int] = field(default_factory=list) def add_value(self, value): self.data.append(value) def __str__(self): return f\"{self.name}: {self.value}, {self.data}\" if __name__ == \"__main__\": my_data = DataClass(name=\"MyData\", value=10) print(my_data) my_data = DataClassWithDefaults() my_data.add_value(1) print(my_data) Data Defaultdict # Automatic keys with defaultdict # ----------------------------------------------------------------------------- # defaultdict automatically creates missing keys so your code doesn't need explicit checks. from collections import defaultdict def test_default_factory(factory): d = defaultdict(factory) # Test the defaultdict try: print(d['key1']) print(d['key2']) print(d['key3']) except KeyError as e: print(\"KeyError: {}\".format(e)) assert True print() if __name__ == \"__main__\": default_factories = [ None, # Behaves like a regular dictionary str, # Returns an empty string if the key is not found int, # Returns 0 if the key is not found float, # Returns 0.0 if the key is not found list, # Returns an empty list if the key is not found tuple, # Returns an empty tuple if the key is not found dict, # Returns an empty dictionary if the key is not found set, # Returns an empty set if the key is not found lambda: 'value', # Returns a default value if the key is not found ] for default_factory in default_factories: test_default_factory(default_factory) Data Deque Fifo # Deque as FIFO queue # ----------------------------------------------------------------------------- # Deque offers fast O(1) operations at both ends, making it ideal for implementing queues. from collections import deque def emtpy_deque(customers): # Test the deque while True: try: # Get the item from the right item = customers.pop() print(\"Get item: {}\".format(item)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_deque(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.appendleft(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a deque d = deque() # Fill the deque fill_deque(d) # Empty the deque emtpy_deque(d) Data Deque Lifo # Deque as LIFO stack # ----------------------------------------------------------------------------- # Using deque as a stack provides efficient push and pop operations. from collections import deque def emtpy_deque(plates): # Test the deque while True: try: # Get the item from the right item = plates.pop() print(\"Get item: {}\".format(item)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_deque(plates): items = ['Soup plate', 'Salad plate', 'Dinner plate', 'Dessert plate'] for item in items: plates.append(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a deque d = deque() # Fill the deque fill_deque(d) # Empty the deque emtpy_deque(d) Data Dill # Serializing with dill # ----------------------------------------------------------------------------- # dill extends pickle and can serialize a wider range of Python objects. import dill import sys class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Print the book object print(book.__dict__) # Serialize the book object serialized_book = dill.dumps(book) # Print the size of the serialized object print('Size of the serialized object: {} bytes'.format(sys.getsizeof(serialized_book))) # Print the serialized object print(serialized_book) # Deserialize the book object deserialized_book = dill.loads(serialized_book) # Print the book object print(deserialized_book.__dict__) Data Filtering # Filtering with filter() # ----------------------------------------------------------------------------- # The built-in filter() returns elements for which a function returns True. def is_even(x): return x % 2 == 0 # Sample data sample = [1, 2, 3, 4, 5, 6, 7, 8, 9] # Filter using a filtering function (first) and an iterable (second) iterator = filter(is_even, sample) print(list(iterator)) # Filter using a lambda function (first) and an iterable (second) iterator = filter(lambda x: x % 2 == 0, sample) print(list(iterator)) Data Heapq # heapq priority queue # ----------------------------------------------------------------------------- # A heap lets you maintain a priority queue with O(log n) push/pop operations. import heapq def empty_heapq(h): # Test the heapq while True: try: print(heapq.heappop(h)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_heapq(h): # Add items to the heapq heapq.heappush(h, 4) heapq.heappush(h, 1) heapq.heappush(h, 7) if __name__ == \"__main__\": # Create a heapq heap = [] heapq.heapify(heap) # Fill the heapq fill_heapq(heap) # Empty the heapq empty_heapq(heap) Data Mapping # Mapping with map() # ----------------------------------------------------------------------------- # map() applies a function to every element of an iterable, returning the results. def sqr(x): return x * x # Sample data sample = [1, 2, 3, 4, 5, 6, 7, 8, 9] # Map using a mapping function (first) and an iterable (second) iterator = map(sqr, sample) print(list(iterator)) # Map using a lambda function (first) and an iterable (second) iterator = map(lambda x: x * x, sample) print(list(iterator)) Data Namedtuple # Named tuples # ----------------------------------------------------------------------------- # namedtuples give tuple-like objects readable field names without extra overhead. from collections import namedtuple # Create a namedtuple (label, fields) # - The label will be used in the representation of the namedtuple # - The fields will be used to access the namedtuple attributes Point = namedtuple('Point', ['x', 'y']) p = Point(1, 2) # Test the namedtuple representation print(p) # Test the namedtuple attributes print(p.x) print(p.y) # Test the namedtuple index access print(p[0]) print(p[1]) Data Ordered Dict # Ordered dictionaries # ----------------------------------------------------------------------------- # OrderedDict remembers the insertion order of keys, which can be useful for reproducible iteration. from collections import OrderedDict # Create an OrderedDict od = OrderedDict() # Add elements od['a'] = 1 od['b'] = 2 od['c'] = 3 od['d'] = 4 # Print the OrderedDict print(od) # Move 'c' to the end od.move_to_end('c') # Print the OrderedDict print(od) # Move 'c' to the start od.move_to_end('c', last=False) # Print the OrderedDict print(od) Data Packing # Packing *args and **kwargs # ----------------------------------------------------------------------------- # Packing arguments allows functions to accept an arbitrary number of positional or keyword parameters. def func1(*args): # args is a tuple of arguments (packed) print(sum(args)) # Unpack the tuple into individual arguments print(*args) func1(1, 2, 3, 4) Data Pickle # Object serialization with pickle # ----------------------------------------------------------------------------- # pickle serializes and deserializes Python objects so they can be saved and restored later. import pickle import sys class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Print the book object print(book.__dict__) # Serialize the book object serialized_book = pickle.dumps(book) # Print the size of the serialized object print('Size of the serialized object: {} bytes'.format(sys.getsizeof(serialized_book))) # Print the serialized object print(serialized_book) # Deserialize the book object deserialized_book = pickle.loads(serialized_book) # Print the book object print(deserialized_book.__dict__) Data Queue Fifo # FIFO queue with Queue # ----------------------------------------------------------------------------- # queue.Queue provides a thread-safe FIFO structure for coordinating producer/consumer workloads. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: item = customers.get(block=False) print(\"Get item: {}\".format(item)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.put(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a FIFO queue d = queue.Queue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d) Data Queue Lifo # LIFO queue with LifoQueue # ----------------------------------------------------------------------------- # LifoQueue behaves like a stack while remaining safe for use with multiple threads. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: item = customers.get(block=False) print(\"Get item: {}\".format(item)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.put(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a LIFO queue d = queue.LifoQueue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d) Data Queue Priority # Priority queues # ----------------------------------------------------------------------------- # PriorityQueue orders tasks by priority, letting the smallest value be retrieved first. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: priority, item = customers.get(block=False) print(\"Get {:8} : priority {:5}\".format(item, priority)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): priorities = [3, 1, 2, 4] items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for priority, item in zip(priorities, items): priority = int(priority) customers.put((priority, item)) print(\"Add {:8} : priority {:5}\".format(item, priority)) print() if __name__ == \"__main__\": # Create a FIFO queue d = queue.PriorityQueue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d) Data Reducing # Aggregating with reduce() # ----------------------------------------------------------------------------- # reduce() repeatedly applies a function to items, collapsing them into a single result. from functools import reduce def total(x, y): return x + y # Sample data sample = [1, 1, 1] # Map using a mapping function (first) and an iterable (second) value = reduce(total, sample) print(value) # Map using a lambda function (first) and an iterable (second) iterator = reduce(lambda x, y: x + y, sample) print(value) Data Reversing # Reverse iteration # ----------------------------------------------------------------------------- # The reversed() built-in returns an iterator that yields items from the end to the start. # Sample data sample_1 = [1, 2, 5, 4, 3] sample_2 = {1: 'a', 2: 'b', 5: 'd', 4: 'c', 3: 'e'} # Reverse a list iterator = reversed(sample_1) print(list(iterator)) # Reverse a dictionary iterator = reversed(sample_2.items()) print(list(iterator)) Data Sorting # Sorting with sorted() # ----------------------------------------------------------------------------- # sorted() creates a new sorted list from any iterable, optionally using a key function. class Book(object): def __init__(self, title, author, year): self.title = title self.author = author self.year = year def __repr__(self): return \"Book({title}, {author}, {year})\".format( title=self.title, author=self.author, year=self.year) # List of books books = [ Book('The Great Gatsby', 'F. Scott Fitzgerald', 1925), Book('To Kill a Mockingbird', 'Harper Lee', 1960), Book('1984', 'George Orwell', 1949), Book('Brave New World', 'Aldous Huxley', 1932), Book('The Catcher in the Rye', 'J.D. Salinger', 1951), ] # Sort the list of dictionaries based on the 'year' key in each dictionary sorted_books = sorted(books, key=lambda book: book.year) # Print the sorted list for b in sorted_books: print(b) Data Struct # Working with struct # ----------------------------------------------------------------------------- # The struct module packs and unpacks binary data to interact with C-style structs. import struct class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Define the byte stream format (32s = 32 characters, f = float, i = integer), big-endian (>) serialized = struct.pack('>32s 32s f i', book.title.encode('utf-8'), book.author.encode('utf-8'), book.price, book.year ) # Print the size of the serialized object (32 + 32 + 4 + 4 = 72 bytes) print('Size of the serialized object: {} bytes'.format(struct.calcsize('32s 32s f i'))) # Print the binary stream (72 bytes) print(serialized) # Deserialize the data title, author, price, year = struct.unpack('32s 32s f i', serialized) print(title.decode('utf-8').strip('\\x00')) print(author.decode('utf-8').strip('\\x00')) print(price) print(year) Data Struct With Buffer # Struct packing into buffers # ----------------------------------------------------------------------------- # Packing directly into an existing buffer lets you build binary data without intermediate strings. import struct class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Define the byte stream format (32s = 32 characters, f = float, i = integer), big-endian (>) format_string = '>32s 32s f i' # Create the buffer buffer_size = struct.calcsize(format_string) buffer = bytearray(buffer_size) # Pack the data into the buffer serialized = struct.pack(format_string, book.title.encode('utf-8'), book.author.encode('utf-8'), book.price, book.year ) # Print the size of the serialized object (32 + 32 + 4 + 4 = 72 bytes) print('Size of the serialized object: {} bytes'.format(struct.calcsize('32s 32s f i'))) # Print the binary stream (72 bytes) print(serialized) # Deserialize the data title, author, price, year = struct.unpack_from(format_string, serialized) print(title.decode('utf-8').strip('\\x00')) print(author.decode('utf-8').strip('\\x00')) print(price) print(year) Data Unpacking # Argument unpacking # ----------------------------------------------------------------------------- # Unpacking with * and ** lets you pass iterables or mappings as arguments in a clean syntax. # A list of arguments pos_args = [1, 2, 3, 4] keyword_args = {'a': 1, 'b': 2, 'c': 3, 'd': 4} # A sample function that takes 4 arguments # and prints the, def func1(a, b, c, d): print(a, b, c, d) # Variable number of arguments def func2(a, b, c, d, *args): print(a + b + c + d + sum(args)) # Variable number of keyword arguments def func3(**kwargs): print(kwargs['a'] + kwargs['b'] + kwargs['c'] + kwargs['d']) func1(*pos_args) func2(*pos_args) func3(**keyword_args) test = \"PYTHON\" unpacked = [*test] print(unpacked) Data Zipping # Pairing items with zip() # ----------------------------------------------------------------------------- # zip() pairs elements from multiple iterables so you can iterate over them in lockstep. # Sample data numbers = [1, 2, 3] letters = ['a', 'b', 'c'] # Zip two lists zipped = zip(numbers, letters) zipped_list = list(zipped) print(zipped_list) # Unzip into two lists unzipped = zip(*zipped_list) numbers, letters = map(list, unzipped) print(numbers) print(letters) Unpack Dict # Dictionary unpacking # ----------------------------------------------------------------------------- # The * operator can expand a mapping's items into function arguments or into new dictionaries. \"\"\" https://realpython.com/python-kwargs-and-args/#unpacking-with-the-asterisk-operators \"\"\" test = {\"a\": 1, \"b\": 2, \"c\": 3} print(test) # Unpack dictionary print(*test) print(*test.keys()) print(*test.values()) print(*test.items()) # Unpack first element and then the rest a, *b = test.items() print(a, b) # Merge two lists first = {\"A\": 1, \"B\": 2} second = {\"C\": 3, \"D\": 4} merged = {**first, **second} print(merged) Unpack List # List unpacking # ----------------------------------------------------------------------------- # Using * with a list expands its items when calling a function. \"\"\" https://realpython.com/python-kwargs-and-args/#unpacking-with-the-asterisk-operators \"\"\" test = [1, 2, 3] print(test) # Unpack list and print uses elements as arguments print(*test) # Unpack first element and then the rest a, *b = test print(a, b) # Merge two lists first = [1, 2, 3] second = [4, 5, 6] merged = [*first, *second] print(merged) Unpack Snippets # Unpacking snippets # ----------------------------------------------------------------------------- # These small examples show how the * operator can gather or scatter items from sequences. test_string = \"PYTHON\" test_list = [1, 2, 3, 4] test_dict = {\"A\": 1, \"B\": 2} # Unpack string *test, = test_string print(test) # Unpack list *test, = test_list print(test) # Unpack dictionary items *test, = test_dict.items() print(test) # Copy dictionary test = {**test_dict} print(test) print(test is test_dict)","title":"Data Types"},{"location":"examples/16_data_types/#data-types","text":"","title":"Data Types"},{"location":"examples/16_data_types/#comprehension-dictionary","text":"# Dictionary comprehensions # ----------------------------------------------------------------------------- # Dictionary comprehensions let you construct mappings concisely. They are ideal for transforming one form of data into key/value pairs. existing_list = [1, 2, 3, 4, 5] existing_dictionary = {1: \"junior\", 2: \"mid\", 3: \"c\", 4: \"d\", 5: \"e\"} # Dictionary comprehension with list new_dictionary_1 = {number: number**2 for number in existing_list} # Dictionary comprehension with existing dictionary new_dictionary_2 = {key: \"_\"+value+\"_\" for (key, value) in existing_dictionary.items()} # Dictionary comprehension with existing dictionary and conditions new_dictionary_3 = {key: \"_\"+value+\"_\" for (key, value) in existing_dictionary.items() if key < 5 if value != \"mid\"} print(new_dictionary_1) print(new_dictionary_2) print(new_dictionary_3)","title":"Comprehension Dictionary"},{"location":"examples/16_data_types/#comprehension-list","text":"# List comprehensions # ----------------------------------------------------------------------------- # List comprehensions allow you to create or filter lists concisely without explicit loops. existing_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # List comprehension without condition new_list_1 = [number**2 for number in existing_list] # List comprehension with condition new_list_2 = [number**2 for number in existing_list if number < 6] print(new_list_1) print(new_list_2)","title":"Comprehension List"},{"location":"examples/16_data_types/#data-array","text":"# Efficient arrays # ----------------------------------------------------------------------------- # The array module stores numeric values more efficiently than lists because all elements share the same type. import array def test_int(): # Create an array of integers int_array = array.array('i', [1, 2, 3, 4, 5]) # Convert the array to a bytes object (useful for binary data) bytes_data = int_array.tobytes() print(bytes_data) # Convert a bytes object back to an array new_array = array.array('i') new_array.frombytes(bytes_data) print(new_array) print() def test_unicode(): # Use unicode characters unicode_array = array.array('u', \"\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!\") # Convert the array to a bytes object (useful for binary data) bytes_data = unicode_array.tobytes() print(bytes_data) # Convert a bytes object back to an array new_array = array.array('u') new_array.frombytes(bytes_data) print(new_array) print() if __name__ == \"__main__\": test_int() test_unicode()","title":"Data Array"},{"location":"examples/16_data_types/#data-base64","text":"# Base64 encoding # ----------------------------------------------------------------------------- # Base64 converts binary data to ASCII text. This is handy when transmitting bytes over text-based protocols. import base64 # Convert the string to bytes text_expected = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_expected.encode('utf-8') # Encode the byte stream in Base64 encoded = base64.b64encode(text_stream) print(encoded) # Decode the byte stream from Base64 decoded = base64.b64decode(encoded) # Print the decoded string text_obtained = decoded.decode('utf-8') print(text_obtained) # Assert that the expected and obtained strings are equal assert text_expected == text_obtained","title":"Data Base64"},{"location":"examples/16_data_types/#data-binascii","text":"# Binary-to-ASCII conversions # ----------------------------------------------------------------------------- # The binascii module exposes low-level routines for converting between binary data and various ASCII encodings. import binascii def test_base64(): print(\"Test Base64\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in Base64 encoded = binascii.b2a_base64(text_stream) print(encoded) # Decode the byte stream from Base64 decoded = binascii.a2b_base64(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() def test_hex(): print(\"Test Hex\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in hexadecimal encoded = binascii.b2a_hex(text_stream) print(encoded) # Decode the byte stream from hexadecimal decoded = binascii.a2b_hex(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() def test_uu(): print(\"Test UUEncode\") # Convert the string to bytes text_out = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' text_stream = text_out.encode('utf-8') print(text_out) # Encode the byte stream in uuencode encoded = binascii.b2a_uu(text_stream) print(encoded) # Decode the byte stream from uuencode decoded = binascii.a2b_uu(encoded) print(decoded) # Print the decoded string text_in = decoded.decode('utf-8') print(text_in) # Assert that the expected and obtained strings are equal assert text_in == text_out print() if __name__ == \"__main__\": test_base64() test_hex() test_uu()","title":"Data Binascii"},{"location":"examples/16_data_types/#data-chainmap","text":"# Combining dictionaries with ChainMap # ----------------------------------------------------------------------------- # ChainMap lets you combine several dictionaries into a single view without copying them. from collections import ChainMap # Create two dictionaries dict1 = {'junior': 1, 'mid': 2} dict2 = {'c': 3, 'd': 4} # Create a ChainMap chain = ChainMap(dict1, dict2) # Print the ChainMap print(chain) # Print elements print(list(chain.items())) # Find value of a key from dict1 print(chain['a']) # Find value of a key from dict2 print(chain['c'])","title":"Data Chainmap"},{"location":"examples/16_data_types/#data-codecs","text":"# Encoding text with codecs # ----------------------------------------------------------------------------- # The codecs module provides tools for encoding and decoding streams of text in different character sets. import codecs import pprint def test_utf8(): print(\"Test UTF-8\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text, 'utf-8') print(encoded) decoded = codecs.decode(encoded, 'utf-8') print(decoded) info = codecs.lookup('utf-8') print(\"lookup() -> \", info) print() def test_utf16(): print(\"Test UTF-16\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text, 'utf-16') print(encoded) decoded = codecs.decode(encoded, 'utf-16') print(decoded) info = codecs.lookup('utf-16') print(\"lookup() -> \", info) print() def test_base64(): print(\"Test Base64\") text = '\u0417\u0434\u0440\u0430\u0432\u0435\u0439\u0442\u0435, \u0445\u043e\u0440\u0430!' print(text) encoded = codecs.encode(text.encode('utf-8'), 'base64') print(encoded) decoded = codecs.decode(encoded, 'base64') print(decoded.decode('utf-8')) info = codecs.lookup('base64') print(\"lookup() -> \", info) print() if __name__ == \"__main__\": test_utf8() test_utf16() test_base64()","title":"Data Codecs"},{"location":"examples/16_data_types/#data-codecs-custom","text":"# Custom codecs # ----------------------------------------------------------------------------- # Registering a custom codec allows you to handle data stored in a specialized encoding. import codecs class ROT13Codec(codecs.Codec): # ROT13 Cipher - see https://en.wikipedia.org/wiki/ROT13 def encode(self, stream, errors='strict'): # Result is a list of characters encoded = [] # Iterate over the input stream for char in stream: # Encode lower case letters if 'a' <= char <= 'z': offset = ord('a') encoded_char = chr(((ord(char) - offset + 13) % 26) + offset) # Encode upper case letters elif 'A' <= char <= 'Z': offset = ord('A') encoded_char = chr(((ord(char) - offset + 13) % 26) + offset) # Other characters are not encoded else: encoded_char = char # Append encoded character to the resulting list encoded.append(encoded_char) # Return the encoded bytes and the length of the input stream return ''.join(encoded), len(stream) def decode(self, stream, errors='strict'): # ROT13 is its own inverse return self.encode(stream, errors) def lookup(self, encoding): if encoding == 'rot13': codec = codecs.CodecInfo( name='rot13', encode=self.encode, decode=self.decode, ) else: codec = None return codec # Register the codec with the codecs module before using it codecs.register(ROT13Codec().lookup) # Usage encoded_text = codecs.encode(\"Hello, World!\", encoding='rot13') print(encoded_text) # Output: \"Uryyb, Jbeyq!\" decoded_text = codecs.decode(encoded_text, encoding='rot13') print(decoded_text) # Output: \"Hello, World!\"","title":"Data Codecs Custom"},{"location":"examples/16_data_types/#data-copying","text":"# Deep and shallow copying # ----------------------------------------------------------------------------- # Shallow and deep copying let you duplicate complex objects without affecting the originals. import copy # Create a deeply nested dictionary numbers_dict = { \"numbers\": { \"integers\": [1, 2, 3, 4, 5], \"floats\": [1.1, 2.2, 3.3, 4.4, 5.5] } } # Create a shallow copy of the dictionary shallow_copy = copy.copy(numbers_dict) # Create a deep copy of the dictionary deep_copy = copy.deepcopy(numbers_dict) # Modify the original dictionary numbers_dict[\"numbers\"][\"integers\"].append(6) numbers_dict[\"numbers\"][\"floats\"].append(6.6) # Print the original dictionary (modified) print(\"Original\", numbers_dict) # Print the shallow copy (modified) print(\"Shallow\", shallow_copy) # Print the deep copy (not modified) print(\"Deep\", deep_copy)","title":"Data Copying"},{"location":"examples/16_data_types/#data-counter-class","text":"# Counting with Counter # ----------------------------------------------------------------------------- # A Counter is a dictionary subclass for tallying hashable objects quickly. from collections import Counter # Create a Counter object a = Counter('abcdeabcdabcaba') b = Counter(reversed(\"abcdeabcdabcaba\")) # Print the Counter object print(a) print(b) # Print the three most common element print(a.most_common(3)) print(b.most_common(3)) # Add two Counter objects c = a + b print(c) # Subtract two Counter objects d = a - b print(d)","title":"Data Counter Class"},{"location":"examples/16_data_types/#data-dataclass","text":"# Lightweight data classes # ----------------------------------------------------------------------------- # Dataclasses eliminate boilerplate when defining classes meant primarily to store data. import dataclasses from dataclasses import dataclass, field from typing import List @dataclass class DataClass(object): name: str value: int def __post_init__(self): self.value = self.value * 2 def __str__(self): return f\"{self.name}: {self.value}\" @dataclass class DataClassWithDefaults(DataClass): name: str = \"MyData with defaults\" value: int = 0 data: List[int] = field(default_factory=list) def add_value(self, value): self.data.append(value) def __str__(self): return f\"{self.name}: {self.value}, {self.data}\" if __name__ == \"__main__\": my_data = DataClass(name=\"MyData\", value=10) print(my_data) my_data = DataClassWithDefaults() my_data.add_value(1) print(my_data)","title":"Data Dataclass"},{"location":"examples/16_data_types/#data-defaultdict","text":"# Automatic keys with defaultdict # ----------------------------------------------------------------------------- # defaultdict automatically creates missing keys so your code doesn't need explicit checks. from collections import defaultdict def test_default_factory(factory): d = defaultdict(factory) # Test the defaultdict try: print(d['key1']) print(d['key2']) print(d['key3']) except KeyError as e: print(\"KeyError: {}\".format(e)) assert True print() if __name__ == \"__main__\": default_factories = [ None, # Behaves like a regular dictionary str, # Returns an empty string if the key is not found int, # Returns 0 if the key is not found float, # Returns 0.0 if the key is not found list, # Returns an empty list if the key is not found tuple, # Returns an empty tuple if the key is not found dict, # Returns an empty dictionary if the key is not found set, # Returns an empty set if the key is not found lambda: 'value', # Returns a default value if the key is not found ] for default_factory in default_factories: test_default_factory(default_factory)","title":"Data Defaultdict"},{"location":"examples/16_data_types/#data-deque-fifo","text":"# Deque as FIFO queue # ----------------------------------------------------------------------------- # Deque offers fast O(1) operations at both ends, making it ideal for implementing queues. from collections import deque def emtpy_deque(customers): # Test the deque while True: try: # Get the item from the right item = customers.pop() print(\"Get item: {}\".format(item)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_deque(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.appendleft(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a deque d = deque() # Fill the deque fill_deque(d) # Empty the deque emtpy_deque(d)","title":"Data Deque Fifo"},{"location":"examples/16_data_types/#data-deque-lifo","text":"# Deque as LIFO stack # ----------------------------------------------------------------------------- # Using deque as a stack provides efficient push and pop operations. from collections import deque def emtpy_deque(plates): # Test the deque while True: try: # Get the item from the right item = plates.pop() print(\"Get item: {}\".format(item)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_deque(plates): items = ['Soup plate', 'Salad plate', 'Dinner plate', 'Dessert plate'] for item in items: plates.append(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a deque d = deque() # Fill the deque fill_deque(d) # Empty the deque emtpy_deque(d)","title":"Data Deque Lifo"},{"location":"examples/16_data_types/#data-dill","text":"# Serializing with dill # ----------------------------------------------------------------------------- # dill extends pickle and can serialize a wider range of Python objects. import dill import sys class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Print the book object print(book.__dict__) # Serialize the book object serialized_book = dill.dumps(book) # Print the size of the serialized object print('Size of the serialized object: {} bytes'.format(sys.getsizeof(serialized_book))) # Print the serialized object print(serialized_book) # Deserialize the book object deserialized_book = dill.loads(serialized_book) # Print the book object print(deserialized_book.__dict__)","title":"Data Dill"},{"location":"examples/16_data_types/#data-filtering","text":"# Filtering with filter() # ----------------------------------------------------------------------------- # The built-in filter() returns elements for which a function returns True. def is_even(x): return x % 2 == 0 # Sample data sample = [1, 2, 3, 4, 5, 6, 7, 8, 9] # Filter using a filtering function (first) and an iterable (second) iterator = filter(is_even, sample) print(list(iterator)) # Filter using a lambda function (first) and an iterable (second) iterator = filter(lambda x: x % 2 == 0, sample) print(list(iterator))","title":"Data Filtering"},{"location":"examples/16_data_types/#data-heapq","text":"# heapq priority queue # ----------------------------------------------------------------------------- # A heap lets you maintain a priority queue with O(log n) push/pop operations. import heapq def empty_heapq(h): # Test the heapq while True: try: print(heapq.heappop(h)) except IndexError as e: print(\"Empty: {}\".format(e)) break print() def fill_heapq(h): # Add items to the heapq heapq.heappush(h, 4) heapq.heappush(h, 1) heapq.heappush(h, 7) if __name__ == \"__main__\": # Create a heapq heap = [] heapq.heapify(heap) # Fill the heapq fill_heapq(heap) # Empty the heapq empty_heapq(heap)","title":"Data Heapq"},{"location":"examples/16_data_types/#data-mapping","text":"# Mapping with map() # ----------------------------------------------------------------------------- # map() applies a function to every element of an iterable, returning the results. def sqr(x): return x * x # Sample data sample = [1, 2, 3, 4, 5, 6, 7, 8, 9] # Map using a mapping function (first) and an iterable (second) iterator = map(sqr, sample) print(list(iterator)) # Map using a lambda function (first) and an iterable (second) iterator = map(lambda x: x * x, sample) print(list(iterator))","title":"Data Mapping"},{"location":"examples/16_data_types/#data-namedtuple","text":"# Named tuples # ----------------------------------------------------------------------------- # namedtuples give tuple-like objects readable field names without extra overhead. from collections import namedtuple # Create a namedtuple (label, fields) # - The label will be used in the representation of the namedtuple # - The fields will be used to access the namedtuple attributes Point = namedtuple('Point', ['x', 'y']) p = Point(1, 2) # Test the namedtuple representation print(p) # Test the namedtuple attributes print(p.x) print(p.y) # Test the namedtuple index access print(p[0]) print(p[1])","title":"Data Namedtuple"},{"location":"examples/16_data_types/#data-ordered-dict","text":"# Ordered dictionaries # ----------------------------------------------------------------------------- # OrderedDict remembers the insertion order of keys, which can be useful for reproducible iteration. from collections import OrderedDict # Create an OrderedDict od = OrderedDict() # Add elements od['a'] = 1 od['b'] = 2 od['c'] = 3 od['d'] = 4 # Print the OrderedDict print(od) # Move 'c' to the end od.move_to_end('c') # Print the OrderedDict print(od) # Move 'c' to the start od.move_to_end('c', last=False) # Print the OrderedDict print(od)","title":"Data Ordered Dict"},{"location":"examples/16_data_types/#data-packing","text":"# Packing *args and **kwargs # ----------------------------------------------------------------------------- # Packing arguments allows functions to accept an arbitrary number of positional or keyword parameters. def func1(*args): # args is a tuple of arguments (packed) print(sum(args)) # Unpack the tuple into individual arguments print(*args) func1(1, 2, 3, 4)","title":"Data Packing"},{"location":"examples/16_data_types/#data-pickle","text":"# Object serialization with pickle # ----------------------------------------------------------------------------- # pickle serializes and deserializes Python objects so they can be saved and restored later. import pickle import sys class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Print the book object print(book.__dict__) # Serialize the book object serialized_book = pickle.dumps(book) # Print the size of the serialized object print('Size of the serialized object: {} bytes'.format(sys.getsizeof(serialized_book))) # Print the serialized object print(serialized_book) # Deserialize the book object deserialized_book = pickle.loads(serialized_book) # Print the book object print(deserialized_book.__dict__)","title":"Data Pickle"},{"location":"examples/16_data_types/#data-queue-fifo","text":"# FIFO queue with Queue # ----------------------------------------------------------------------------- # queue.Queue provides a thread-safe FIFO structure for coordinating producer/consumer workloads. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: item = customers.get(block=False) print(\"Get item: {}\".format(item)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.put(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a FIFO queue d = queue.Queue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d)","title":"Data Queue Fifo"},{"location":"examples/16_data_types/#data-queue-lifo","text":"# LIFO queue with LifoQueue # ----------------------------------------------------------------------------- # LifoQueue behaves like a stack while remaining safe for use with multiple threads. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: item = customers.get(block=False) print(\"Get item: {}\".format(item)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for item in items: customers.put(item) print(\"Add item: {}\".format(item)) print() if __name__ == \"__main__\": # Create a LIFO queue d = queue.LifoQueue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d)","title":"Data Queue Lifo"},{"location":"examples/16_data_types/#data-queue-priority","text":"# Priority queues # ----------------------------------------------------------------------------- # PriorityQueue orders tasks by priority, letting the smallest value be retrieved first. from six.moves import queue def empty_queue(customers): # Test the queue while True: try: priority, item = customers.get(block=False) print(\"Get {:8} : priority {:5}\".format(item, priority)) except queue.Empty as e: print(\"Empty: {}\".format(e)) break print() def fill_queue(customers): priorities = [3, 1, 2, 4] items = ['Ivan', 'Dragan', 'Petkan', 'Stoyan'] for priority, item in zip(priorities, items): priority = int(priority) customers.put((priority, item)) print(\"Add {:8} : priority {:5}\".format(item, priority)) print() if __name__ == \"__main__\": # Create a FIFO queue d = queue.PriorityQueue() # Fill the queue fill_queue(d) # Empty the queue empty_queue(d)","title":"Data Queue Priority"},{"location":"examples/16_data_types/#data-reducing","text":"# Aggregating with reduce() # ----------------------------------------------------------------------------- # reduce() repeatedly applies a function to items, collapsing them into a single result. from functools import reduce def total(x, y): return x + y # Sample data sample = [1, 1, 1] # Map using a mapping function (first) and an iterable (second) value = reduce(total, sample) print(value) # Map using a lambda function (first) and an iterable (second) iterator = reduce(lambda x, y: x + y, sample) print(value)","title":"Data Reducing"},{"location":"examples/16_data_types/#data-reversing","text":"# Reverse iteration # ----------------------------------------------------------------------------- # The reversed() built-in returns an iterator that yields items from the end to the start. # Sample data sample_1 = [1, 2, 5, 4, 3] sample_2 = {1: 'a', 2: 'b', 5: 'd', 4: 'c', 3: 'e'} # Reverse a list iterator = reversed(sample_1) print(list(iterator)) # Reverse a dictionary iterator = reversed(sample_2.items()) print(list(iterator))","title":"Data Reversing"},{"location":"examples/16_data_types/#data-sorting","text":"# Sorting with sorted() # ----------------------------------------------------------------------------- # sorted() creates a new sorted list from any iterable, optionally using a key function. class Book(object): def __init__(self, title, author, year): self.title = title self.author = author self.year = year def __repr__(self): return \"Book({title}, {author}, {year})\".format( title=self.title, author=self.author, year=self.year) # List of books books = [ Book('The Great Gatsby', 'F. Scott Fitzgerald', 1925), Book('To Kill a Mockingbird', 'Harper Lee', 1960), Book('1984', 'George Orwell', 1949), Book('Brave New World', 'Aldous Huxley', 1932), Book('The Catcher in the Rye', 'J.D. Salinger', 1951), ] # Sort the list of dictionaries based on the 'year' key in each dictionary sorted_books = sorted(books, key=lambda book: book.year) # Print the sorted list for b in sorted_books: print(b)","title":"Data Sorting"},{"location":"examples/16_data_types/#data-struct","text":"# Working with struct # ----------------------------------------------------------------------------- # The struct module packs and unpacks binary data to interact with C-style structs. import struct class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Define the byte stream format (32s = 32 characters, f = float, i = integer), big-endian (>) serialized = struct.pack('>32s 32s f i', book.title.encode('utf-8'), book.author.encode('utf-8'), book.price, book.year ) # Print the size of the serialized object (32 + 32 + 4 + 4 = 72 bytes) print('Size of the serialized object: {} bytes'.format(struct.calcsize('32s 32s f i'))) # Print the binary stream (72 bytes) print(serialized) # Deserialize the data title, author, price, year = struct.unpack('32s 32s f i', serialized) print(title.decode('utf-8').strip('\\x00')) print(author.decode('utf-8').strip('\\x00')) print(price) print(year)","title":"Data Struct"},{"location":"examples/16_data_types/#data-struct-with-buffer","text":"# Struct packing into buffers # ----------------------------------------------------------------------------- # Packing directly into an existing buffer lets you build binary data without intermediate strings. import struct class Book(object): def __init__(self, title, author, price, year): self.title = title self.author = author self.price = price self.year = year if __name__ == \"__main__\": # Create a book object book = Book(title='Python for Dummies', author='John Smith', price=25.0, year=2014) # Define the byte stream format (32s = 32 characters, f = float, i = integer), big-endian (>) format_string = '>32s 32s f i' # Create the buffer buffer_size = struct.calcsize(format_string) buffer = bytearray(buffer_size) # Pack the data into the buffer serialized = struct.pack(format_string, book.title.encode('utf-8'), book.author.encode('utf-8'), book.price, book.year ) # Print the size of the serialized object (32 + 32 + 4 + 4 = 72 bytes) print('Size of the serialized object: {} bytes'.format(struct.calcsize('32s 32s f i'))) # Print the binary stream (72 bytes) print(serialized) # Deserialize the data title, author, price, year = struct.unpack_from(format_string, serialized) print(title.decode('utf-8').strip('\\x00')) print(author.decode('utf-8').strip('\\x00')) print(price) print(year)","title":"Data Struct With Buffer"},{"location":"examples/16_data_types/#data-unpacking","text":"# Argument unpacking # ----------------------------------------------------------------------------- # Unpacking with * and ** lets you pass iterables or mappings as arguments in a clean syntax. # A list of arguments pos_args = [1, 2, 3, 4] keyword_args = {'a': 1, 'b': 2, 'c': 3, 'd': 4} # A sample function that takes 4 arguments # and prints the, def func1(a, b, c, d): print(a, b, c, d) # Variable number of arguments def func2(a, b, c, d, *args): print(a + b + c + d + sum(args)) # Variable number of keyword arguments def func3(**kwargs): print(kwargs['a'] + kwargs['b'] + kwargs['c'] + kwargs['d']) func1(*pos_args) func2(*pos_args) func3(**keyword_args) test = \"PYTHON\" unpacked = [*test] print(unpacked)","title":"Data Unpacking"},{"location":"examples/16_data_types/#data-zipping","text":"# Pairing items with zip() # ----------------------------------------------------------------------------- # zip() pairs elements from multiple iterables so you can iterate over them in lockstep. # Sample data numbers = [1, 2, 3] letters = ['a', 'b', 'c'] # Zip two lists zipped = zip(numbers, letters) zipped_list = list(zipped) print(zipped_list) # Unzip into two lists unzipped = zip(*zipped_list) numbers, letters = map(list, unzipped) print(numbers) print(letters)","title":"Data Zipping"},{"location":"examples/16_data_types/#unpack-dict","text":"# Dictionary unpacking # ----------------------------------------------------------------------------- # The * operator can expand a mapping's items into function arguments or into new dictionaries. \"\"\" https://realpython.com/python-kwargs-and-args/#unpacking-with-the-asterisk-operators \"\"\" test = {\"a\": 1, \"b\": 2, \"c\": 3} print(test) # Unpack dictionary print(*test) print(*test.keys()) print(*test.values()) print(*test.items()) # Unpack first element and then the rest a, *b = test.items() print(a, b) # Merge two lists first = {\"A\": 1, \"B\": 2} second = {\"C\": 3, \"D\": 4} merged = {**first, **second} print(merged)","title":"Unpack Dict"},{"location":"examples/16_data_types/#unpack-list","text":"# List unpacking # ----------------------------------------------------------------------------- # Using * with a list expands its items when calling a function. \"\"\" https://realpython.com/python-kwargs-and-args/#unpacking-with-the-asterisk-operators \"\"\" test = [1, 2, 3] print(test) # Unpack list and print uses elements as arguments print(*test) # Unpack first element and then the rest a, *b = test print(a, b) # Merge two lists first = [1, 2, 3] second = [4, 5, 6] merged = [*first, *second] print(merged)","title":"Unpack List"},{"location":"examples/16_data_types/#unpack-snippets","text":"# Unpacking snippets # ----------------------------------------------------------------------------- # These small examples show how the * operator can gather or scatter items from sequences. test_string = \"PYTHON\" test_list = [1, 2, 3, 4] test_dict = {\"A\": 1, \"B\": 2} # Unpack string *test, = test_string print(test) # Unpack list *test, = test_list print(test) # Unpack dictionary items *test, = test_dict.items() print(test) # Copy dictionary test = {**test_dict} print(test) print(test is test_dict)","title":"Unpack Snippets"},{"location":"examples/17_import_system/","text":"Import System Export Decorator # Defines an export decorator for populating a package's __all__. # ------------------------------------------------------------------------------ # Utility that adds functions to a package's __all__. # Demonstrates placing the export decorator in a package's __init__ file # Export decorator def export(defn): # Add the object to the global namespace globals()[defn.__name__] = defn # Set the object to be exported __all__.append(defn.__name__) # Return the object return defn # Demonstration of the export decorator @export def func4(): print('func4') Import Absolute # Shows how to enforce and use absolute imports. # ------------------------------------------------------------------------------ # Example script demonstrating absolute imports. # Using absolute imports import asyncio # Enforce absolute imports from __future__ import absolute_import # Absolute imports from foo.api.submodule1 import func1 from foo.core.submodule2 import func2 from foo.gui.submodule3 import func3 # Call all functions func1() func2() func3() Import Circular # Triggers a circular import between two submodules. # ------------------------------------------------------------------------------ # Runs the circular import scenario. import circular.submodule1 as submodule1 submodule1.func1() Import Conditional # Shows conditional imports based on Python version. # ------------------------------------------------------------------------------ # Uses different imports depending on Python version. import sys # Option 1 try: import Queue as queue except ImportError: import queue q = queue.Queue() print(q) # Option 2 is_py2 = sys.version[0] == '2' if is_py2: import Queue as test2 else: import queue as test2 q = test2.Queue() print(q) Import Main Module # Demonstrates __main__ name when executing a module as a script. # ------------------------------------------------------------------------------ # Shows module __name__ when executed directly. # Main program entry point import pprint # The module attribute __name__ is set to '__main__' when the module is run as the main program. print(globals()['__name__']) Import Module Objects # Shows manual creation of ModuleType objects to demonstrate import internals. # ------------------------------------------------------------------------------ # Creates modules manually via ModuleType. from types import ModuleType # Create a new module object test = ModuleType('test') print(\"test.__dict__:\", test.__dict__) # Add some attributes to the module test.__dict__['a'] = 1 test.__dict__['b'] = 2 test.__dict__['c'] = 3 # Print the module's namespace print(\"test.__dict__:\", test.__dict__) Import Namespaces # Explores namespaces at different scopes using builtins and custom classes. # ------------------------------------------------------------------------------ # Traces namespace dictionaries at various scopes. # Namespace of the builtins module. import pprint class MyClass(object): def __init__(self): self.a = 1 self.b = 2 def instance_method(self): pprint.pprint(\"INSTANCE GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"INSTANCE LOCALS: {}\".format(locals().keys())) print() @classmethod def class_method(cls): pprint.pprint(\"CLASS GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"CLASS LOCALS: {}\".format(locals().keys())) print() def func1(self): print(\"@FUNC1: Before the assignment of a\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() a = 1 print(\"@FUNC1: After the assignment of a\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() def func2(): print(\"@FUNC2: Before the assignment of b\") pprint.pprint(\"FUNC2 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC2 LOCALS: {}\".format(locals().keys())) print() b = a + 1 print(\"@FUNC2: After the assignment of b\") pprint.pprint(\"FUNC2 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC2 LOCALS: {}\".format(locals().keys())) print() func2() print(\"@FUNC1: After the call to func2\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() # Builtins level print(\"===== Builtins namespace =====\") print() pprint.pprint(\"BUILTINS VARS: {}\".format(vars(__builtins__).keys())) print() # Module level print(\"===== Module namespace =====\") print() pprint.pprint(\"MODULE GLOBALS VARS: {}\".format(globals().keys())) pprint.pprint(\"MODULE LOCALS VARS: {}\".format(locals().keys())) print() # Class level print(\"===== Class namespace =====\") print() pprint.pprint(\"CLASS VARS: {}\".format(vars(MyClass).keys())) MyClass.class_method() print() # Instance level print(\"===== Instance namespace =====\") print() my_instance = MyClass() print(vars(my_instance)) my_instance.instance_method() print() # Function level print(\"===== Function namespace =====\") print() my_instance.func1() print(vars(my_instance.func1)) print() Import Packages # Demonstrates importing a package and using its public API. # ------------------------------------------------------------------------------ # Imports the foo package and uses its API. import product # Use the public API defined in __init__.py product.func1() product.func2() product.func3() Import Process # Implements a minimal importer to show how Python loads modules. # ------------------------------------------------------------------------------ # Minimal demonstration of how the import statement works. # A naive implementation of the import statement import marshal import os import sys import types def _import(module_name): # Check if the module is already imported if module_name in sys.modules: print('Module already imported') return sys.modules[module_name] # Read the source code from the file sourcepath = module_name + '.py' with open(sourcepath, 'r') as f: sourcecode = f.read() # Compile the source code to bytecode code = _compile(sourcecode, sourcepath, module_name) # Create a new module object module = types.ModuleType(module_name) module.__file__ = sourcepath # Cache the module object in sys.modules sys.modules[module_name] = module # Execute the bytecode in the module's namespace exec(code, module.__dict__) # Return the module object return sys.modules[module_name] def _compile(sourcecode, sourcepath, module_name): # Compile the source code of a module to bytecode. # -------------------------------------------------------------------------------- # Compiles the code and optionally writes a .pyc file. MAGIC_NUMBER = (3439).to_bytes(2, 'little') + b'\\r\\n' # Compile the source code to bytecode code = compile(sourcecode, sourcepath, 'exec') # The following code is optional # Serialize the code object and write it to a .pyc file with open(module_name + '.pyc', 'wb') as f: mtime = os.path.getmtime(sourcepath) size = os.path.getsize(sourcepath) f.write(MAGIC_NUMBER) f.write(int(mtime).to_bytes(4, sys.byteorder)) f.write(int(size).to_bytes(4, sys.byteorder)) marshal.dump(code, f) return code if __name__ == '__main__': s1 = _import('./foo/api/submodule1') s2 = _import('./foo/api/submodule1') print(s1.my_id, s2.my_id) Import Search Path # Displays and modifies sys.path to demonstrate search paths. # ------------------------------------------------------------------------------ # Displays and alters sys.path for searching modules. # Demonstrates the import search path import sys import pprint from api import submodule1 print('submodule1.my_id =', submodule1.my_id) # Print the search path paths = sys.path for path in paths: print(path) print() # Add the current directory to the search path sys.path.append('.') paths = sys.path for path in paths: print(path) Import Skip Execution # Demonstrates guarding code with __name__ to skip execution on import. # ------------------------------------------------------------------------------ # Guard code to avoid running on import. # Main program entry point def func1(): return 1 def func2(): return 2 def func3(): return 3 def test_module(): assert func1() == 1 assert func2() == 2 assert func3() == 3 # The following code prevents the module to be executed when imported as a # module. It will be executed only when run as a script directly by the Python # interpreter. If omitted the module will be executed on each import. if __name__ == '__main__': test_module() Import Statements # Illustrates various forms of the import statement. # ------------------------------------------------------------------------------ # Shows many forms of the import statement in use. # Import statements in action. # Importing the package import foo print('version =', foo.__version__) # Importing a submodule import foo.api.submodule1 print('api.submodule1.my_id =', foo.api.submodule1.my_id) # Importing the entire module with an alias import foo.api.submodule1 as sm1 print('sm1.my_id =', sm1.my_id) from foo.api import submodule1 print('submodule1.my_id =', submodule1.my_id) from foo.api.submodule1 import my_id print('my_id =', my_id) Import Sys Path # Shows sys.path details via prefix values. # ------------------------------------------------------------------------------ # Prints prefix values from sys.path. import sys print(sys.prefix) print(sys.exec_prefix) Import Tracking # Replaces builtins.__import__ to trace loaded modules. # ------------------------------------------------------------------------------ # Wraps __import__ to log module names. def my_import(modname, *args, imp=__import__): print('importing', modname) return imp(modname, *args) import builtins builtins.__import__ = my_import import socket Rootdir # Absolute path to this directory for search path tests. # ------------------------------------------------------------------------------ # Convenient variable for retrieving this directory. import os ROOT_DIR = os.path.dirname(os.path.abspath(__file__))","title":"Import System"},{"location":"examples/17_import_system/#import-system","text":"","title":"Import System"},{"location":"examples/17_import_system/#export-decorator","text":"# Defines an export decorator for populating a package's __all__. # ------------------------------------------------------------------------------ # Utility that adds functions to a package's __all__. # Demonstrates placing the export decorator in a package's __init__ file # Export decorator def export(defn): # Add the object to the global namespace globals()[defn.__name__] = defn # Set the object to be exported __all__.append(defn.__name__) # Return the object return defn # Demonstration of the export decorator @export def func4(): print('func4')","title":"Export Decorator"},{"location":"examples/17_import_system/#import-absolute","text":"# Shows how to enforce and use absolute imports. # ------------------------------------------------------------------------------ # Example script demonstrating absolute imports. # Using absolute imports import asyncio # Enforce absolute imports from __future__ import absolute_import # Absolute imports from foo.api.submodule1 import func1 from foo.core.submodule2 import func2 from foo.gui.submodule3 import func3 # Call all functions func1() func2() func3()","title":"Import Absolute"},{"location":"examples/17_import_system/#import-circular","text":"# Triggers a circular import between two submodules. # ------------------------------------------------------------------------------ # Runs the circular import scenario. import circular.submodule1 as submodule1 submodule1.func1()","title":"Import Circular"},{"location":"examples/17_import_system/#import-conditional","text":"# Shows conditional imports based on Python version. # ------------------------------------------------------------------------------ # Uses different imports depending on Python version. import sys # Option 1 try: import Queue as queue except ImportError: import queue q = queue.Queue() print(q) # Option 2 is_py2 = sys.version[0] == '2' if is_py2: import Queue as test2 else: import queue as test2 q = test2.Queue() print(q)","title":"Import Conditional"},{"location":"examples/17_import_system/#import-main-module","text":"# Demonstrates __main__ name when executing a module as a script. # ------------------------------------------------------------------------------ # Shows module __name__ when executed directly. # Main program entry point import pprint # The module attribute __name__ is set to '__main__' when the module is run as the main program. print(globals()['__name__'])","title":"Import Main Module"},{"location":"examples/17_import_system/#import-module-objects","text":"# Shows manual creation of ModuleType objects to demonstrate import internals. # ------------------------------------------------------------------------------ # Creates modules manually via ModuleType. from types import ModuleType # Create a new module object test = ModuleType('test') print(\"test.__dict__:\", test.__dict__) # Add some attributes to the module test.__dict__['a'] = 1 test.__dict__['b'] = 2 test.__dict__['c'] = 3 # Print the module's namespace print(\"test.__dict__:\", test.__dict__)","title":"Import Module Objects"},{"location":"examples/17_import_system/#import-namespaces","text":"# Explores namespaces at different scopes using builtins and custom classes. # ------------------------------------------------------------------------------ # Traces namespace dictionaries at various scopes. # Namespace of the builtins module. import pprint class MyClass(object): def __init__(self): self.a = 1 self.b = 2 def instance_method(self): pprint.pprint(\"INSTANCE GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"INSTANCE LOCALS: {}\".format(locals().keys())) print() @classmethod def class_method(cls): pprint.pprint(\"CLASS GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"CLASS LOCALS: {}\".format(locals().keys())) print() def func1(self): print(\"@FUNC1: Before the assignment of a\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() a = 1 print(\"@FUNC1: After the assignment of a\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() def func2(): print(\"@FUNC2: Before the assignment of b\") pprint.pprint(\"FUNC2 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC2 LOCALS: {}\".format(locals().keys())) print() b = a + 1 print(\"@FUNC2: After the assignment of b\") pprint.pprint(\"FUNC2 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC2 LOCALS: {}\".format(locals().keys())) print() func2() print(\"@FUNC1: After the call to func2\") pprint.pprint(\"FUNC1 GLOBALS: {}\".format(globals().keys())) pprint.pprint(\"FUNC1 LOCALS: {}\".format(locals().keys())) print() # Builtins level print(\"===== Builtins namespace =====\") print() pprint.pprint(\"BUILTINS VARS: {}\".format(vars(__builtins__).keys())) print() # Module level print(\"===== Module namespace =====\") print() pprint.pprint(\"MODULE GLOBALS VARS: {}\".format(globals().keys())) pprint.pprint(\"MODULE LOCALS VARS: {}\".format(locals().keys())) print() # Class level print(\"===== Class namespace =====\") print() pprint.pprint(\"CLASS VARS: {}\".format(vars(MyClass).keys())) MyClass.class_method() print() # Instance level print(\"===== Instance namespace =====\") print() my_instance = MyClass() print(vars(my_instance)) my_instance.instance_method() print() # Function level print(\"===== Function namespace =====\") print() my_instance.func1() print(vars(my_instance.func1)) print()","title":"Import Namespaces"},{"location":"examples/17_import_system/#import-packages","text":"# Demonstrates importing a package and using its public API. # ------------------------------------------------------------------------------ # Imports the foo package and uses its API. import product # Use the public API defined in __init__.py product.func1() product.func2() product.func3()","title":"Import Packages"},{"location":"examples/17_import_system/#import-process","text":"# Implements a minimal importer to show how Python loads modules. # ------------------------------------------------------------------------------ # Minimal demonstration of how the import statement works. # A naive implementation of the import statement import marshal import os import sys import types def _import(module_name): # Check if the module is already imported if module_name in sys.modules: print('Module already imported') return sys.modules[module_name] # Read the source code from the file sourcepath = module_name + '.py' with open(sourcepath, 'r') as f: sourcecode = f.read() # Compile the source code to bytecode code = _compile(sourcecode, sourcepath, module_name) # Create a new module object module = types.ModuleType(module_name) module.__file__ = sourcepath # Cache the module object in sys.modules sys.modules[module_name] = module # Execute the bytecode in the module's namespace exec(code, module.__dict__) # Return the module object return sys.modules[module_name] def _compile(sourcecode, sourcepath, module_name): # Compile the source code of a module to bytecode. # -------------------------------------------------------------------------------- # Compiles the code and optionally writes a .pyc file. MAGIC_NUMBER = (3439).to_bytes(2, 'little') + b'\\r\\n' # Compile the source code to bytecode code = compile(sourcecode, sourcepath, 'exec') # The following code is optional # Serialize the code object and write it to a .pyc file with open(module_name + '.pyc', 'wb') as f: mtime = os.path.getmtime(sourcepath) size = os.path.getsize(sourcepath) f.write(MAGIC_NUMBER) f.write(int(mtime).to_bytes(4, sys.byteorder)) f.write(int(size).to_bytes(4, sys.byteorder)) marshal.dump(code, f) return code if __name__ == '__main__': s1 = _import('./foo/api/submodule1') s2 = _import('./foo/api/submodule1') print(s1.my_id, s2.my_id)","title":"Import Process"},{"location":"examples/17_import_system/#import-search-path","text":"# Displays and modifies sys.path to demonstrate search paths. # ------------------------------------------------------------------------------ # Displays and alters sys.path for searching modules. # Demonstrates the import search path import sys import pprint from api import submodule1 print('submodule1.my_id =', submodule1.my_id) # Print the search path paths = sys.path for path in paths: print(path) print() # Add the current directory to the search path sys.path.append('.') paths = sys.path for path in paths: print(path)","title":"Import Search Path"},{"location":"examples/17_import_system/#import-skip-execution","text":"# Demonstrates guarding code with __name__ to skip execution on import. # ------------------------------------------------------------------------------ # Guard code to avoid running on import. # Main program entry point def func1(): return 1 def func2(): return 2 def func3(): return 3 def test_module(): assert func1() == 1 assert func2() == 2 assert func3() == 3 # The following code prevents the module to be executed when imported as a # module. It will be executed only when run as a script directly by the Python # interpreter. If omitted the module will be executed on each import. if __name__ == '__main__': test_module()","title":"Import Skip Execution"},{"location":"examples/17_import_system/#import-statements","text":"# Illustrates various forms of the import statement. # ------------------------------------------------------------------------------ # Shows many forms of the import statement in use. # Import statements in action. # Importing the package import foo print('version =', foo.__version__) # Importing a submodule import foo.api.submodule1 print('api.submodule1.my_id =', foo.api.submodule1.my_id) # Importing the entire module with an alias import foo.api.submodule1 as sm1 print('sm1.my_id =', sm1.my_id) from foo.api import submodule1 print('submodule1.my_id =', submodule1.my_id) from foo.api.submodule1 import my_id print('my_id =', my_id)","title":"Import Statements"},{"location":"examples/17_import_system/#import-sys-path","text":"# Shows sys.path details via prefix values. # ------------------------------------------------------------------------------ # Prints prefix values from sys.path. import sys print(sys.prefix) print(sys.exec_prefix)","title":"Import Sys Path"},{"location":"examples/17_import_system/#import-tracking","text":"# Replaces builtins.__import__ to trace loaded modules. # ------------------------------------------------------------------------------ # Wraps __import__ to log module names. def my_import(modname, *args, imp=__import__): print('importing', modname) return imp(modname, *args) import builtins builtins.__import__ = my_import import socket","title":"Import Tracking"},{"location":"examples/17_import_system/#rootdir","text":"# Absolute path to this directory for search path tests. # ------------------------------------------------------------------------------ # Convenient variable for retrieving this directory. import os ROOT_DIR = os.path.dirname(os.path.abspath(__file__))","title":"Rootdir"},{"location":"examples/18_linting_tools/","text":"Linting Tools Lint Black # Formatting code with black # ----------------------------------------------------------------------------- # This script demonstrates invoking the ``black`` code formatter from Python. # It formats the target file if ``black`` is installed. import subprocess import sys def run_black(target: str) -> None: try: subprocess.run([\"black\", target], check=True) except FileNotFoundError: print(\"black is not installed.\") except subprocess.CalledProcessError as exc: print(f\"black reported an error: {exc}\") if __name__ == \"__main__\": file_to_format = sys.argv[1] if len(sys.argv) > 1 else __file__ run_black(file_to_format) Lint Flake8 # Linting code with flake8 # ----------------------------------------------------------------------------- # This script runs the ``flake8`` linter on the target file and reports # any issues. It gracefully handles the case where flake8 is not installed. import subprocess import sys def run_flake8(target: str) -> None: try: subprocess.run([\"flake8\", target], check=True) except FileNotFoundError: print(\"flake8 is not installed.\") except subprocess.CalledProcessError as exc: print(f\"flake8 found issues: {exc}\") if __name__ == \"__main__\": file_to_check = sys.argv[1] if len(sys.argv) > 1 else __file__ run_flake8(file_to_check) Lint Pylint # Linting code with pylint # ----------------------------------------------------------------------------- # ``pylint`` performs static code analysis. This script demonstrates how to # call it from Python and handle common error cases. import subprocess import sys def run_pylint(target: str) -> None: try: subprocess.run([\"pylint\", target], check=True) except FileNotFoundError: print(\"pylint is not installed.\") except subprocess.CalledProcessError as exc: print(f\"pylint found issues: {exc}\") if __name__ == \"__main__\": file_to_check = sys.argv[1] if len(sys.argv) > 1 else __file__ run_pylint(file_to_check)","title":"Linting Tools"},{"location":"examples/18_linting_tools/#linting-tools","text":"","title":"Linting Tools"},{"location":"examples/18_linting_tools/#lint-black","text":"# Formatting code with black # ----------------------------------------------------------------------------- # This script demonstrates invoking the ``black`` code formatter from Python. # It formats the target file if ``black`` is installed. import subprocess import sys def run_black(target: str) -> None: try: subprocess.run([\"black\", target], check=True) except FileNotFoundError: print(\"black is not installed.\") except subprocess.CalledProcessError as exc: print(f\"black reported an error: {exc}\") if __name__ == \"__main__\": file_to_format = sys.argv[1] if len(sys.argv) > 1 else __file__ run_black(file_to_format)","title":"Lint Black"},{"location":"examples/18_linting_tools/#lint-flake8","text":"# Linting code with flake8 # ----------------------------------------------------------------------------- # This script runs the ``flake8`` linter on the target file and reports # any issues. It gracefully handles the case where flake8 is not installed. import subprocess import sys def run_flake8(target: str) -> None: try: subprocess.run([\"flake8\", target], check=True) except FileNotFoundError: print(\"flake8 is not installed.\") except subprocess.CalledProcessError as exc: print(f\"flake8 found issues: {exc}\") if __name__ == \"__main__\": file_to_check = sys.argv[1] if len(sys.argv) > 1 else __file__ run_flake8(file_to_check)","title":"Lint Flake8"},{"location":"examples/18_linting_tools/#lint-pylint","text":"# Linting code with pylint # ----------------------------------------------------------------------------- # ``pylint`` performs static code analysis. This script demonstrates how to # call it from Python and handle common error cases. import subprocess import sys def run_pylint(target: str) -> None: try: subprocess.run([\"pylint\", target], check=True) except FileNotFoundError: print(\"pylint is not installed.\") except subprocess.CalledProcessError as exc: print(f\"pylint found issues: {exc}\") if __name__ == \"__main__\": file_to_check = sys.argv[1] if len(sys.argv) > 1 else __file__ run_pylint(file_to_check)","title":"Lint Pylint"},{"location":"examples/19_test_frameworks/","text":"Test Frameworks App # Framework: doctest # -------------------- # # Provide usage examples that serve as doctests for the conversion # functions. import logging import requests class App(object): \"\"\" A simple app to convert miles to km and vice versa Args: None Examples: >>> app = App() >>> app.miles_to_km(1) 1.61 >>> app.km_to_miles(1) 0.62 >>> app.miles_to_km({'a': 1, 'b': 2}) Traceback (most recent call last): ... TypeError: Input must be a float or int. Input was <class 'dict'> >>> app.miles_to_km([1, 2, 3]) Traceback (most recent call last): ... TypeError: Input must be a float or int. Input was <class 'list'> \"\"\" def __init__(self): # Get a logger object self.log = logging.getLogger(__name__) # Add a handler to the logger self.log.addHandler(logging.NullHandler()) def miles_to_km(self, miles): if isinstance(miles, float) or isinstance(miles, int) or isinstance(miles, str): km = miles * 1.60934 self.log.info('{miles} miles is {km} km'.format(miles=miles, km=km)) return round(km, 2) else: self.log.error(f'Input must be a float, int or str. Input was {type(miles)}') raise TypeError(f'Input must be a float or int. Input was {type(miles)}') def km_to_miles(self, km): if isinstance(km, float) or isinstance(km, int) or isinstance(km, str): miles = km / 1.60934 self.log.info(f'{km} km is {miles} miles') return round(miles, 2) else: self.log.error(f'Input must be a float, int or str. Input was {type(km)}') raise TypeError(f'Input must be a float or int. Input was {type(km)}') @staticmethod def process_payment(payment_data): # Make an HTTP request to process the payment response = requests.post(\"https://payment-api.com/process\", json=payment_data) return response.status_code","title":"Test Frameworks"},{"location":"examples/19_test_frameworks/#test-frameworks","text":"","title":"Test Frameworks"},{"location":"examples/19_test_frameworks/#app","text":"# Framework: doctest # -------------------- # # Provide usage examples that serve as doctests for the conversion # functions. import logging import requests class App(object): \"\"\" A simple app to convert miles to km and vice versa Args: None Examples: >>> app = App() >>> app.miles_to_km(1) 1.61 >>> app.km_to_miles(1) 0.62 >>> app.miles_to_km({'a': 1, 'b': 2}) Traceback (most recent call last): ... TypeError: Input must be a float or int. Input was <class 'dict'> >>> app.miles_to_km([1, 2, 3]) Traceback (most recent call last): ... TypeError: Input must be a float or int. Input was <class 'list'> \"\"\" def __init__(self): # Get a logger object self.log = logging.getLogger(__name__) # Add a handler to the logger self.log.addHandler(logging.NullHandler()) def miles_to_km(self, miles): if isinstance(miles, float) or isinstance(miles, int) or isinstance(miles, str): km = miles * 1.60934 self.log.info('{miles} miles is {km} km'.format(miles=miles, km=km)) return round(km, 2) else: self.log.error(f'Input must be a float, int or str. Input was {type(miles)}') raise TypeError(f'Input must be a float or int. Input was {type(miles)}') def km_to_miles(self, km): if isinstance(km, float) or isinstance(km, int) or isinstance(km, str): miles = km / 1.60934 self.log.info(f'{km} km is {miles} miles') return round(miles, 2) else: self.log.error(f'Input must be a float, int or str. Input was {type(km)}') raise TypeError(f'Input must be a float or int. Input was {type(km)}') @staticmethod def process_payment(payment_data): # Make an HTTP request to process the payment response = requests.post(\"https://payment-api.com/process\", json=payment_data) return response.status_code","title":"App"},{"location":"examples/20_package_managers/","text":"Package Managers Package List # Listing installed packages # ----------------------------------------------------------------------------- # This example prints all installed distributions using ``pkg_resources`` from # ``setuptools``. It can help inspect the current Python environment. import pkg_resources for dist in sorted(pkg_resources.working_set, key=lambda d: d.project_name.lower()): print(f\"{dist.project_name}=={dist.version}\") Package Pip Install # Installing a package with pip # ----------------------------------------------------------------------------- # This example invokes ``pip`` through ``subprocess`` to install the requested # package. In real scenarios this requires network access. import subprocess import sys def pip_install(package: str) -> None: try: subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", package], check=True) except subprocess.CalledProcessError as exc: print(f\"pip failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" pip_install(pkg) Package Pipenv # Using pipenv to install packages # ----------------------------------------------------------------------------- # This script invokes ``pipenv install`` to install the requested package. # ``pipenv`` must be installed and available on PATH. import subprocess import sys def pipenv_install(package: str) -> None: try: subprocess.run([\"pipenv\", \"install\", package], check=True) except FileNotFoundError: print(\"pipenv is not installed.\") except subprocess.CalledProcessError as exc: print(f\"pipenv failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" pipenv_install(pkg) Package Poetry # Managing packages with poetry # ----------------------------------------------------------------------------- # This script calls ``poetry add`` to add the requested package to the # ``pyproject.toml`` of the current directory. ``poetry`` must be installed. import subprocess import sys def poetry_add(package: str) -> None: try: subprocess.run([\"poetry\", \"add\", package], check=True) except FileNotFoundError: print(\"poetry is not installed.\") except subprocess.CalledProcessError as exc: print(f\"poetry failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" poetry_add(pkg) Package Uv # Installing packages with uv # ----------------------------------------------------------------------------- # ``uv`` is a modern package manager that can replace ``pip``. This script # demonstrates invoking ``uv pip install`` to install a package. import subprocess import sys def uv_install(package: str) -> None: try: subprocess.run([\"uv\", \"pip\", \"install\", package], check=True) except FileNotFoundError: print(\"uv is not installed.\") except subprocess.CalledProcessError as exc: print(f\"uv failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" uv_install(pkg) Package Virtualenv # Creating a virtual environment # ----------------------------------------------------------------------------- # The ``venv`` module can be used to create isolated Python environments. This # script programmatically creates one in the ``example_env`` directory. from pathlib import Path import venv def create_env(path: Path) -> None: builder = venv.EnvBuilder(with_pip=True) builder.create(path) print(f\"Virtual environment created at {path}\") if __name__ == \"__main__\": create_env(Path(\"example_env\"))","title":"Package Managers"},{"location":"examples/20_package_managers/#package-managers","text":"","title":"Package Managers"},{"location":"examples/20_package_managers/#package-list","text":"# Listing installed packages # ----------------------------------------------------------------------------- # This example prints all installed distributions using ``pkg_resources`` from # ``setuptools``. It can help inspect the current Python environment. import pkg_resources for dist in sorted(pkg_resources.working_set, key=lambda d: d.project_name.lower()): print(f\"{dist.project_name}=={dist.version}\")","title":"Package List"},{"location":"examples/20_package_managers/#package-pip-install","text":"# Installing a package with pip # ----------------------------------------------------------------------------- # This example invokes ``pip`` through ``subprocess`` to install the requested # package. In real scenarios this requires network access. import subprocess import sys def pip_install(package: str) -> None: try: subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", package], check=True) except subprocess.CalledProcessError as exc: print(f\"pip failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" pip_install(pkg)","title":"Package Pip Install"},{"location":"examples/20_package_managers/#package-pipenv","text":"# Using pipenv to install packages # ----------------------------------------------------------------------------- # This script invokes ``pipenv install`` to install the requested package. # ``pipenv`` must be installed and available on PATH. import subprocess import sys def pipenv_install(package: str) -> None: try: subprocess.run([\"pipenv\", \"install\", package], check=True) except FileNotFoundError: print(\"pipenv is not installed.\") except subprocess.CalledProcessError as exc: print(f\"pipenv failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" pipenv_install(pkg)","title":"Package Pipenv"},{"location":"examples/20_package_managers/#package-poetry","text":"# Managing packages with poetry # ----------------------------------------------------------------------------- # This script calls ``poetry add`` to add the requested package to the # ``pyproject.toml`` of the current directory. ``poetry`` must be installed. import subprocess import sys def poetry_add(package: str) -> None: try: subprocess.run([\"poetry\", \"add\", package], check=True) except FileNotFoundError: print(\"poetry is not installed.\") except subprocess.CalledProcessError as exc: print(f\"poetry failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" poetry_add(pkg)","title":"Package Poetry"},{"location":"examples/20_package_managers/#package-uv","text":"# Installing packages with uv # ----------------------------------------------------------------------------- # ``uv`` is a modern package manager that can replace ``pip``. This script # demonstrates invoking ``uv pip install`` to install a package. import subprocess import sys def uv_install(package: str) -> None: try: subprocess.run([\"uv\", \"pip\", \"install\", package], check=True) except FileNotFoundError: print(\"uv is not installed.\") except subprocess.CalledProcessError as exc: print(f\"uv failed: {exc}\") if __name__ == \"__main__\": pkg = sys.argv[1] if len(sys.argv) > 1 else \"requests\" uv_install(pkg)","title":"Package Uv"},{"location":"examples/20_package_managers/#package-virtualenv","text":"# Creating a virtual environment # ----------------------------------------------------------------------------- # The ``venv`` module can be used to create isolated Python environments. This # script programmatically creates one in the ``example_env`` directory. from pathlib import Path import venv def create_env(path: Path) -> None: builder = venv.EnvBuilder(with_pip=True) builder.create(path) print(f\"Virtual environment created at {path}\") if __name__ == \"__main__\": create_env(Path(\"example_env\"))","title":"Package Virtualenv"},{"location":"examples/21_design_patterns/","text":"Design Patterns Abstract Factory # Example: Abstract Factory from abc import ABC, abstractmethod class Button(ABC): # Abstract interface for buttons @abstractmethod def paint(self): raise NotImplementedError class WinButton(Button): # Concrete foo for Windows buttons def paint(self): print(\"WinButton\") class LinuxButton(Button): def paint(self): print(\"LinuxButton\") class Menu(ABC): # Abstract interface for menus @abstractmethod def paint(self): raise NotImplementedError class WinMenu(Menu): # Concrete foo for Windows menus def paint(self): print(\"WindowsMenu\") class LinuxMenu(Menu): # Concrete foo for Linux menus def paint(self): print(\"LinuxMenu\") class GUIFactory(ABC): # Abstract factory that declares a set of methods for creating each of the # products. These methods must return abstract foo types represented by # the abstract interfaces Button and Menu. @abstractmethod def create_button(self) -> Button: raise NotImplementedError @abstractmethod def create_menu(self) -> Menu: raise NotImplementedError class WinFactory(GUIFactory): # The concrete factory for Windows foo variants. def create_button(self): return WinButton() def create_menu(self): return WinMenu() class LinuxFactory(GUIFactory): # The concrete factory for Linux foo variants. def create_button(self): return LinuxButton() def create_menu(self): return LinuxMenu() if __name__ == \"__main__\": os = input(\"Select OS: \") if os == \"win\": factory = WinFactory() elif os == \"linux\": factory = LinuxFactory() else: raise ValueError(\"Invalid GUI\") # Create the GUI button = factory.create_button() menu = factory.create_menu() gui = [button, menu] # Paint the GUI for item in gui: item.paint() Adapter With Composition # Example: Adapter Pattern (Object Adapter) class ChannelV1(object): @staticmethod def applyConfig(): # method name from actual legacy code in the company print('Configuration method of the old device class!') class ChannelV2(object): @staticmethod def configure(): print('Configuration method of the new device class!') class ChannelAdapter(ChannelV1): # Class adapter (with composition) def __init__(self, adaptee): self.adaptee = adaptee def applyConfig(self): self.adaptee.configure() def host_app(channel): channel.applyConfig() if __name__ == \"__main__\": # Original code using the old service host_app(channel=ChannelV1()) # Use adapter for the new service adapted to the old interface host_app(channel=ChannelAdapter(adaptee=ChannelV2())) Adapter With Inheritance class ChannelV1(object): @staticmethod def applyConfig(): # method name from actual legacy code in the company (Python 2.7) print('Configuration method of the old device class!') class ChannelV2(object): @staticmethod def configure(): print('Configuration method of the new device class!') class ChannelAdapter(ChannelV1, ChannelV2): # Class adapter (with inheritance) def applyConfig(self): # The adapter's applyConfig method calls the new class's configure method self.configure() def host_app(channel): # The host_app function works with the ChannelV1 interface channel.applyConfig() if __name__ == \"__main__\": # Original code using the old service (ChannelV1) host_app(channel=ChannelV1()) # Use adapter for the new service (ChannelV2) adapted to the old interface (ChannelV1) host_app(channel=ChannelAdapter()) Bridge # Example: Bridge Pattern with shapes and colors class Color(object): # Interface for Implementation def __init__(self, name): self.name = name def paint(self, shape): raise NotImplementedError class Red(Color): # Concrete implementation for red color def __init__(self): super(Red, self).__init__('red') def paint(self, shape): print('Painting the {} with red color'.format(shape)) class Blue(Color): # Concrete implementation for blue color def __init__(self): super(Blue, self).__init__('blue') def paint(self, shape): print('Painting the {} with blue color'.format(shape)) class Shape(object): # This is the abstaction used by the client def __init__(self, color: Color): self.color = color def draw(self): raise NotImplementedError class Circle(Shape): # Refinded abstraction for circles def draw(self): print('Drawing a circle') self.color.paint(shape='circle') class Square(Shape): # Refined abstraction for squares def draw(self): print('Drawing a square') self.color.paint(shape='square') class DrawApp(object): # This is the client class @staticmethod def draw(shape: Shape): shape.draw() if __name__ == \"__main__\": # Draw a red circle app = DrawApp() # Draw shapes app.draw(shape=Circle(color=Red())) app.draw(shape=Square(color=Blue())) Builder # Example: Builder Pattern from abc import ABC, abstractmethod class Pizza(object): def __init__(self): self.crust = None self.cheese = None self.toppings = [] def __str__(self): return \"Crust: {0}\\nCheese: {1}\\nToppings: {2}\".format( self.crust, self.cheese, \", \".join(self.toppings) ) class PizzaBuilderAbc(ABC): @abstractmethod def set_crust(self, crust): pass @abstractmethod def add_cheese(self, cheese): pass @abstractmethod def add_topping(self, topping): pass @abstractmethod def build(self): pass class MyPizzaBuilder(object): def __init__(self): self.pizza = Pizza() def set_crust(self, crust): self.pizza.crust = crust return self def add_cheese(self, cheese): self.pizza.cheese = cheese return self def add_topping(self, topping): self.pizza.toppings.append(topping) return self def build(self): return self.pizza pizza = ( MyPizzaBuilder() .set_crust(\"thin\") .add_cheese(\"mozzarella\") .add_topping(\"pepperoni\") .add_topping(\"mushrooms\") .build() ) print(pizza) Chain Chain Of Responsibility # Example: Chain of Responsibility Pattern # Handler interface class Approver(object): def __init__(self, successor=None): self.successor = successor def set_successor(self, successor): self.successor = successor def approve(self, purchase): pass # Concrete handlers class TeamLeader(Approver): def approve(self, purchase): if purchase <= 1000: print(f\"Team Leader approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class Manager(Approver): def approve(self, purchase): if 1000 < purchase <= 5000: print(f\"Manager approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class Director(Approver): def approve(self, purchase): if 5000 < purchase <= 10000: print(f\"Director approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class President(Approver): def approve(self, purchase): if purchase > 10000: print(f\"President approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) # Client code if __name__ == \"__main__\": # Define the roles in the chain of responsibility team_leader = TeamLeader() manager = Manager() director = Director() president = President() # Set the successors team_leader.set_successor(manager) manager.set_successor(director) director.set_successor(president) # Create purchases purchases = [500, 1000, 2000, 5000, 10000, 20000] # Process the purchases for purchase in purchases: team_leader.approve(purchase) Command # Example: Command Pattern # Command interface class Command(object): def execute(self): pass def undo(self): pass # Concrete commands class TypeCommand(Command): def __init__(self, text, document): self.text = text self.document = document def execute(self): self.document.add_text(self.text) def undo(self): self.document.remove_text(self.text) # Receiver class class Document(object): def __init__(self): self.content = \"\" def add_text(self, text): self.content += text def remove_text(self, text): if text and text in self.content: self.content = self.content.replace(text, \"\", 1) def get_content(self): return self.content # Invoker class (TextEditor) class TextEditor(object): def __init__(self): self.history = [] def execute(self, command): command.execute() self.history.append(command) def undo_last_command(self): if self.history: command = self.history.pop() command.undo() # Client code if __name__ == \"__main__\": document = Document() editor = TextEditor() print(\"Initial content:\", document.get_content()) # Type some text type_action1 = TypeCommand(\"Hello, \", document) editor.execute(type_action1) print(\"After typing:\", document.get_content()) type_action2 = TypeCommand(\"world!\", document) editor.execute(type_action2) print(\"After typing:\", document.get_content()) # Undo the last command editor.undo_last_command() print(\"After undo:\", document.get_content()) Composite # Example: Composite pattern from abc import abstractmethod class IComponent(object): # Interface used by both the leaf and composite classes def __init__(self, name): self.name = name @abstractmethod def execute(self): raise NotImplementedError class Leaf(IComponent): def execute(self): return \"{} running\".format(self.name) # Concrete implementation of the composite class class Composite(IComponent): # This is the composite class (tree is composed of leafs) def __init__(self, name=\"Root\"): super(Composite, self).__init__(name) self.components = [] def add(self, c): self.components.append(c) return self def remove(self, c): self.components.remove(c) return self def get_children(self): return self.components def execute(self): # Delegate work to all the children for child in self.components: print(\"{} / {}\".format(self.name, child.execute())) return \"{} running\".format(self.name) if __name__ == \"__main__\": # Define composite foo product = Composite() product.add(Leaf(\"Leaf 1\")) product.add(Leaf(\"Leaf 2\")) print(product.execute()) print() # Nested composite foo product.add( Composite(\"Subsystem A\") .add(Leaf(\"Leaf 1\")) .add(Leaf(\"Leaf 2\")) ) print(product.execute()) Decorator # Example: Decorator Pattern from abc import ABC, abstractmethod class NotifierAbc(ABC): @abstractmethod def notify(self): pass class Notifier(NotifierAbc): def notify(self): print(\"Print on screen ...\") class NotifierDecorator(NotifierAbc): def __init__(self, component): self._component = component @abstractmethod def notify(self): pass class EmailNotifier(NotifierDecorator): @staticmethod def send_email(): print(\"Sending email ...\") def notify(self): self.send_email() self._component.notify() class SMSNotifier(NotifierDecorator): @staticmethod def send_sms(): print(\"Sending SMS ...\") def notify(self): self.send_sms() self._component.notify() def main(): notifier = Notifier() notifier_with_email = EmailNotifier(notifier) notifier_with_email_and_sms = SMSNotifier(notifier_with_email) notifier_with_email_and_sms.notify() if __name__ == \"__main__\": main() Facade # Example: Facade Pattern class PumpSystem(object): @staticmethod def prepare(): print(\"SubsystemA prepare ...\") @staticmethod def run(): print(\"SubsystemA run ...\") class VentilationSystem(object): @staticmethod def prepare(): print(\"SubsystemB prepare ...\") @staticmethod def run(): print(\"SubsystemB run ...\") class ComplexSystemFacade(object): def __init__(self): self._subsystemA = PumpSystem() self._subsystemB = VentilationSystem() def run(self): self._subsystemA.prepare() self._subsystemB.prepare() self._subsystemA.run() self._subsystemB.run() def main(): system = ComplexSystemFacade() system.run() if __name__ == \"__main__\": main() Factory Class Method # Example: Factory Method as a class method class Transport(object): def __init__(self): pass def deliver(self): pass class Truck(Transport): def deliver(self): print(\"Delivering by land in a box\") class Ship(Transport): def deliver(self): print(\"Delivering by sea in a container\") class Logistic(object): def __init__(self, transport): self.transport = transport def deliver(self): self.transport.deliver() @classmethod def from_json(cls, json): # Factory method # Get transport type token = json.get(\"transport_type\") # Convert to lowercase and remove whitespace transport_type = token.lower().strip(\" \\t\\n\\r\") # Factory logic if transport_type == \"truck\": return Truck() elif transport_type == \"ship\": return Ship() else: raise ValueError(\"Invalid transport type\") class App(object): @staticmethod def run(): # Select transport json = {\"transport_type\": \"truck\"} transport = Logistic.from_json(json) # Deliver logistic = Logistic(transport) logistic.deliver() if __name__ == \"__main__\": app = App() app.run() Factory Static Method # Example: Factory Method as a static Method class Transport(object): def __init__(self): pass def deliver(self): pass class Truck(Transport): def deliver(self): print(\"Delivering by land in a box\") class Ship(Transport): def deliver(self): print(\"Delivering by sea in a container\") class Logistic(object): def __init__(self, transport): self.transport = transport def deliver(self): self.transport.deliver() class App(object): @staticmethod def select_transport(): # Factory method # Get transport type token = input(\"Select transport type: \") # Convert to lowercase and remove whitespace transport_type = token.lower().strip(\" \\t\\n\\r\") # Factory logic if transport_type == \"truck\": return Truck() elif transport_type == \"ship\": return Ship() else: raise ValueError(\"Invalid transport type\") def run(self): # Select transport transport = self.select_transport() # Deliver logistic = Logistic(transport) logistic.deliver() if __name__ == \"__main__\": app = App() app.run() Flyweight # Exercise: Flyweight Pattern # Shared state (flyweight object) class CoffeeFlavor(object): def __init__(self, flavor): self._flavor = flavor def get_flavor(self): return self._flavor # Unique state (context object) class CoffeeOrder(object): def __init__(self, table_number, flavor): self._table_number = table_number self._flavor = flavor def serve(self): print(f\"Serving coffee to table {self._table_number} with flavor {self._flavor.get_flavor()}\") # Flyweight factory (manages the flyweight and context objects) class CoffeeShop(object): def __init__(self): # Cache for the orders and flavors self._orders = {} self._flavors = {} def take_order(self, table_number, flavor_name): # Check if the flavor instance is already cached flavor = self._flavors.get(flavor_name) # If not, create a new flavor instance and cache it if not flavor: flavor = CoffeeFlavor(flavor_name) self._flavors[flavor_name] = flavor # Create a new order with the shared flavor and unique table number order = CoffeeOrder(table_number, flavor) self._orders[table_number] = order def serve_orders(self): for table_number, order in self._orders.items(): order.serve() # Client code if __name__ == \"__main__\": # Create the coffee shop coffee_shop = CoffeeShop() # Take orders from the customers coffee_shop.take_order(1, \"Cappuccino\") coffee_shop.take_order(2, \"Espresso\") coffee_shop.take_order(3, \"Cappuccino\") coffee_shop.take_order(4, \"Espresso\") # Serve the orders coffee_shop.serve_orders() Interpreter # Example: Interpreter Pattern # Abstract Expression class Expression(object): def interpret(self, context): raise NotImplementedError # Terminal Expression class Number(Expression): def __init__(self, value): self.value = value def interpret(self, context): return self.value # Non-terminal Expression class Add(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self, context): return self.left.interpret(context) + self.right.interpret(context) # Context class Context(object): def __init__(self): self.variables = {} def set(self, variable, value): self.variables[variable] = value def get(self, variable): return self.variables.get(variable, 0) # Client code if __name__ == \"__main__\": context = Context() context.set(\"x\", 10) context.set(\"y\", 5) expression = Add( Number(context.get(\"x\")), Number(context.get(\"y\")) ) result = expression.interpret(context) print(\"Result: {}\".format(result)) Iterator # Example: Iterator Pattern # Iterator interface class Iterator(object): def has_next(self): pass def next(self): pass # TreeNode represents a node in a tree class TreeNode(object): def __init__(self, data): self.data = data self.children = [] def add_child(self, child): self.children.append(child) # Concrete Iterator for tree traversal class TreeIterator(Iterator): def __init__(self, root): self.stack = [root] def has_next(self): return len(self.stack) > 0 def next(self): if not self.has_next(): raise StopIteration() node = self.stack.pop() for child in reversed(node.children): self.stack.append(child) return node.data # Client code if __name__ == \"__main__\": # Create a sample tree structure root = TreeNode(\"Root\") child1 = TreeNode(\"Child 1\") child2 = TreeNode(\"Child 2\") child3 = TreeNode(\"Child 3\") # Add nodes to the tree root.add_child(child1) root.add_child(child2) child2.add_child(child3) # Create a tree iterator iterator = TreeIterator(root) # Traverse and print tree nodes while iterator.has_next(): node = iterator.next() print(node) Mediator # Example: Mediator Pattern # Mediator interface class Mediator(object): def forward(self, message, component): raise NotImplementedError # Concrete Mediator class Dialog(Mediator): def __init__(self): self.components = [] def set_component(self, component): self.components.append(component) def forward(self, message, sender): for component in self.components: if sender is not component: component.receive(message) # Component interface class Component(object): def __init__(self, mediator): self.mediator = mediator def send(self, message): raise NotImplementedError def receive(self, message): raise NotImplementedError # Concrete Component class Button(Component): def send(self, message): print(f\"Button sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Button receives: {message}\") # Concrete Component class Textbox(Component): def send(self, message): print(f\"Textbox sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Textbox receives: {message}\") # Concrete Component class Checkbox(Component): def send(self, message): print(f\"Checkbox sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Checkbox receives: {message}\") # Client code if __name__ == \"__main__\": # Create the mediator mediator = Dialog() # Add components to the mediator button = Button(mediator) mediator.set_component(button) # Add more components to the mediator textbox = Textbox(mediator) mediator.set_component(textbox) # Add more components to the mediator checkbox = Checkbox(mediator) mediator.set_component(checkbox) # Send messages button.send(\"Hello from Button!\") Memento # Example: Memento Pattern # Originator class class TextEditor: def __init__(self): self.content = \"\" def write(self, text): self.content += text def show_content(self): print(f\"Editor Content: {self.content}\") def create_memento(self): return TextEditorMemento(self.content) def restore_from_memento(self, memento): self.content = memento.get_state() # Memento class class TextEditorMemento: def __init__(self, content): self.content = content def get_state(self): return self.content # Caretaker class class History: def __init__(self): self.states = [] def push(self, memento): self.states.append(memento) def pop(self): if self.states: return self.states.pop() return None # Client code if __name__ == \"__main__\": text_editor = TextEditor() history = History() text_editor.write(\"Hello, \") history.push(text_editor.create_memento()) text_editor.write(\"world!\") history.push(text_editor.create_memento()) text_editor.show_content() text_editor.write(\" Hello, hello!\") text_editor.show_content() # Undo the last action last_state = history.pop() if last_state: text_editor.restore_from_memento(last_state) text_editor.show_content() Observer # Example: Observer Pattern # Subject Interface (produces data) class Publisher(object): def attach(self, observer): pass def detach(self, observer): pass def notify(self): pass # Concrete Subject class WeatherData(Publisher): def __init__(self): self.subscribers = [] self.temperature = 0.0 self.humidity = 0.0 self.pressure = 0.0 def attach(self, observer): self.subscribers.append(observer) def detach(self, observer): self.subscribers.remove(observer) def notify(self): for subscriber in self.subscribers: subscriber.update(self.temperature, self.humidity, self.pressure) def set(self, temperature, humidity, pressure): self.temperature = temperature self.humidity = humidity self.pressure = pressure self.notify() # Observer interface (consumes data) class Subscriber(object): def update(self, temperature, humidity, pressure): pass # Concrete Observer class DisplayDevice(Subscriber): def __init__(self, name): self.name = name def update(self, temperature, humidity, pressure): print( f\"{self.name} Display - Temperature: {temperature}\u00b0C, Humidity: {humidity}%, Pressure: {pressure} hPa\") # Client code if __name__ == \"__main__\": # Create a weather station weather_station = WeatherData() # Attach a display device to the weather station display1 = DisplayDevice(\"Display 1\") weather_station.attach(display1) # Attach another display device to the weather station display2 = DisplayDevice(\"Display 2\") weather_station.attach(display2) # Simulate changes in weather data weather_station.set(25.0, 60.0, 1013.0) weather_station.set(26.5, 55.0, 1010.5) Prototype # Example: Prototype Pattern from abc import ABC, abstractmethod # Prototype interface class Prototype(ABC): @abstractmethod def clone(self): pass # Concrete Prototype class Pizza(Prototype): def __init__(self, crust, cheese, toppings): self.crust = crust self.cheese = cheese self.toppings = toppings def __str__(self): return \"Crust: {0}\\nCheese: {1}\\nToppings: {2}\".format( self.crust, self.cheese, \", \".join(self.toppings) ) def clone(self): return Pizza(self.crust, self.cheese, self.toppings) if __name__ == \"__main__\": pizza = Pizza(\"thin\", \"mozzarella\", [\"pepperoni\", \"mushrooms\"]) pizza_clone = pizza.clone() print(pizza_clone) print(pizza == pizza_clone) print(pizza is pizza_clone) Proxy # Example: Proxy Pattern class Server(object): def request(self): raise NotImplementedError class RealServer(Server): def request(self): print(\"RealServer: Handling request.\") class ProxyServer(Server): def __init__(self, server: Server = None): self._server = server def request(self): if self.check_access(): self._server.request() self.log_access() @staticmethod def check_access(): print(\"ProxyServer: Checking access prior to firing a real request.\") return True @staticmethod def log_access(): print(\"ProxyServer: Logging the time of request.\", end=\"\") class Client(object): def __init__(self, server: Server): self._server = server def execute(self): self._server.request() if __name__ == \"__main__\": print(\"Client: Executing the client code with a real server\") real_server = RealServer() client = Client(server=real_server) client.execute() print(\"\") print(\"Client: Executing the same client code with a proxy server\") client = Client(server=ProxyServer(real_server)) client.execute() Singleton # Example: Singleton Pattern with __new__ class Singleton(object): __instance = None def __new__(cls): if cls.__instance is None: cls.__instance = super(Singleton, cls).__new__(cls) return cls.__instance s1 = Singleton() s2 = Singleton() print(s1 is s2) State # State interface class State(object): def connect(self): raise NotImplementedError def disconnect(self): raise NotImplementedError def send_data(self, data): raise NotImplementedError # Concrete State: Disconnected class DisconnectedState(State): def connect(self): # Action print(\"Connecting to the server...\") # Transition to the Connected state return ConnectedState() def disconnect(self): print(\"Already disconnected.\") return self def send_data(self, data): print(\"Cannot send data while disconnected.\") return self # Concrete State: Connected class ConnectedState(State): def connect(self): # Action print(\"Already connected.\") # Transition return self def disconnect(self): # Action print(\"Disconnecting from the server...\") # Transition return DisconnectedState() def send_data(self, data): # Action print(f\"Sending data to the server: {data}\") # Transition return self # Context class class Client(object): def __init__(self): # Initial state self.state = DisconnectedState() def connect(self): self.state = self.state.connect() def disconnect(self): self.state = self.state.disconnect() def send_data(self, data): self.state.send_data(data) # Client code if __name__ == \"__main__\": client = Client() client.send_data(\"Hello, server!\") # Try sending data while disconnected client.connect() client.send_data(\"Hello, server!\") # Send data after connecting client.connect() # Try connecting again client.disconnect() client.send_data(\"Goodbye, server!\") # Send data after disconnecting Strategy # Example: Strategy Pattern # Strategy interface class TextFormatter(object): def format_text(self, text): raise NotImplementedError # Concrete Strategy: Uppercase formatting class UppercaseFormatter(TextFormatter): def format_text(self, text): return text.upper() # Concrete Strategy: Lowercase formatting class LowercaseFormatter(TextFormatter): def format_text(self, text): return text.lower() # Concrete Strategy: Title case formatting class TitleCaseFormatter(TextFormatter): def format_text(self, text): return text.title() # Context class class TextEditor(object): def __init__(self, formatter): self.formatter = formatter def set_formatter(self, formatter): self.formatter = formatter def format_text(self, text): return self.formatter.format_text(text) # Client code if __name__ == \"__main__\": text = \"This is a simple example of the Strategy Pattern.\" # Create text editor with the default uppercase formatting strategy editor = TextEditor(UppercaseFormatter()) result = editor.format_text(text) print(\"Uppercase Formatting:\") print(result) # Change the formatting strategy to lowercase editor.set_formatter(LowercaseFormatter()) result = editor.format_text(text) print(\"\\nLowercase Formatting:\") print(result) # Change the formatting strategy to title case editor.set_formatter(TitleCaseFormatter()) result = editor.format_text(text) print(\"\\nTitle Case Formatting:\") print(result) Template Method # Example: Template Method Pattern # Abstract with template methods class Notification(object): # Template method def send_notification(self, message): self.authenticate() self.format_message(message) self.send_message() # Template method def authenticate(self): print(\"Authentication successful\") # Template method def format_message(self, message): print(f\"Formatting message: {message}\") # Abstract method def send_message(self): raise NotImplementedError # Concrete Notification subclass for email class EmailNotification(Notification): def send_message(self): print(\"Sending email...\") # Concrete Notification subclass for SMS class SMSNotification(Notification): def send_message(self): print(\"Sending SMS...\") # Client code if __name__ == \"__main__\": email_notification = EmailNotification() sms_notification = SMSNotification() text = \"This is a notification message.\" print(\"Email Notification:\") email_notification.send_notification(text) print(\"\\nSMS Notification:\") sms_notification.send_notification(text) Visitor # Example: Visitor Pattern class ExportVisitor(object): def visit(self, element): pass class XMLExportVisitor(ExportVisitor): def visit(self, element): print('XML exporter visiting element of type {0}'.format(type(element).__name__)) class Node(object): def accept(self, visitor): pass class City(Node): def accept(self, visitor): visitor.visit(self) class Industry(Node): def accept(self, visitor): visitor.visit(self) class NavigationMap(object): def __init__(self): self.nodes = [] def add(self, element): self.nodes.append(element) def accept(self, visitor): for element in self.nodes: element.accept(visitor) if __name__ == \"__main__\": exporter = XMLExportVisitor() object_structure = NavigationMap() object_structure.add(City()) object_structure.add(Industry()) object_structure.accept(exporter)","title":"Design Patterns"},{"location":"examples/21_design_patterns/#design-patterns","text":"","title":"Design Patterns"},{"location":"examples/21_design_patterns/#abstract-factory","text":"# Example: Abstract Factory from abc import ABC, abstractmethod class Button(ABC): # Abstract interface for buttons @abstractmethod def paint(self): raise NotImplementedError class WinButton(Button): # Concrete foo for Windows buttons def paint(self): print(\"WinButton\") class LinuxButton(Button): def paint(self): print(\"LinuxButton\") class Menu(ABC): # Abstract interface for menus @abstractmethod def paint(self): raise NotImplementedError class WinMenu(Menu): # Concrete foo for Windows menus def paint(self): print(\"WindowsMenu\") class LinuxMenu(Menu): # Concrete foo for Linux menus def paint(self): print(\"LinuxMenu\") class GUIFactory(ABC): # Abstract factory that declares a set of methods for creating each of the # products. These methods must return abstract foo types represented by # the abstract interfaces Button and Menu. @abstractmethod def create_button(self) -> Button: raise NotImplementedError @abstractmethod def create_menu(self) -> Menu: raise NotImplementedError class WinFactory(GUIFactory): # The concrete factory for Windows foo variants. def create_button(self): return WinButton() def create_menu(self): return WinMenu() class LinuxFactory(GUIFactory): # The concrete factory for Linux foo variants. def create_button(self): return LinuxButton() def create_menu(self): return LinuxMenu() if __name__ == \"__main__\": os = input(\"Select OS: \") if os == \"win\": factory = WinFactory() elif os == \"linux\": factory = LinuxFactory() else: raise ValueError(\"Invalid GUI\") # Create the GUI button = factory.create_button() menu = factory.create_menu() gui = [button, menu] # Paint the GUI for item in gui: item.paint()","title":"Abstract Factory"},{"location":"examples/21_design_patterns/#adapter-with-composition","text":"# Example: Adapter Pattern (Object Adapter) class ChannelV1(object): @staticmethod def applyConfig(): # method name from actual legacy code in the company print('Configuration method of the old device class!') class ChannelV2(object): @staticmethod def configure(): print('Configuration method of the new device class!') class ChannelAdapter(ChannelV1): # Class adapter (with composition) def __init__(self, adaptee): self.adaptee = adaptee def applyConfig(self): self.adaptee.configure() def host_app(channel): channel.applyConfig() if __name__ == \"__main__\": # Original code using the old service host_app(channel=ChannelV1()) # Use adapter for the new service adapted to the old interface host_app(channel=ChannelAdapter(adaptee=ChannelV2()))","title":"Adapter With Composition"},{"location":"examples/21_design_patterns/#adapter-with-inheritance","text":"class ChannelV1(object): @staticmethod def applyConfig(): # method name from actual legacy code in the company (Python 2.7) print('Configuration method of the old device class!') class ChannelV2(object): @staticmethod def configure(): print('Configuration method of the new device class!') class ChannelAdapter(ChannelV1, ChannelV2): # Class adapter (with inheritance) def applyConfig(self): # The adapter's applyConfig method calls the new class's configure method self.configure() def host_app(channel): # The host_app function works with the ChannelV1 interface channel.applyConfig() if __name__ == \"__main__\": # Original code using the old service (ChannelV1) host_app(channel=ChannelV1()) # Use adapter for the new service (ChannelV2) adapted to the old interface (ChannelV1) host_app(channel=ChannelAdapter())","title":"Adapter With Inheritance"},{"location":"examples/21_design_patterns/#bridge","text":"# Example: Bridge Pattern with shapes and colors class Color(object): # Interface for Implementation def __init__(self, name): self.name = name def paint(self, shape): raise NotImplementedError class Red(Color): # Concrete implementation for red color def __init__(self): super(Red, self).__init__('red') def paint(self, shape): print('Painting the {} with red color'.format(shape)) class Blue(Color): # Concrete implementation for blue color def __init__(self): super(Blue, self).__init__('blue') def paint(self, shape): print('Painting the {} with blue color'.format(shape)) class Shape(object): # This is the abstaction used by the client def __init__(self, color: Color): self.color = color def draw(self): raise NotImplementedError class Circle(Shape): # Refinded abstraction for circles def draw(self): print('Drawing a circle') self.color.paint(shape='circle') class Square(Shape): # Refined abstraction for squares def draw(self): print('Drawing a square') self.color.paint(shape='square') class DrawApp(object): # This is the client class @staticmethod def draw(shape: Shape): shape.draw() if __name__ == \"__main__\": # Draw a red circle app = DrawApp() # Draw shapes app.draw(shape=Circle(color=Red())) app.draw(shape=Square(color=Blue()))","title":"Bridge"},{"location":"examples/21_design_patterns/#builder","text":"# Example: Builder Pattern from abc import ABC, abstractmethod class Pizza(object): def __init__(self): self.crust = None self.cheese = None self.toppings = [] def __str__(self): return \"Crust: {0}\\nCheese: {1}\\nToppings: {2}\".format( self.crust, self.cheese, \", \".join(self.toppings) ) class PizzaBuilderAbc(ABC): @abstractmethod def set_crust(self, crust): pass @abstractmethod def add_cheese(self, cheese): pass @abstractmethod def add_topping(self, topping): pass @abstractmethod def build(self): pass class MyPizzaBuilder(object): def __init__(self): self.pizza = Pizza() def set_crust(self, crust): self.pizza.crust = crust return self def add_cheese(self, cheese): self.pizza.cheese = cheese return self def add_topping(self, topping): self.pizza.toppings.append(topping) return self def build(self): return self.pizza pizza = ( MyPizzaBuilder() .set_crust(\"thin\") .add_cheese(\"mozzarella\") .add_topping(\"pepperoni\") .add_topping(\"mushrooms\") .build() ) print(pizza)","title":"Builder"},{"location":"examples/21_design_patterns/#chain","text":"","title":"Chain"},{"location":"examples/21_design_patterns/#chain-of-responsibility","text":"# Example: Chain of Responsibility Pattern # Handler interface class Approver(object): def __init__(self, successor=None): self.successor = successor def set_successor(self, successor): self.successor = successor def approve(self, purchase): pass # Concrete handlers class TeamLeader(Approver): def approve(self, purchase): if purchase <= 1000: print(f\"Team Leader approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class Manager(Approver): def approve(self, purchase): if 1000 < purchase <= 5000: print(f\"Manager approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class Director(Approver): def approve(self, purchase): if 5000 < purchase <= 10000: print(f\"Director approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) class President(Approver): def approve(self, purchase): if purchase > 10000: print(f\"President approves the purchase of ${purchase}\") elif self.successor: self.successor.approve(purchase) # Client code if __name__ == \"__main__\": # Define the roles in the chain of responsibility team_leader = TeamLeader() manager = Manager() director = Director() president = President() # Set the successors team_leader.set_successor(manager) manager.set_successor(director) director.set_successor(president) # Create purchases purchases = [500, 1000, 2000, 5000, 10000, 20000] # Process the purchases for purchase in purchases: team_leader.approve(purchase)","title":"Chain Of Responsibility"},{"location":"examples/21_design_patterns/#command","text":"# Example: Command Pattern # Command interface class Command(object): def execute(self): pass def undo(self): pass # Concrete commands class TypeCommand(Command): def __init__(self, text, document): self.text = text self.document = document def execute(self): self.document.add_text(self.text) def undo(self): self.document.remove_text(self.text) # Receiver class class Document(object): def __init__(self): self.content = \"\" def add_text(self, text): self.content += text def remove_text(self, text): if text and text in self.content: self.content = self.content.replace(text, \"\", 1) def get_content(self): return self.content # Invoker class (TextEditor) class TextEditor(object): def __init__(self): self.history = [] def execute(self, command): command.execute() self.history.append(command) def undo_last_command(self): if self.history: command = self.history.pop() command.undo() # Client code if __name__ == \"__main__\": document = Document() editor = TextEditor() print(\"Initial content:\", document.get_content()) # Type some text type_action1 = TypeCommand(\"Hello, \", document) editor.execute(type_action1) print(\"After typing:\", document.get_content()) type_action2 = TypeCommand(\"world!\", document) editor.execute(type_action2) print(\"After typing:\", document.get_content()) # Undo the last command editor.undo_last_command() print(\"After undo:\", document.get_content())","title":"Command"},{"location":"examples/21_design_patterns/#composite","text":"# Example: Composite pattern from abc import abstractmethod class IComponent(object): # Interface used by both the leaf and composite classes def __init__(self, name): self.name = name @abstractmethod def execute(self): raise NotImplementedError class Leaf(IComponent): def execute(self): return \"{} running\".format(self.name) # Concrete implementation of the composite class class Composite(IComponent): # This is the composite class (tree is composed of leafs) def __init__(self, name=\"Root\"): super(Composite, self).__init__(name) self.components = [] def add(self, c): self.components.append(c) return self def remove(self, c): self.components.remove(c) return self def get_children(self): return self.components def execute(self): # Delegate work to all the children for child in self.components: print(\"{} / {}\".format(self.name, child.execute())) return \"{} running\".format(self.name) if __name__ == \"__main__\": # Define composite foo product = Composite() product.add(Leaf(\"Leaf 1\")) product.add(Leaf(\"Leaf 2\")) print(product.execute()) print() # Nested composite foo product.add( Composite(\"Subsystem A\") .add(Leaf(\"Leaf 1\")) .add(Leaf(\"Leaf 2\")) ) print(product.execute())","title":"Composite"},{"location":"examples/21_design_patterns/#decorator","text":"# Example: Decorator Pattern from abc import ABC, abstractmethod class NotifierAbc(ABC): @abstractmethod def notify(self): pass class Notifier(NotifierAbc): def notify(self): print(\"Print on screen ...\") class NotifierDecorator(NotifierAbc): def __init__(self, component): self._component = component @abstractmethod def notify(self): pass class EmailNotifier(NotifierDecorator): @staticmethod def send_email(): print(\"Sending email ...\") def notify(self): self.send_email() self._component.notify() class SMSNotifier(NotifierDecorator): @staticmethod def send_sms(): print(\"Sending SMS ...\") def notify(self): self.send_sms() self._component.notify() def main(): notifier = Notifier() notifier_with_email = EmailNotifier(notifier) notifier_with_email_and_sms = SMSNotifier(notifier_with_email) notifier_with_email_and_sms.notify() if __name__ == \"__main__\": main()","title":"Decorator"},{"location":"examples/21_design_patterns/#facade","text":"# Example: Facade Pattern class PumpSystem(object): @staticmethod def prepare(): print(\"SubsystemA prepare ...\") @staticmethod def run(): print(\"SubsystemA run ...\") class VentilationSystem(object): @staticmethod def prepare(): print(\"SubsystemB prepare ...\") @staticmethod def run(): print(\"SubsystemB run ...\") class ComplexSystemFacade(object): def __init__(self): self._subsystemA = PumpSystem() self._subsystemB = VentilationSystem() def run(self): self._subsystemA.prepare() self._subsystemB.prepare() self._subsystemA.run() self._subsystemB.run() def main(): system = ComplexSystemFacade() system.run() if __name__ == \"__main__\": main()","title":"Facade"},{"location":"examples/21_design_patterns/#factory-class-method","text":"# Example: Factory Method as a class method class Transport(object): def __init__(self): pass def deliver(self): pass class Truck(Transport): def deliver(self): print(\"Delivering by land in a box\") class Ship(Transport): def deliver(self): print(\"Delivering by sea in a container\") class Logistic(object): def __init__(self, transport): self.transport = transport def deliver(self): self.transport.deliver() @classmethod def from_json(cls, json): # Factory method # Get transport type token = json.get(\"transport_type\") # Convert to lowercase and remove whitespace transport_type = token.lower().strip(\" \\t\\n\\r\") # Factory logic if transport_type == \"truck\": return Truck() elif transport_type == \"ship\": return Ship() else: raise ValueError(\"Invalid transport type\") class App(object): @staticmethod def run(): # Select transport json = {\"transport_type\": \"truck\"} transport = Logistic.from_json(json) # Deliver logistic = Logistic(transport) logistic.deliver() if __name__ == \"__main__\": app = App() app.run()","title":"Factory Class Method"},{"location":"examples/21_design_patterns/#factory-static-method","text":"# Example: Factory Method as a static Method class Transport(object): def __init__(self): pass def deliver(self): pass class Truck(Transport): def deliver(self): print(\"Delivering by land in a box\") class Ship(Transport): def deliver(self): print(\"Delivering by sea in a container\") class Logistic(object): def __init__(self, transport): self.transport = transport def deliver(self): self.transport.deliver() class App(object): @staticmethod def select_transport(): # Factory method # Get transport type token = input(\"Select transport type: \") # Convert to lowercase and remove whitespace transport_type = token.lower().strip(\" \\t\\n\\r\") # Factory logic if transport_type == \"truck\": return Truck() elif transport_type == \"ship\": return Ship() else: raise ValueError(\"Invalid transport type\") def run(self): # Select transport transport = self.select_transport() # Deliver logistic = Logistic(transport) logistic.deliver() if __name__ == \"__main__\": app = App() app.run()","title":"Factory Static Method"},{"location":"examples/21_design_patterns/#flyweight","text":"# Exercise: Flyweight Pattern # Shared state (flyweight object) class CoffeeFlavor(object): def __init__(self, flavor): self._flavor = flavor def get_flavor(self): return self._flavor # Unique state (context object) class CoffeeOrder(object): def __init__(self, table_number, flavor): self._table_number = table_number self._flavor = flavor def serve(self): print(f\"Serving coffee to table {self._table_number} with flavor {self._flavor.get_flavor()}\") # Flyweight factory (manages the flyweight and context objects) class CoffeeShop(object): def __init__(self): # Cache for the orders and flavors self._orders = {} self._flavors = {} def take_order(self, table_number, flavor_name): # Check if the flavor instance is already cached flavor = self._flavors.get(flavor_name) # If not, create a new flavor instance and cache it if not flavor: flavor = CoffeeFlavor(flavor_name) self._flavors[flavor_name] = flavor # Create a new order with the shared flavor and unique table number order = CoffeeOrder(table_number, flavor) self._orders[table_number] = order def serve_orders(self): for table_number, order in self._orders.items(): order.serve() # Client code if __name__ == \"__main__\": # Create the coffee shop coffee_shop = CoffeeShop() # Take orders from the customers coffee_shop.take_order(1, \"Cappuccino\") coffee_shop.take_order(2, \"Espresso\") coffee_shop.take_order(3, \"Cappuccino\") coffee_shop.take_order(4, \"Espresso\") # Serve the orders coffee_shop.serve_orders()","title":"Flyweight"},{"location":"examples/21_design_patterns/#interpreter","text":"# Example: Interpreter Pattern # Abstract Expression class Expression(object): def interpret(self, context): raise NotImplementedError # Terminal Expression class Number(Expression): def __init__(self, value): self.value = value def interpret(self, context): return self.value # Non-terminal Expression class Add(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self, context): return self.left.interpret(context) + self.right.interpret(context) # Context class Context(object): def __init__(self): self.variables = {} def set(self, variable, value): self.variables[variable] = value def get(self, variable): return self.variables.get(variable, 0) # Client code if __name__ == \"__main__\": context = Context() context.set(\"x\", 10) context.set(\"y\", 5) expression = Add( Number(context.get(\"x\")), Number(context.get(\"y\")) ) result = expression.interpret(context) print(\"Result: {}\".format(result))","title":"Interpreter"},{"location":"examples/21_design_patterns/#iterator","text":"# Example: Iterator Pattern # Iterator interface class Iterator(object): def has_next(self): pass def next(self): pass # TreeNode represents a node in a tree class TreeNode(object): def __init__(self, data): self.data = data self.children = [] def add_child(self, child): self.children.append(child) # Concrete Iterator for tree traversal class TreeIterator(Iterator): def __init__(self, root): self.stack = [root] def has_next(self): return len(self.stack) > 0 def next(self): if not self.has_next(): raise StopIteration() node = self.stack.pop() for child in reversed(node.children): self.stack.append(child) return node.data # Client code if __name__ == \"__main__\": # Create a sample tree structure root = TreeNode(\"Root\") child1 = TreeNode(\"Child 1\") child2 = TreeNode(\"Child 2\") child3 = TreeNode(\"Child 3\") # Add nodes to the tree root.add_child(child1) root.add_child(child2) child2.add_child(child3) # Create a tree iterator iterator = TreeIterator(root) # Traverse and print tree nodes while iterator.has_next(): node = iterator.next() print(node)","title":"Iterator"},{"location":"examples/21_design_patterns/#mediator","text":"# Example: Mediator Pattern # Mediator interface class Mediator(object): def forward(self, message, component): raise NotImplementedError # Concrete Mediator class Dialog(Mediator): def __init__(self): self.components = [] def set_component(self, component): self.components.append(component) def forward(self, message, sender): for component in self.components: if sender is not component: component.receive(message) # Component interface class Component(object): def __init__(self, mediator): self.mediator = mediator def send(self, message): raise NotImplementedError def receive(self, message): raise NotImplementedError # Concrete Component class Button(Component): def send(self, message): print(f\"Button sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Button receives: {message}\") # Concrete Component class Textbox(Component): def send(self, message): print(f\"Textbox sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Textbox receives: {message}\") # Concrete Component class Checkbox(Component): def send(self, message): print(f\"Checkbox sends: {message}\") self.mediator.forward(message, self) def receive(self, message): print(f\"Checkbox receives: {message}\") # Client code if __name__ == \"__main__\": # Create the mediator mediator = Dialog() # Add components to the mediator button = Button(mediator) mediator.set_component(button) # Add more components to the mediator textbox = Textbox(mediator) mediator.set_component(textbox) # Add more components to the mediator checkbox = Checkbox(mediator) mediator.set_component(checkbox) # Send messages button.send(\"Hello from Button!\")","title":"Mediator"},{"location":"examples/21_design_patterns/#memento","text":"# Example: Memento Pattern # Originator class class TextEditor: def __init__(self): self.content = \"\" def write(self, text): self.content += text def show_content(self): print(f\"Editor Content: {self.content}\") def create_memento(self): return TextEditorMemento(self.content) def restore_from_memento(self, memento): self.content = memento.get_state() # Memento class class TextEditorMemento: def __init__(self, content): self.content = content def get_state(self): return self.content # Caretaker class class History: def __init__(self): self.states = [] def push(self, memento): self.states.append(memento) def pop(self): if self.states: return self.states.pop() return None # Client code if __name__ == \"__main__\": text_editor = TextEditor() history = History() text_editor.write(\"Hello, \") history.push(text_editor.create_memento()) text_editor.write(\"world!\") history.push(text_editor.create_memento()) text_editor.show_content() text_editor.write(\" Hello, hello!\") text_editor.show_content() # Undo the last action last_state = history.pop() if last_state: text_editor.restore_from_memento(last_state) text_editor.show_content()","title":"Memento"},{"location":"examples/21_design_patterns/#observer","text":"# Example: Observer Pattern # Subject Interface (produces data) class Publisher(object): def attach(self, observer): pass def detach(self, observer): pass def notify(self): pass # Concrete Subject class WeatherData(Publisher): def __init__(self): self.subscribers = [] self.temperature = 0.0 self.humidity = 0.0 self.pressure = 0.0 def attach(self, observer): self.subscribers.append(observer) def detach(self, observer): self.subscribers.remove(observer) def notify(self): for subscriber in self.subscribers: subscriber.update(self.temperature, self.humidity, self.pressure) def set(self, temperature, humidity, pressure): self.temperature = temperature self.humidity = humidity self.pressure = pressure self.notify() # Observer interface (consumes data) class Subscriber(object): def update(self, temperature, humidity, pressure): pass # Concrete Observer class DisplayDevice(Subscriber): def __init__(self, name): self.name = name def update(self, temperature, humidity, pressure): print( f\"{self.name} Display - Temperature: {temperature}\u00b0C, Humidity: {humidity}%, Pressure: {pressure} hPa\") # Client code if __name__ == \"__main__\": # Create a weather station weather_station = WeatherData() # Attach a display device to the weather station display1 = DisplayDevice(\"Display 1\") weather_station.attach(display1) # Attach another display device to the weather station display2 = DisplayDevice(\"Display 2\") weather_station.attach(display2) # Simulate changes in weather data weather_station.set(25.0, 60.0, 1013.0) weather_station.set(26.5, 55.0, 1010.5)","title":"Observer"},{"location":"examples/21_design_patterns/#prototype","text":"# Example: Prototype Pattern from abc import ABC, abstractmethod # Prototype interface class Prototype(ABC): @abstractmethod def clone(self): pass # Concrete Prototype class Pizza(Prototype): def __init__(self, crust, cheese, toppings): self.crust = crust self.cheese = cheese self.toppings = toppings def __str__(self): return \"Crust: {0}\\nCheese: {1}\\nToppings: {2}\".format( self.crust, self.cheese, \", \".join(self.toppings) ) def clone(self): return Pizza(self.crust, self.cheese, self.toppings) if __name__ == \"__main__\": pizza = Pizza(\"thin\", \"mozzarella\", [\"pepperoni\", \"mushrooms\"]) pizza_clone = pizza.clone() print(pizza_clone) print(pizza == pizza_clone) print(pizza is pizza_clone)","title":"Prototype"},{"location":"examples/21_design_patterns/#proxy","text":"# Example: Proxy Pattern class Server(object): def request(self): raise NotImplementedError class RealServer(Server): def request(self): print(\"RealServer: Handling request.\") class ProxyServer(Server): def __init__(self, server: Server = None): self._server = server def request(self): if self.check_access(): self._server.request() self.log_access() @staticmethod def check_access(): print(\"ProxyServer: Checking access prior to firing a real request.\") return True @staticmethod def log_access(): print(\"ProxyServer: Logging the time of request.\", end=\"\") class Client(object): def __init__(self, server: Server): self._server = server def execute(self): self._server.request() if __name__ == \"__main__\": print(\"Client: Executing the client code with a real server\") real_server = RealServer() client = Client(server=real_server) client.execute() print(\"\") print(\"Client: Executing the same client code with a proxy server\") client = Client(server=ProxyServer(real_server)) client.execute()","title":"Proxy"},{"location":"examples/21_design_patterns/#singleton","text":"# Example: Singleton Pattern with __new__ class Singleton(object): __instance = None def __new__(cls): if cls.__instance is None: cls.__instance = super(Singleton, cls).__new__(cls) return cls.__instance s1 = Singleton() s2 = Singleton() print(s1 is s2)","title":"Singleton"},{"location":"examples/21_design_patterns/#state","text":"# State interface class State(object): def connect(self): raise NotImplementedError def disconnect(self): raise NotImplementedError def send_data(self, data): raise NotImplementedError # Concrete State: Disconnected class DisconnectedState(State): def connect(self): # Action print(\"Connecting to the server...\") # Transition to the Connected state return ConnectedState() def disconnect(self): print(\"Already disconnected.\") return self def send_data(self, data): print(\"Cannot send data while disconnected.\") return self # Concrete State: Connected class ConnectedState(State): def connect(self): # Action print(\"Already connected.\") # Transition return self def disconnect(self): # Action print(\"Disconnecting from the server...\") # Transition return DisconnectedState() def send_data(self, data): # Action print(f\"Sending data to the server: {data}\") # Transition return self # Context class class Client(object): def __init__(self): # Initial state self.state = DisconnectedState() def connect(self): self.state = self.state.connect() def disconnect(self): self.state = self.state.disconnect() def send_data(self, data): self.state.send_data(data) # Client code if __name__ == \"__main__\": client = Client() client.send_data(\"Hello, server!\") # Try sending data while disconnected client.connect() client.send_data(\"Hello, server!\") # Send data after connecting client.connect() # Try connecting again client.disconnect() client.send_data(\"Goodbye, server!\") # Send data after disconnecting","title":"State"},{"location":"examples/21_design_patterns/#strategy","text":"# Example: Strategy Pattern # Strategy interface class TextFormatter(object): def format_text(self, text): raise NotImplementedError # Concrete Strategy: Uppercase formatting class UppercaseFormatter(TextFormatter): def format_text(self, text): return text.upper() # Concrete Strategy: Lowercase formatting class LowercaseFormatter(TextFormatter): def format_text(self, text): return text.lower() # Concrete Strategy: Title case formatting class TitleCaseFormatter(TextFormatter): def format_text(self, text): return text.title() # Context class class TextEditor(object): def __init__(self, formatter): self.formatter = formatter def set_formatter(self, formatter): self.formatter = formatter def format_text(self, text): return self.formatter.format_text(text) # Client code if __name__ == \"__main__\": text = \"This is a simple example of the Strategy Pattern.\" # Create text editor with the default uppercase formatting strategy editor = TextEditor(UppercaseFormatter()) result = editor.format_text(text) print(\"Uppercase Formatting:\") print(result) # Change the formatting strategy to lowercase editor.set_formatter(LowercaseFormatter()) result = editor.format_text(text) print(\"\\nLowercase Formatting:\") print(result) # Change the formatting strategy to title case editor.set_formatter(TitleCaseFormatter()) result = editor.format_text(text) print(\"\\nTitle Case Formatting:\") print(result)","title":"Strategy"},{"location":"examples/21_design_patterns/#template-method","text":"# Example: Template Method Pattern # Abstract with template methods class Notification(object): # Template method def send_notification(self, message): self.authenticate() self.format_message(message) self.send_message() # Template method def authenticate(self): print(\"Authentication successful\") # Template method def format_message(self, message): print(f\"Formatting message: {message}\") # Abstract method def send_message(self): raise NotImplementedError # Concrete Notification subclass for email class EmailNotification(Notification): def send_message(self): print(\"Sending email...\") # Concrete Notification subclass for SMS class SMSNotification(Notification): def send_message(self): print(\"Sending SMS...\") # Client code if __name__ == \"__main__\": email_notification = EmailNotification() sms_notification = SMSNotification() text = \"This is a notification message.\" print(\"Email Notification:\") email_notification.send_notification(text) print(\"\\nSMS Notification:\") sms_notification.send_notification(text)","title":"Template Method"},{"location":"examples/21_design_patterns/#visitor","text":"# Example: Visitor Pattern class ExportVisitor(object): def visit(self, element): pass class XMLExportVisitor(ExportVisitor): def visit(self, element): print('XML exporter visiting element of type {0}'.format(type(element).__name__)) class Node(object): def accept(self, visitor): pass class City(Node): def accept(self, visitor): visitor.visit(self) class Industry(Node): def accept(self, visitor): visitor.visit(self) class NavigationMap(object): def __init__(self): self.nodes = [] def add(self, element): self.nodes.append(element) def accept(self, visitor): for element in self.nodes: element.accept(visitor) if __name__ == \"__main__\": exporter = XMLExportVisitor() object_structure = NavigationMap() object_structure.add(City()) object_structure.add(Industry()) object_structure.accept(exporter)","title":"Visitor"},{"location":"examples/23_meta_classes/","text":"Meta Classes Demo Abstract from abc import ABCMeta, abstractmethod from six import with_metaclass class DeviceAbc(with_metaclass(ABCMeta)): @abstractmethod def foo(self): pass class Device(DeviceAbc): def foo(self): pass a = Device() Demo Basic # Two-step metaclass creation in Python 3.x from six import with_metaclass class SimpleMeta1(type): def __init__(cls, name, bases, namespace): super(SimpleMeta1, cls).__init__(name, bases, namespace) # Print the methods and attributes found at the parsing stage print(name, bases, namespace) # Create a method called uses_metaclass returning junior simple string object cls.uses_metaclass = lambda self: 'Added by the meta-class' class Simple1(object, with_metaclass(SimpleMeta1)): # Add junior instance method to the namespace def foo(self): pass # Add junior static function to the namespace @staticmethod def bar(): pass # Create the class simple = Simple1() # Expect 3 methods after the meta-class was executed print([m for m in dir(simple) if not m.startswith('__')]) # Execute the method added by the meta-class print(simple.uses_metaclass()) Demo Conflict from six import with_metaclass class MetaClassA(type): pass class MetaClassB(type): pass class A(object, with_metaclass(MetaClassA)): pass class B(object, with_metaclass(MetaClassB)): pass try: class C1(A, B): pass except Exception as e: print(e) class MetaClassC(MetaClassA, MetaClassB): pass class C2(A, B, with_metaclass(MetaClassC)): pass Demo Debug # coding=utf-8 \"\"\" __new__ is called for the creation of a new class, while __init__ is called after the class is created, to perform additional initialization before the class is handed to the caller. The primary difference is that when overriding __new__() you can change things like the \u2018name\u2019, \u2018bases\u2019 and \u2018namespace\u2019 arguments before you call the super constructor and it will have an effect, but doing the same thing in __init__() you won\u2019t get any results from the constructor call. \"\"\" from collections import OrderedDict import time class DebugMeta(type): @classmethod def __prepare__(cls, name, bases): namespace = OrderedDict() namespace[\"owner\"] = \"Branimir Georgiev\" print(\"Preparing namespace dictionary {0}\".format(namespace)) return namespace def __new__(mcs, name, bases, namespace): x = super(DebugMeta, mcs).__new__(mcs, name, bases, namespace) print(\"Creating new class {0}\".format(x)) x.timestamp = time.time() return x def __init__(cls, name, bases, namespace): print(\"Class initialization\") super(DebugMeta, cls).__init__(name, bases, namespace) cls.access = \"rw\" def __call__(cls, *args, **kwargs): print(\"Class call\") return super(DebugMeta, cls).__call__(*args, **kwargs) def __del__(self): print(\"Class deleted\") class Base(metaclass=DebugMeta): def __init__(self, *args, **kwargs): super(Base, self).__init__(*args, **kwargs) print(\"Instance initialization {0}\".format(vars(self))) def __new__(cls, *args, **kwargs): x = super(Base, cls).__new__(cls, *args, **kwargs) print(\"Creating new instance {0}\".format(x)) return x def __call__(self, *args, **kwargs): print(\"Instance called args={0} and kwargs={1}\".format(args, kwargs)) def __del__(self): print(\"Instance deleted\") config = {\"a\":1, \"b\":2} test = Base() test(1, test=2) Demo Declarative API # https://developer.ibm.com/technologies/analytics/tutorials/ba-metaprogramming-python/ # # >>> from from django.db import models # >>> class Vehicle(models.Model): # ... color = models.CharField(max_length=10) # ... wheels = models.IntegerField() # >>> four_wheeler = Vehicle(color=\"Blue\", wheels=\"Four\") # Raises an error # >>> four_wheeler = Vehicle(color=\"Blue\", wheels=4) # >>> four_wheeler.wheels # 4 from collections import OrderedDict from six import with_metaclass class MyStore(object): \"\"\"Store keeping track of singleton instances.\"\"\" def __init__(self): self.store = {} def __str__(self): return str({key: str(value) for key, value in self.store.items()}) def register(self, name, obj): self.store[name] = obj store = MyStore() class MyField(str): pass class MyMeta(type): \"\"\" Example of metaclass demonstrating some of the classical features that such a construct can provide: class alteration and registration. \"\"\" @staticmethod def __prepare__(): return OrderedDict() def __new__(mcs, class_name, class_bases, class_attrs): # Reorganizing attributes: reorganized_attrs = OrderedDict([('_fields', OrderedDict()), ('_constants', OrderedDict())]) for name, attr in class_attrs.items(): if isinstance(attr, MyField): reorganized_attrs['_fields'][name] = attr elif not name.startswith('__') and not callable(attr): reorganized_attrs['_constants'][name] = attr else: reorganized_attrs[name] = attr # Creating the class: cls = type.__new__(mcs, class_name, class_bases, reorganized_attrs) # Initializing the singleton pattern: obj = cls() cls._obj = obj # Registering the new object: store.register(class_name, obj) # Displaying the results of the application of the metaclass: print(\"Here is what {} contains:\".format(cls.__name__)) for name, attr in cls.__dict__.items(): print(\" . {}: {}\".format(name, attr)) print(\"\") return cls def __call__(cls, *args, **kwargs): \"\"\"Implementing the singleton pattern at class call.\"\"\" if not hasattr(cls, '_obj'): obj = super(MyMeta, cls).__call__(*args, **kwargs) obj.__init__(*args, **kwargs) return obj else: return cls._obj class MyClass(with_metaclass(MyMeta)): \"\"\"Example of a user-defined (client) class that makes use of MyMeta.\"\"\" # Demo attributes (mixed fields and constants) a = 42 b = MyField('foo') c = MyField('bar') d = 'Field' in globals() def __str__(self): \"\"\"Showing the memory address of self (proving it is junior singleton).\"\"\" return \"I'm located at: {}\".format(id(self)) test_instance = MyClass() print(test_instance) other_instance = MyClass() print(\"Once again\", other_instance) print(\"The store is:\", store) Demo Decorator # https://cleverdevil.io/2009/python-metaclasses-demystified import inspect from six import with_metaclass class AutoDecorateMeta(type): def __init__(cls, name, bases, namespace): super(AutoDecorateMeta, cls).__init__(name, bases, namespace) deco = namespace.get('decorator', lambda f: f) for key, value in namespace.items(): # skip the decorator and constructor if key in ('decorator', '__init__'): continue # skip objects in the namespace that aren't methods if not inspect.isfunction(value): continue # apply the decorator setattr(cls, key, deco(value)) class Person(object, with_metaclass(AutoDecorateMeta)): # Decorator selector decorator = property def __init__(self, first, middle, last): self.first = first self.middle = middle self.last = last # Will be decorated def name(self): return '%s %s' % (self.first, self.last) # Will be decorated def full_name(self): return '%s %s %s' % (self.first, self.middle, self.last) # Will be decorated def initials(self): return '%s%s%s' % (self.first[0], self.middle[0], self.last[0]) mlk = Person('Martin', 'Luther', 'King') # Usual way to use name is as method # mlk.name() # Auto-decorated class converted method to property print(mlk.name) print(mlk.full_name) print(mlk.initials) Demo Final from six import with_metaclass class Final(type): def __init__(cls, name, bases, namespace): super(Final, cls).__init__(name, bases, namespace) for klass in bases: if isinstance(klass, Final): raise TypeError(str(klass.__name__) + \" is final\") class A(object, with_metaclass(Final)): A = 1 def a(self): pass class B(A): B = 1 def b(self): pass a = A() print(a) b = B() print(b) Demo GUI ############################################################################## # Window # > Box # > Label ############################################################################## ############################################################################## # Imperative programming ############################################################################## class Box(object): def add(self, what): pass class Label(object): def __init__(self, label=\"\"): self.label = label def add(self): pass class Window(object): def __init__(self, title=\"Window element\"): self.title = title self.box = Box() self.add(self.box) self.label = Label(label=\"Hello, label!\") self.box.add(self.label) def add(self, what): pass ############################################################################## # Declarative programming ############################################################################## class Top(Window): title = \"Hello, window!\" class Group(Box): class Title(Label): label = '\"Hello, label!\"' ############################################################################## # Solution??? ############################################################################## Demo Indexing from six import with_metaclass ############################################################################## # Metaclass definition ############################################################################## class Indexer(type): def __init__(cls, name, bases, namespace): super(Indexer, cls).__init__(name, bases, namespace) if not hasattr(cls, \"subclasses\"): cls.subclasses = [] if not hasattr(cls, \"index\"): cls.index = 0 # Index only subclasses for b in bases: if isinstance(b, Indexer): cls.subclasses.append(1) cls.index = len(cls.subclasses) ############################################################################## # First base class and subclasses ############################################################################## class A(with_metaclass(Indexer)): pass class A1(A): pass class A2(A): pass print(A.index, A1.index, A2.index) ############################################################################## # Second base class and subclasses ############################################################################## class B(with_metaclass(Indexer)): pass class B1(B): pass class B2(B): pass print(B.index, B1.index, B2.index) Demo Registrar from six import with_metaclass ############################################################################## # EXAMPLE 1 : Register leaf classes and count them ############################################################################## # 1. Metaclass definition class RegisterLeafClasses(type): def __init__(cls, name, bases, namespace): super(RegisterLeafClasses, cls).__init__(name, bases, namespace) if not hasattr(cls, 'registry'): cls.registry = set() cls.registry.add(cls) cls.registry -= set(bases) # Remove base classes # Class property @property def count(cls): return len(cls.registry) # Metamethods, called on class objects: def __iter__(cls): return iter(cls.registry) def __str__(cls): if cls in cls.registry: return cls.__name__ return cls.__name__ + \": \" + \", \".join([sc.__name__ for sc in cls]) # 2. Custom root class class Color(object, with_metaclass(RegisterLeafClasses)): pass # 3. Derived classes class Blue(Color): pass class Red(Color): pass class Green(Color): pass class Yellow(Color): pass print(Color) # 4. Tests class PhthaloBlue(Blue): pass class CeruleanBlue(Blue): pass print(Color) for c in Color: # Iterate over subclasses print(c) print(Color.count) ############################################################################## # EXAMPLE 2 : Example from Hilscher Framework ############################################################################## class Registrar(type): \"\"\" A meta class used to generate a list of all subclasses of a class \"\"\" def __init__(cls, name, bases, dct): super(Registrar, cls).__init__(name, bases, dct) cls.register(cls) @classmethod def list(mcs): for attrib in getattr(mcs, 'classes', tuple()): yield attrib # Metamethod used to register classes @classmethod def register(mcs, cls): try: # Create reference to classes attribute classes = mcs.classes except AttributeError: # Create classes attribute and create reference classes = mcs.classes = [] mcs.count = 0 # Use reference to populate registry classes.append(cls) class ClassToRegister1(object, with_metaclass(Registrar)): pass class ClassToRegister2(ClassToRegister1): pass a = ClassToRegister1() b = ClassToRegister2() for x in Registrar.list(): print(x) Demo Reloading from six import with_metaclass \"\"\" Scenario : At Hilscher the test framework uses meta-classes to scan for devices with open channels. If 2 or more device classes are found, then the network creates a new class with all device classes as base classes. This leads to a problem as the order the device classes are found is not always guaranteed. Solution: Use custom device class to ensure the right methods are used for the respective device \"\"\" class ReloadMeta(type): registry = {} def __new__(mcs, class_name, bases, namespace): module_name = namespace['__module__'] try: current = mcs.registry[module_name][class_name] except KeyError: current = None if current: mcs.regenerate(current, namespace) return current cls = type.__new__(mcs, class_name, bases, namespace) mcs.registry.setdefault(module_name, {})[class_name] = cls return cls def regenerate(cls, namespace): print(\"Reloading class %s\" % cls) for name in list(cls.__dict__.keys()): if name in ['__name__', '__metaclass__', '__module__', '__dict__', '__weakref__', '__bases__']: continue delattr(cls, name) for name, value in namespace.items(): setattr(cls, name, value) return cls if __name__ == '__main__': # First class with method test class C(object, with_metaclass(ReloadMeta)): def test(self): print('first {0}'.format(self)) c = C() c.test() # Second class with new method test class C(object, with_metaclass(ReloadMeta)): def test(self): print('second {0}'.format(self)) c.test() Demo Singleton # coding=utf-8 \"\"\" By overriding __call__() in the metaclass, the creation of instances are intercepted. Instance creation is bypassed if one already exists. Note the dependence upon the behavior of static class fields. When cls.instance is first read, it gets the static value of instance from the metaclass, which is None. However, when the assignment is made, Python creates a local version for the particular class, and the next time cls.instance is read, it sees that local version. Because of this behavior, each class ends up with its own class-specific instance field (thus instance is not somehow being \u201cinherited\u201d from the metaclass). \"\"\" class Singleton(type): instance = None def __call__(cls, *args, **kwargs): if not cls.instance: cls.instance = super(Singleton, cls).__call__(*args, **kwargs) return cls.instance class ASingleton(object, metaclass=Singleton): pass a = ASingleton() b = ASingleton() assert a is b print(a.__class__.__name__, b.__class__.__name__) print(id(a), id(b)) Demo Typed from six import with_metaclass # Create metaclass class MyMetaClass(type): def __init__(cls, name, bases, namespace): super(MyMetaClass, cls).__init__(name, bases, namespace) # Create first custom class from metaclass class A(object, with_metaclass(MyMetaClass)): A = 1 def __init__(self, param=1): self.a = param @staticmethod def configure(): print(\"A\") # Create second custom class from metaclass class B(object, with_metaclass(MyMetaClass)): B = 2 def __init__(self, param=1): self.b = param @staticmethod def configure(): print(\"B\") # Show that order of super classes determines class behavior # -> Inherits combined class attributes but instance attrib/methods from A D = MyMetaClass('D', (A, B), {}) test = D() print(vars(test)) test.configure() # -> Inherits combined class attributes but instance attrib/methods from B D = MyMetaClass('D', (B, A), {}) test = D() print(vars(test)) test.configure() # -> Solution when multiple inheritance problems (due to bad design, etc.) # Recast class type test = B(test) pass Snippets namespace = globals() abstracts = set(name for name, value in namespace.items() if getattr(value, \"__isabstractmethod__\", False)) print(abstracts)","title":"Meta Classes"},{"location":"examples/23_meta_classes/#meta-classes","text":"","title":"Meta Classes"},{"location":"examples/23_meta_classes/#demo-abstract","text":"from abc import ABCMeta, abstractmethod from six import with_metaclass class DeviceAbc(with_metaclass(ABCMeta)): @abstractmethod def foo(self): pass class Device(DeviceAbc): def foo(self): pass a = Device()","title":"Demo Abstract"},{"location":"examples/23_meta_classes/#demo-basic","text":"# Two-step metaclass creation in Python 3.x from six import with_metaclass class SimpleMeta1(type): def __init__(cls, name, bases, namespace): super(SimpleMeta1, cls).__init__(name, bases, namespace) # Print the methods and attributes found at the parsing stage print(name, bases, namespace) # Create a method called uses_metaclass returning junior simple string object cls.uses_metaclass = lambda self: 'Added by the meta-class' class Simple1(object, with_metaclass(SimpleMeta1)): # Add junior instance method to the namespace def foo(self): pass # Add junior static function to the namespace @staticmethod def bar(): pass # Create the class simple = Simple1() # Expect 3 methods after the meta-class was executed print([m for m in dir(simple) if not m.startswith('__')]) # Execute the method added by the meta-class print(simple.uses_metaclass())","title":"Demo Basic"},{"location":"examples/23_meta_classes/#demo-conflict","text":"from six import with_metaclass class MetaClassA(type): pass class MetaClassB(type): pass class A(object, with_metaclass(MetaClassA)): pass class B(object, with_metaclass(MetaClassB)): pass try: class C1(A, B): pass except Exception as e: print(e) class MetaClassC(MetaClassA, MetaClassB): pass class C2(A, B, with_metaclass(MetaClassC)): pass","title":"Demo Conflict"},{"location":"examples/23_meta_classes/#demo-debug","text":"# coding=utf-8 \"\"\" __new__ is called for the creation of a new class, while __init__ is called after the class is created, to perform additional initialization before the class is handed to the caller. The primary difference is that when overriding __new__() you can change things like the \u2018name\u2019, \u2018bases\u2019 and \u2018namespace\u2019 arguments before you call the super constructor and it will have an effect, but doing the same thing in __init__() you won\u2019t get any results from the constructor call. \"\"\" from collections import OrderedDict import time class DebugMeta(type): @classmethod def __prepare__(cls, name, bases): namespace = OrderedDict() namespace[\"owner\"] = \"Branimir Georgiev\" print(\"Preparing namespace dictionary {0}\".format(namespace)) return namespace def __new__(mcs, name, bases, namespace): x = super(DebugMeta, mcs).__new__(mcs, name, bases, namespace) print(\"Creating new class {0}\".format(x)) x.timestamp = time.time() return x def __init__(cls, name, bases, namespace): print(\"Class initialization\") super(DebugMeta, cls).__init__(name, bases, namespace) cls.access = \"rw\" def __call__(cls, *args, **kwargs): print(\"Class call\") return super(DebugMeta, cls).__call__(*args, **kwargs) def __del__(self): print(\"Class deleted\") class Base(metaclass=DebugMeta): def __init__(self, *args, **kwargs): super(Base, self).__init__(*args, **kwargs) print(\"Instance initialization {0}\".format(vars(self))) def __new__(cls, *args, **kwargs): x = super(Base, cls).__new__(cls, *args, **kwargs) print(\"Creating new instance {0}\".format(x)) return x def __call__(self, *args, **kwargs): print(\"Instance called args={0} and kwargs={1}\".format(args, kwargs)) def __del__(self): print(\"Instance deleted\") config = {\"a\":1, \"b\":2} test = Base() test(1, test=2)","title":"Demo Debug"},{"location":"examples/23_meta_classes/#demo-declarative-api","text":"# https://developer.ibm.com/technologies/analytics/tutorials/ba-metaprogramming-python/ # # >>> from from django.db import models # >>> class Vehicle(models.Model): # ... color = models.CharField(max_length=10) # ... wheels = models.IntegerField() # >>> four_wheeler = Vehicle(color=\"Blue\", wheels=\"Four\") # Raises an error # >>> four_wheeler = Vehicle(color=\"Blue\", wheels=4) # >>> four_wheeler.wheels # 4 from collections import OrderedDict from six import with_metaclass class MyStore(object): \"\"\"Store keeping track of singleton instances.\"\"\" def __init__(self): self.store = {} def __str__(self): return str({key: str(value) for key, value in self.store.items()}) def register(self, name, obj): self.store[name] = obj store = MyStore() class MyField(str): pass class MyMeta(type): \"\"\" Example of metaclass demonstrating some of the classical features that such a construct can provide: class alteration and registration. \"\"\" @staticmethod def __prepare__(): return OrderedDict() def __new__(mcs, class_name, class_bases, class_attrs): # Reorganizing attributes: reorganized_attrs = OrderedDict([('_fields', OrderedDict()), ('_constants', OrderedDict())]) for name, attr in class_attrs.items(): if isinstance(attr, MyField): reorganized_attrs['_fields'][name] = attr elif not name.startswith('__') and not callable(attr): reorganized_attrs['_constants'][name] = attr else: reorganized_attrs[name] = attr # Creating the class: cls = type.__new__(mcs, class_name, class_bases, reorganized_attrs) # Initializing the singleton pattern: obj = cls() cls._obj = obj # Registering the new object: store.register(class_name, obj) # Displaying the results of the application of the metaclass: print(\"Here is what {} contains:\".format(cls.__name__)) for name, attr in cls.__dict__.items(): print(\" . {}: {}\".format(name, attr)) print(\"\") return cls def __call__(cls, *args, **kwargs): \"\"\"Implementing the singleton pattern at class call.\"\"\" if not hasattr(cls, '_obj'): obj = super(MyMeta, cls).__call__(*args, **kwargs) obj.__init__(*args, **kwargs) return obj else: return cls._obj class MyClass(with_metaclass(MyMeta)): \"\"\"Example of a user-defined (client) class that makes use of MyMeta.\"\"\" # Demo attributes (mixed fields and constants) a = 42 b = MyField('foo') c = MyField('bar') d = 'Field' in globals() def __str__(self): \"\"\"Showing the memory address of self (proving it is junior singleton).\"\"\" return \"I'm located at: {}\".format(id(self)) test_instance = MyClass() print(test_instance) other_instance = MyClass() print(\"Once again\", other_instance) print(\"The store is:\", store)","title":"Demo Declarative API"},{"location":"examples/23_meta_classes/#demo-decorator","text":"# https://cleverdevil.io/2009/python-metaclasses-demystified import inspect from six import with_metaclass class AutoDecorateMeta(type): def __init__(cls, name, bases, namespace): super(AutoDecorateMeta, cls).__init__(name, bases, namespace) deco = namespace.get('decorator', lambda f: f) for key, value in namespace.items(): # skip the decorator and constructor if key in ('decorator', '__init__'): continue # skip objects in the namespace that aren't methods if not inspect.isfunction(value): continue # apply the decorator setattr(cls, key, deco(value)) class Person(object, with_metaclass(AutoDecorateMeta)): # Decorator selector decorator = property def __init__(self, first, middle, last): self.first = first self.middle = middle self.last = last # Will be decorated def name(self): return '%s %s' % (self.first, self.last) # Will be decorated def full_name(self): return '%s %s %s' % (self.first, self.middle, self.last) # Will be decorated def initials(self): return '%s%s%s' % (self.first[0], self.middle[0], self.last[0]) mlk = Person('Martin', 'Luther', 'King') # Usual way to use name is as method # mlk.name() # Auto-decorated class converted method to property print(mlk.name) print(mlk.full_name) print(mlk.initials)","title":"Demo Decorator"},{"location":"examples/23_meta_classes/#demo-final","text":"from six import with_metaclass class Final(type): def __init__(cls, name, bases, namespace): super(Final, cls).__init__(name, bases, namespace) for klass in bases: if isinstance(klass, Final): raise TypeError(str(klass.__name__) + \" is final\") class A(object, with_metaclass(Final)): A = 1 def a(self): pass class B(A): B = 1 def b(self): pass a = A() print(a) b = B() print(b)","title":"Demo Final"},{"location":"examples/23_meta_classes/#demo-gui","text":"############################################################################## # Window # > Box # > Label ############################################################################## ############################################################################## # Imperative programming ############################################################################## class Box(object): def add(self, what): pass class Label(object): def __init__(self, label=\"\"): self.label = label def add(self): pass class Window(object): def __init__(self, title=\"Window element\"): self.title = title self.box = Box() self.add(self.box) self.label = Label(label=\"Hello, label!\") self.box.add(self.label) def add(self, what): pass ############################################################################## # Declarative programming ############################################################################## class Top(Window): title = \"Hello, window!\" class Group(Box): class Title(Label): label = '\"Hello, label!\"' ############################################################################## # Solution??? ##############################################################################","title":"Demo GUI"},{"location":"examples/23_meta_classes/#demo-indexing","text":"from six import with_metaclass ############################################################################## # Metaclass definition ############################################################################## class Indexer(type): def __init__(cls, name, bases, namespace): super(Indexer, cls).__init__(name, bases, namespace) if not hasattr(cls, \"subclasses\"): cls.subclasses = [] if not hasattr(cls, \"index\"): cls.index = 0 # Index only subclasses for b in bases: if isinstance(b, Indexer): cls.subclasses.append(1) cls.index = len(cls.subclasses) ############################################################################## # First base class and subclasses ############################################################################## class A(with_metaclass(Indexer)): pass class A1(A): pass class A2(A): pass print(A.index, A1.index, A2.index) ############################################################################## # Second base class and subclasses ############################################################################## class B(with_metaclass(Indexer)): pass class B1(B): pass class B2(B): pass print(B.index, B1.index, B2.index)","title":"Demo Indexing"},{"location":"examples/23_meta_classes/#demo-registrar","text":"from six import with_metaclass ############################################################################## # EXAMPLE 1 : Register leaf classes and count them ############################################################################## # 1. Metaclass definition class RegisterLeafClasses(type): def __init__(cls, name, bases, namespace): super(RegisterLeafClasses, cls).__init__(name, bases, namespace) if not hasattr(cls, 'registry'): cls.registry = set() cls.registry.add(cls) cls.registry -= set(bases) # Remove base classes # Class property @property def count(cls): return len(cls.registry) # Metamethods, called on class objects: def __iter__(cls): return iter(cls.registry) def __str__(cls): if cls in cls.registry: return cls.__name__ return cls.__name__ + \": \" + \", \".join([sc.__name__ for sc in cls]) # 2. Custom root class class Color(object, with_metaclass(RegisterLeafClasses)): pass # 3. Derived classes class Blue(Color): pass class Red(Color): pass class Green(Color): pass class Yellow(Color): pass print(Color) # 4. Tests class PhthaloBlue(Blue): pass class CeruleanBlue(Blue): pass print(Color) for c in Color: # Iterate over subclasses print(c) print(Color.count) ############################################################################## # EXAMPLE 2 : Example from Hilscher Framework ############################################################################## class Registrar(type): \"\"\" A meta class used to generate a list of all subclasses of a class \"\"\" def __init__(cls, name, bases, dct): super(Registrar, cls).__init__(name, bases, dct) cls.register(cls) @classmethod def list(mcs): for attrib in getattr(mcs, 'classes', tuple()): yield attrib # Metamethod used to register classes @classmethod def register(mcs, cls): try: # Create reference to classes attribute classes = mcs.classes except AttributeError: # Create classes attribute and create reference classes = mcs.classes = [] mcs.count = 0 # Use reference to populate registry classes.append(cls) class ClassToRegister1(object, with_metaclass(Registrar)): pass class ClassToRegister2(ClassToRegister1): pass a = ClassToRegister1() b = ClassToRegister2() for x in Registrar.list(): print(x)","title":"Demo Registrar"},{"location":"examples/23_meta_classes/#demo-reloading","text":"from six import with_metaclass \"\"\" Scenario : At Hilscher the test framework uses meta-classes to scan for devices with open channels. If 2 or more device classes are found, then the network creates a new class with all device classes as base classes. This leads to a problem as the order the device classes are found is not always guaranteed. Solution: Use custom device class to ensure the right methods are used for the respective device \"\"\" class ReloadMeta(type): registry = {} def __new__(mcs, class_name, bases, namespace): module_name = namespace['__module__'] try: current = mcs.registry[module_name][class_name] except KeyError: current = None if current: mcs.regenerate(current, namespace) return current cls = type.__new__(mcs, class_name, bases, namespace) mcs.registry.setdefault(module_name, {})[class_name] = cls return cls def regenerate(cls, namespace): print(\"Reloading class %s\" % cls) for name in list(cls.__dict__.keys()): if name in ['__name__', '__metaclass__', '__module__', '__dict__', '__weakref__', '__bases__']: continue delattr(cls, name) for name, value in namespace.items(): setattr(cls, name, value) return cls if __name__ == '__main__': # First class with method test class C(object, with_metaclass(ReloadMeta)): def test(self): print('first {0}'.format(self)) c = C() c.test() # Second class with new method test class C(object, with_metaclass(ReloadMeta)): def test(self): print('second {0}'.format(self)) c.test()","title":"Demo Reloading"},{"location":"examples/23_meta_classes/#demo-singleton","text":"# coding=utf-8 \"\"\" By overriding __call__() in the metaclass, the creation of instances are intercepted. Instance creation is bypassed if one already exists. Note the dependence upon the behavior of static class fields. When cls.instance is first read, it gets the static value of instance from the metaclass, which is None. However, when the assignment is made, Python creates a local version for the particular class, and the next time cls.instance is read, it sees that local version. Because of this behavior, each class ends up with its own class-specific instance field (thus instance is not somehow being \u201cinherited\u201d from the metaclass). \"\"\" class Singleton(type): instance = None def __call__(cls, *args, **kwargs): if not cls.instance: cls.instance = super(Singleton, cls).__call__(*args, **kwargs) return cls.instance class ASingleton(object, metaclass=Singleton): pass a = ASingleton() b = ASingleton() assert a is b print(a.__class__.__name__, b.__class__.__name__) print(id(a), id(b))","title":"Demo Singleton"},{"location":"examples/23_meta_classes/#demo-typed","text":"from six import with_metaclass # Create metaclass class MyMetaClass(type): def __init__(cls, name, bases, namespace): super(MyMetaClass, cls).__init__(name, bases, namespace) # Create first custom class from metaclass class A(object, with_metaclass(MyMetaClass)): A = 1 def __init__(self, param=1): self.a = param @staticmethod def configure(): print(\"A\") # Create second custom class from metaclass class B(object, with_metaclass(MyMetaClass)): B = 2 def __init__(self, param=1): self.b = param @staticmethod def configure(): print(\"B\") # Show that order of super classes determines class behavior # -> Inherits combined class attributes but instance attrib/methods from A D = MyMetaClass('D', (A, B), {}) test = D() print(vars(test)) test.configure() # -> Inherits combined class attributes but instance attrib/methods from B D = MyMetaClass('D', (B, A), {}) test = D() print(vars(test)) test.configure() # -> Solution when multiple inheritance problems (due to bad design, etc.) # Recast class type test = B(test) pass","title":"Demo Typed"},{"location":"examples/23_meta_classes/#snippets","text":"namespace = globals() abstracts = set(name for name, value in namespace.items() if getattr(value, \"__isabstractmethod__\", False)) print(abstracts)","title":"Snippets"},{"location":"examples/24_generators/","text":"Generators Counter def counter(offset): # Execution starts while True: # Execution is halted yield offset # Execution resumption with next() offset += 1 # Get the iterator object by calling the generator function gen = counter(1) # Get next element using next() as function and object method print(next(gen)) # Print the rest for x in gen: print(x) ################################################################################################## # Python 3.3+ : yield from ################################################################################################## # def gen2(): # yield from \"Python\" # yield from range(5) # # print(\"\\ng2: \", end=\", \") # g2 = gen2() # for x in g2: # print(x, end=\", \") # print() Memory Footprint import sys # Create list comprehension and print size l = [i for i in range(10)] print(\"List size is {0}\".format(sys.getsizeof(l))) # Print items for x in l: print(x) # Create generator expression and print size g = (k for k in range(10)) print(\"\") print(\"Generator expression size is {0}\".format(sys.getsizeof(g))) # Print items for x in g: print(x) Fibonacci def fibonacci_number(f0=0, f1=1, limit=1): # Initialize a, b = f0, f1 # Loop while True: yield a # Solution 01 # a, b = b, a + b # Solution 02 b = a + b a = b - a test = fibonacci_number(f0=2, f1=3) for i in range(10): print(next(test)) Delegation # def city_generator(): # cities = ['Sofia', 'Plovdiv', 'Varna', 'Burgas', 'Ruse', 'Stara Zagora', 'Pleven', 'Sliven', 'Dobrich', 'Shumen'] # for x in cities: # yield x def city_ranking(n=1): def city_generator(): cities = ['Sofia', 'Plovdiv', 'Varna', 'Burgas', 'Ruse', 'Stara Zagora', 'Pleven', 'Sliven', 'Dobrich', 'Shumen'] for x in cities: yield x g = city_generator() for x in range(n): yield next(g) for city in city_ranking(n=5): print(city) Recursive import sys import trace # Using recursion in generator function def oddnum(offset=1, limit=10): if (offset % 2) == 0: offset += 1 if offset < limit: yield offset else: return for x in range(offset + 2, limit, 2): yield next(oddnum(x, limit)) def test(): # Using for loop to print odd numbers till 10 from 1 for nums in oddnum(limit=10): print (nums) ################################################################################################## # TRACING ################################################################################################## ENABLE = 0 tracer = trace.Trace( ignoredirs=[sys.prefix, sys.exec_prefix], trace=ENABLE, count=0) # run the new command using the given tracer tracer.runfunc(test) Generator Concept # Subroutine returning a collection object def sub_even_numbers(stream): them = [] for n in stream: if n % 2 == 0: them.append(n) return them # Generator function which generates a sequence of values def gen_even_numbers(stream): for n in stream: if n % 2 == 0: yield n if __name__ == \"__main__\": # Get the even numbers using the subroutine result = sub_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9]) print(result) # Get the even numbers using the generator function result = gen_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9]) for x in result: print(x, end=\" \") Generator Delegation # Example: Generator Delegation def sub_1(): yield 1 def sub_2(): yield 2 def sub_3(): yield 3 def main_generator(): yield from sub_1() yield from sub_2() yield from sub_3() wrapper = main_generator() for x in wrapper: print(x, end=\", \") Generator Expression # Example: Generator expression num = (x for x in range(100) if x % 2 == 0) for x in num: print(x) Generator Expression Complex # Example: Complex generator expression with the the ternary operator (if-else) # Yield \"apple\" if number is even else yield \"pie\" generator = ((\"apple\" if i % 2 == 0 else \"pie\") for i in range(6)) for x in generator: print(x) Generator Expression Equivalent # Example: Generator expression equivalent def num(): for x in range(100): if x % 2 == 0: yield x num_generator = num() for x in num_generator: print(x) Generator Expression Walrus # Example: Walrus operator in a generator expression # The walrus operator (:=) assigns values to variables as part of a larger # expression. It is also known as the assignment expression and is supported # in Python 3.8 and above. It is useful for debugging, dictionary creation, # and more. gen = (x for x in range(10) if (y := x % 2) == 1) for x in gen: print(x, y) Generator Infinite # Example: Infinite sequence def infinite_sequence(): i = 0 while True: yield i i += 1 gen = infinite_sequence() # The generator is a type of iterator that implements the iterator protocol. print(next(gen)) print(next(gen)) print(next(gen)) # ... and so on Generator Nested # Example: Nested generator def inner_generator(n): for j in range(n): yield \"Inner Value {}\".format(j) def outer_generator(n): for i in range(n): yield \"Outer Value {}\".format(i) for inner_value in inner_generator(i): yield inner_value # Usage n = 3 for value in outer_generator(n): print(value) Generator Passing # Example: Generator Passing def generator(): yield 1 yield 2 yield 3 def wrapper(g): yield from g for x in wrapper(generator()): print(x, end=\", \") Generator Recursive # Example: Recursive generator for Fibonacci numbers def fibonacci(n): if n <= 0: return a, b = 0, 1 yield a # Yield the first Fibonacci number for _ in range(n - 1): a, b = b, a + b yield a # Usage n = 10 # Generate the first 10 Fibonacci numbers for number in fibonacci(n): print(number) Letter Generator def letter_generator(text): print(\"Started\") position = 0 try: while True: try: offset = yield text[position] if offset is None: position += 1 else: position = offset except ValueError: print(\"Value error on position = \" + str(position)) except GeneratorExit: print(\"Terminated\") letter = letter_generator(\"abc\") # Generate letters print(next(letter)) print(next(letter)) # Reset generator and generate letter print(letter.send(0)) # Generate a next letter print(next(letter)) # Throw an exception to the generator print(letter.throw(ValueError)) # Throw GeneratorExit to the generator letter.close()","title":"Generators"},{"location":"examples/24_generators/#generators","text":"","title":"Generators"},{"location":"examples/24_generators/#counter","text":"def counter(offset): # Execution starts while True: # Execution is halted yield offset # Execution resumption with next() offset += 1 # Get the iterator object by calling the generator function gen = counter(1) # Get next element using next() as function and object method print(next(gen)) # Print the rest for x in gen: print(x) ################################################################################################## # Python 3.3+ : yield from ################################################################################################## # def gen2(): # yield from \"Python\" # yield from range(5) # # print(\"\\ng2: \", end=\", \") # g2 = gen2() # for x in g2: # print(x, end=\", \") # print()","title":"Counter"},{"location":"examples/24_generators/#memory-footprint","text":"import sys # Create list comprehension and print size l = [i for i in range(10)] print(\"List size is {0}\".format(sys.getsizeof(l))) # Print items for x in l: print(x) # Create generator expression and print size g = (k for k in range(10)) print(\"\") print(\"Generator expression size is {0}\".format(sys.getsizeof(g))) # Print items for x in g: print(x)","title":"Memory Footprint"},{"location":"examples/24_generators/#fibonacci","text":"def fibonacci_number(f0=0, f1=1, limit=1): # Initialize a, b = f0, f1 # Loop while True: yield a # Solution 01 # a, b = b, a + b # Solution 02 b = a + b a = b - a test = fibonacci_number(f0=2, f1=3) for i in range(10): print(next(test))","title":"Fibonacci"},{"location":"examples/24_generators/#delegation","text":"# def city_generator(): # cities = ['Sofia', 'Plovdiv', 'Varna', 'Burgas', 'Ruse', 'Stara Zagora', 'Pleven', 'Sliven', 'Dobrich', 'Shumen'] # for x in cities: # yield x def city_ranking(n=1): def city_generator(): cities = ['Sofia', 'Plovdiv', 'Varna', 'Burgas', 'Ruse', 'Stara Zagora', 'Pleven', 'Sliven', 'Dobrich', 'Shumen'] for x in cities: yield x g = city_generator() for x in range(n): yield next(g) for city in city_ranking(n=5): print(city)","title":"Delegation"},{"location":"examples/24_generators/#recursive","text":"import sys import trace # Using recursion in generator function def oddnum(offset=1, limit=10): if (offset % 2) == 0: offset += 1 if offset < limit: yield offset else: return for x in range(offset + 2, limit, 2): yield next(oddnum(x, limit)) def test(): # Using for loop to print odd numbers till 10 from 1 for nums in oddnum(limit=10): print (nums) ################################################################################################## # TRACING ################################################################################################## ENABLE = 0 tracer = trace.Trace( ignoredirs=[sys.prefix, sys.exec_prefix], trace=ENABLE, count=0) # run the new command using the given tracer tracer.runfunc(test)","title":"Recursive"},{"location":"examples/24_generators/#generator-concept","text":"# Subroutine returning a collection object def sub_even_numbers(stream): them = [] for n in stream: if n % 2 == 0: them.append(n) return them # Generator function which generates a sequence of values def gen_even_numbers(stream): for n in stream: if n % 2 == 0: yield n if __name__ == \"__main__\": # Get the even numbers using the subroutine result = sub_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9]) print(result) # Get the even numbers using the generator function result = gen_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9]) for x in result: print(x, end=\" \")","title":"Generator Concept"},{"location":"examples/24_generators/#generator-delegation","text":"# Example: Generator Delegation def sub_1(): yield 1 def sub_2(): yield 2 def sub_3(): yield 3 def main_generator(): yield from sub_1() yield from sub_2() yield from sub_3() wrapper = main_generator() for x in wrapper: print(x, end=\", \")","title":"Generator Delegation"},{"location":"examples/24_generators/#generator-expression","text":"# Example: Generator expression num = (x for x in range(100) if x % 2 == 0) for x in num: print(x)","title":"Generator Expression"},{"location":"examples/24_generators/#generator-expression-complex","text":"# Example: Complex generator expression with the the ternary operator (if-else) # Yield \"apple\" if number is even else yield \"pie\" generator = ((\"apple\" if i % 2 == 0 else \"pie\") for i in range(6)) for x in generator: print(x)","title":"Generator Expression Complex"},{"location":"examples/24_generators/#generator-expression-equivalent","text":"# Example: Generator expression equivalent def num(): for x in range(100): if x % 2 == 0: yield x num_generator = num() for x in num_generator: print(x)","title":"Generator Expression Equivalent"},{"location":"examples/24_generators/#generator-expression-walrus","text":"# Example: Walrus operator in a generator expression # The walrus operator (:=) assigns values to variables as part of a larger # expression. It is also known as the assignment expression and is supported # in Python 3.8 and above. It is useful for debugging, dictionary creation, # and more. gen = (x for x in range(10) if (y := x % 2) == 1) for x in gen: print(x, y)","title":"Generator Expression Walrus"},{"location":"examples/24_generators/#generator-infinite","text":"# Example: Infinite sequence def infinite_sequence(): i = 0 while True: yield i i += 1 gen = infinite_sequence() # The generator is a type of iterator that implements the iterator protocol. print(next(gen)) print(next(gen)) print(next(gen)) # ... and so on","title":"Generator Infinite"},{"location":"examples/24_generators/#generator-nested","text":"# Example: Nested generator def inner_generator(n): for j in range(n): yield \"Inner Value {}\".format(j) def outer_generator(n): for i in range(n): yield \"Outer Value {}\".format(i) for inner_value in inner_generator(i): yield inner_value # Usage n = 3 for value in outer_generator(n): print(value)","title":"Generator Nested"},{"location":"examples/24_generators/#generator-passing","text":"# Example: Generator Passing def generator(): yield 1 yield 2 yield 3 def wrapper(g): yield from g for x in wrapper(generator()): print(x, end=\", \")","title":"Generator Passing"},{"location":"examples/24_generators/#generator-recursive","text":"# Example: Recursive generator for Fibonacci numbers def fibonacci(n): if n <= 0: return a, b = 0, 1 yield a # Yield the first Fibonacci number for _ in range(n - 1): a, b = b, a + b yield a # Usage n = 10 # Generate the first 10 Fibonacci numbers for number in fibonacci(n): print(number)","title":"Generator Recursive"},{"location":"examples/24_generators/#letter-generator","text":"def letter_generator(text): print(\"Started\") position = 0 try: while True: try: offset = yield text[position] if offset is None: position += 1 else: position = offset except ValueError: print(\"Value error on position = \" + str(position)) except GeneratorExit: print(\"Terminated\") letter = letter_generator(\"abc\") # Generate letters print(next(letter)) print(next(letter)) # Reset generator and generate letter print(letter.send(0)) # Generate a next letter print(next(letter)) # Throw an exception to the generator print(letter.throw(ValueError)) # Throw GeneratorExit to the generator letter.close()","title":"Letter Generator"},{"location":"examples/25_coroutines/","text":"Coroutines Decorate def prime(func): def start(*args, **kwargs): cr = func(*args, **kwargs) next(cr) return cr return start def source(text, target): tokens = text.split(\" \") for token in tokens: target.send(token) target.close() @prime def pattern_filter(pattern=\"ing\", target=None): print(\"Searching for {}\".format(pattern)) try: while True: token = (yield) if pattern in token: target.send(token) except GeneratorExit: print(\"Done with filtering!!\") @prime def sink(): print(\"I'm sink, i'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") sentence = \"Bob is running behind junior fast moving car\" source(text=sentence, target=pattern_filter( target=sink() ) ) Average def average(start_value=0): avg = float(start_value) counter = 1 while True: new_value = yield avg avg = avg + (new_value - avg) / counter counter += 1 test_avg = average(start_value=0) next(test_avg) assert(test_avg.send(1) == 1) assert(test_avg.send(2) == 1.5) assert(test_avg.send(3) == 2) assert(test_avg.send(4) == 2.5) assert(test_avg.send(4) == 2.8) assert(test_avg.send(4) == 3) Bytestream import random def byte_generator(limit=0, header=None): # Initialize print(\"Started\") counter = 0 # Iterator try: # Generate bytes from header if header: while counter < len(header): yield header[counter] counter += 1 # Generate random bytes after header output = random.randrange(start=0, stop=255, step=1) while counter < limit: try: yield output output = random.randrange(start=0, stop=255, step=1) counter += 1 except Exception as e: print(e) except GeneratorExit: print(\"Terminated\") stream = byte_generator(limit=10, header=[0xDE, 0xAD, 0xBE, 0xEF]) for b in stream: print(hex(b)) Pipeline def producer(string, next_coroutine): tokens = string.split(\" \") for token in tokens: next_coroutine.send(token) next_coroutine.close() def pattern_filter(pattern=\"ing\", next_coroutine=None): print(\"Searching for {}\".format(pattern)) try: while True: token = (yield) if pattern in token: next_coroutine.send(token) except GeneratorExit: print(\"Done with filtering!!\") def consumer(): print(\"I'm sink, i'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") # Define token printer (sink) and activate printer = consumer() next(printer) # Define token filterer (middle) and activate filterer = pattern_filter(next_coroutine=printer) next(filterer) # Define token splitter (producer) sentence = \"Bob is running behind junior fast moving car\" producer(string=sentence, next_coroutine=filterer) Fsm # https://www.codementor.io/@arpitbhayani/building-finite-state-machines-with-python-coroutines-15nk03eh9l class RegexFSM(object): # Evaluate regex in the form ab*c using FSM implemented with state machines def __init__(self): # Start FSM self.current_state = None self.output = False ############################################################################################## def __call__(self, *args, **kwargs): return self.match(*args, **kwargs) ############################################################################################## def send(self, char): try: self.current_state.send(char) except StopIteration: self.output = False ############################################################################################## def match(self, text): # Create state self.current_state = self.start() # Activate state next(self.current_state) # Read input and generate output try: # Read character and send it to the current state for char in text: # Current state reacts to input and makes transition to junior new state self.current_state.send(char) # Activate the new state next(self.current_state) except StopIteration: self.output = False finally: return self.output ############################################################################################## def start(self): self.output = False while True: char = yield if char == 'junior': self.current_state = self.q1() else: break ############################################################################################## def q1(self): self.output = False while True: char = yield if char == 'b': self.current_state = self.q2() elif char == 'c': self.current_state = self.q3() else: break ############################################################################################## def q2(self): self.output = False while True: char = yield if char == 'b': self.current_state = self.q2() elif char == 'c': self.current_state = self.q3() else: break ############################################################################################## def q3(self): self.output = True while True: char = yield if char: self.output = False else: break ############################################################################################## def stop(self): self.current_state.close() if __name__ == \"__main__\": evaluator = RegexFSM() print(evaluator.match(\"abc\")) print(evaluator.match(\"ab\")) print(evaluator.match(\"ac\")) print(evaluator.match(\"bc\")) print(evaluator(\"abc\")) print(evaluator(\"abcd\")) Recursion from __future__ import print_function # from itertools import cycle, permutations def permutations(items): n = len(items) if n == 0: yield [] else: for i in range(len(items)): # We have to use next() to activate the recursive generator for cc in permutations(items[:i] + items[i + 1:]): yield [items[i]] + cc text = \"abc\" for i in permutations(text): print(i) Coroutine Chaining # Example: Coroutine Chaining def producer(string, next_coroutine): tokens = string.split(\" \") for token in tokens: next_coroutine.send(token) next_coroutine.close() def consumer(): print(\"I'm the sink, I'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") sentence = \"Hello, world!\" print(sentence) # Define token printer (consumer) and activate printer = consumer() next(printer) # Define token splitter (producer) producer(string=sentence, next_coroutine=printer) # Output # --------------------------- # Hello, world! # I'm the sink, i'll print tokens # Hello # world! # Done with printing! Coroutine Execution # Example: Coroutine Execution def coroutine(): print(\"Coroutine has been started!\") output = \"foo\" while True: text = yield output print(\"Coroutine input :\", text) output = text[::-1] if text else \"boo\" cr = coroutine() # First usage of next to activate the coroutine and generate junior default value print(\"Coroutine \u043eutput : {0}\".format(next(cr))) # Second usage of next to generate junior new value print(\"Coroutine \u043eutput : {0}\".format(next(cr))) # Send data to the coroutine and generate junior new value print(\"Coroutine \u043eutput : {0}\".format(cr.send(\"abc\"))) # Output: # ------------------------------- # 1. Coroutine has been started! # 2. Coroutine \u043eutput : foo # 3. ('Coroutine received :', None) # 4. Coroutine \u043eutput : boo # 5. ('Coroutine received :', 'abc') # 6. Coroutine \u043eutput : cba Coroutine Interface # Example: Coroutine Interface def letter_generator(text): print(\"Started\") position = 0 try: while True: try: offset = yield text[position] if offset is None: position += 1 else: position = offset except ValueError: print(\"Value error on position = \" + str(position)) except GeneratorExit: print(\"Terminated\") letter = letter_generator(\"abc\") # Generate letters print(next(letter)) print(next(letter)) # Reset generator and generate letter print(letter.send(0)) # Generate next letter print(next(letter)) # Throw an exception to the generator print(letter.throw(ValueError)) # Throw GeneratorExit to the generator letter.close() # Output # ---------------------- # Started # junior # b # junior # b # Value error on position = 1 # b # Terminated","title":"Coroutines"},{"location":"examples/25_coroutines/#coroutines","text":"","title":"Coroutines"},{"location":"examples/25_coroutines/#decorate","text":"def prime(func): def start(*args, **kwargs): cr = func(*args, **kwargs) next(cr) return cr return start def source(text, target): tokens = text.split(\" \") for token in tokens: target.send(token) target.close() @prime def pattern_filter(pattern=\"ing\", target=None): print(\"Searching for {}\".format(pattern)) try: while True: token = (yield) if pattern in token: target.send(token) except GeneratorExit: print(\"Done with filtering!!\") @prime def sink(): print(\"I'm sink, i'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") sentence = \"Bob is running behind junior fast moving car\" source(text=sentence, target=pattern_filter( target=sink() ) )","title":"Decorate"},{"location":"examples/25_coroutines/#average","text":"def average(start_value=0): avg = float(start_value) counter = 1 while True: new_value = yield avg avg = avg + (new_value - avg) / counter counter += 1 test_avg = average(start_value=0) next(test_avg) assert(test_avg.send(1) == 1) assert(test_avg.send(2) == 1.5) assert(test_avg.send(3) == 2) assert(test_avg.send(4) == 2.5) assert(test_avg.send(4) == 2.8) assert(test_avg.send(4) == 3)","title":"Average"},{"location":"examples/25_coroutines/#bytestream","text":"import random def byte_generator(limit=0, header=None): # Initialize print(\"Started\") counter = 0 # Iterator try: # Generate bytes from header if header: while counter < len(header): yield header[counter] counter += 1 # Generate random bytes after header output = random.randrange(start=0, stop=255, step=1) while counter < limit: try: yield output output = random.randrange(start=0, stop=255, step=1) counter += 1 except Exception as e: print(e) except GeneratorExit: print(\"Terminated\") stream = byte_generator(limit=10, header=[0xDE, 0xAD, 0xBE, 0xEF]) for b in stream: print(hex(b))","title":"Bytestream"},{"location":"examples/25_coroutines/#pipeline","text":"def producer(string, next_coroutine): tokens = string.split(\" \") for token in tokens: next_coroutine.send(token) next_coroutine.close() def pattern_filter(pattern=\"ing\", next_coroutine=None): print(\"Searching for {}\".format(pattern)) try: while True: token = (yield) if pattern in token: next_coroutine.send(token) except GeneratorExit: print(\"Done with filtering!!\") def consumer(): print(\"I'm sink, i'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") # Define token printer (sink) and activate printer = consumer() next(printer) # Define token filterer (middle) and activate filterer = pattern_filter(next_coroutine=printer) next(filterer) # Define token splitter (producer) sentence = \"Bob is running behind junior fast moving car\" producer(string=sentence, next_coroutine=filterer)","title":"Pipeline"},{"location":"examples/25_coroutines/#fsm","text":"# https://www.codementor.io/@arpitbhayani/building-finite-state-machines-with-python-coroutines-15nk03eh9l class RegexFSM(object): # Evaluate regex in the form ab*c using FSM implemented with state machines def __init__(self): # Start FSM self.current_state = None self.output = False ############################################################################################## def __call__(self, *args, **kwargs): return self.match(*args, **kwargs) ############################################################################################## def send(self, char): try: self.current_state.send(char) except StopIteration: self.output = False ############################################################################################## def match(self, text): # Create state self.current_state = self.start() # Activate state next(self.current_state) # Read input and generate output try: # Read character and send it to the current state for char in text: # Current state reacts to input and makes transition to junior new state self.current_state.send(char) # Activate the new state next(self.current_state) except StopIteration: self.output = False finally: return self.output ############################################################################################## def start(self): self.output = False while True: char = yield if char == 'junior': self.current_state = self.q1() else: break ############################################################################################## def q1(self): self.output = False while True: char = yield if char == 'b': self.current_state = self.q2() elif char == 'c': self.current_state = self.q3() else: break ############################################################################################## def q2(self): self.output = False while True: char = yield if char == 'b': self.current_state = self.q2() elif char == 'c': self.current_state = self.q3() else: break ############################################################################################## def q3(self): self.output = True while True: char = yield if char: self.output = False else: break ############################################################################################## def stop(self): self.current_state.close() if __name__ == \"__main__\": evaluator = RegexFSM() print(evaluator.match(\"abc\")) print(evaluator.match(\"ab\")) print(evaluator.match(\"ac\")) print(evaluator.match(\"bc\")) print(evaluator(\"abc\")) print(evaluator(\"abcd\"))","title":"Fsm"},{"location":"examples/25_coroutines/#recursion","text":"from __future__ import print_function # from itertools import cycle, permutations def permutations(items): n = len(items) if n == 0: yield [] else: for i in range(len(items)): # We have to use next() to activate the recursive generator for cc in permutations(items[:i] + items[i + 1:]): yield [items[i]] + cc text = \"abc\" for i in permutations(text): print(i)","title":"Recursion"},{"location":"examples/25_coroutines/#coroutine-chaining","text":"# Example: Coroutine Chaining def producer(string, next_coroutine): tokens = string.split(\" \") for token in tokens: next_coroutine.send(token) next_coroutine.close() def consumer(): print(\"I'm the sink, I'll print tokens\") try: while True: token = (yield) print(token) except GeneratorExit: print(\"Done with printing!\") sentence = \"Hello, world!\" print(sentence) # Define token printer (consumer) and activate printer = consumer() next(printer) # Define token splitter (producer) producer(string=sentence, next_coroutine=printer) # Output # --------------------------- # Hello, world! # I'm the sink, i'll print tokens # Hello # world! # Done with printing!","title":"Coroutine Chaining"},{"location":"examples/25_coroutines/#coroutine-execution","text":"# Example: Coroutine Execution def coroutine(): print(\"Coroutine has been started!\") output = \"foo\" while True: text = yield output print(\"Coroutine input :\", text) output = text[::-1] if text else \"boo\" cr = coroutine() # First usage of next to activate the coroutine and generate junior default value print(\"Coroutine \u043eutput : {0}\".format(next(cr))) # Second usage of next to generate junior new value print(\"Coroutine \u043eutput : {0}\".format(next(cr))) # Send data to the coroutine and generate junior new value print(\"Coroutine \u043eutput : {0}\".format(cr.send(\"abc\"))) # Output: # ------------------------------- # 1. Coroutine has been started! # 2. Coroutine \u043eutput : foo # 3. ('Coroutine received :', None) # 4. Coroutine \u043eutput : boo # 5. ('Coroutine received :', 'abc') # 6. Coroutine \u043eutput : cba","title":"Coroutine Execution"},{"location":"examples/25_coroutines/#coroutine-interface","text":"# Example: Coroutine Interface def letter_generator(text): print(\"Started\") position = 0 try: while True: try: offset = yield text[position] if offset is None: position += 1 else: position = offset except ValueError: print(\"Value error on position = \" + str(position)) except GeneratorExit: print(\"Terminated\") letter = letter_generator(\"abc\") # Generate letters print(next(letter)) print(next(letter)) # Reset generator and generate letter print(letter.send(0)) # Generate next letter print(next(letter)) # Throw an exception to the generator print(letter.throw(ValueError)) # Throw GeneratorExit to the generator letter.close() # Output # ---------------------- # Started # junior # b # junior # b # Value error on position = 1 # b # Terminated","title":"Coroutine Interface"},{"location":"examples/28_optimization/","text":"Optimization Function Caching Loop Fusion # Original code with two separate loops import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): array_a = [i for i in range(iterations)] array_b = [i * 2 for i in range(iterations)] sum_a = 0 i = 0 while i < iterations: sum_a += array_a[i] i += 1 sum_b = 0 j = 0 while j < iterations: sum_b += array_b[j] j += 1 return sum_a, sum_b @stats(num_samples=SAMPLES) def optimized_loop(iterations): array_a = [i for i in range(iterations)] array_b = [i * 2 for i in range(iterations)] sum_a = 0 sum_b = 0 i = 0 while i < iterations: sum_a += array_a[i] sum_b += array_b[i] i += 1 return sum_a, sum_b t1 = unoptimized_loop(ITERATIONS) print('Output of unoptimized loop: ', t1, '\\n') t2 = optimized_loop(ITERATIONS) print('Output of optimized loop: ', t2, '\\n') Loop With Invariant Code # Example: Loop Optimization with by moving invariant code out of the loop import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): # Sums and multiplies by 2 num = 1 result = 0 while num < iterations: num += 1 result = num * 2 return result @stats(num_samples=SAMPLES) def optimized_loop(iterations): # Uses the fact that (1*2 + 2*2 + 3*2 + ... + n*2) = 2 * (1 + 2 + 3 + ... + n) num = 1 factor = 2 while num < iterations: num += 1 return num * factor t1 = unoptimized_loop(ITERATIONS) print('-> Output:', t1) t2 = optimized_loop(ITERATIONS) print('-> Output:', t2) Loop With List Comprehension # Example: Loop Optimization with List Comprehension import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] for i in range(num_samples): start = time.time() func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def squares_for_loop(iterations): squares = [] num = 0 while num < iterations: squares.append(num ** 2) num += 1 return squares @stats(num_samples=SAMPLES) def squares_list_comprehension(iterations): squares = [num ** 2 for num in range(1, iterations)] return squares squares_for_loop(ITERATIONS) squares_list_comprehension(ITERATIONS) Loop With Unrolling # Original loop import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): steps = 0 result = 0 for _ in range(0, iterations, 1): steps += 1 result += 1 return result @stats(num_samples=SAMPLES) def optimized_loop(iterations): steps = 0 result = 0 for _ in range(0, iterations, 2): steps += 1 result += 1 result += 1 return result t1 = unoptimized_loop(ITERATIONS) print('Output of unoptimized_loop: ', t1, '\\n') t2 = optimized_loop(ITERATIONS) print('Output of optimized_loop: ', t2, '\\n') Peephole Constant Folding # Example: Peephole Optimization - Constant Folding def unoptimized_const(): # Simulates the creation of unoptimized constants # Short strings a = \"Hello\" a = a + a + a # Tuples b = (1, 2) b = b * 3 # Expressions c = 60 c = c * 5 return a, b, c def peephole_const(): # Python optimizes strings up to 4096 characters and tuples of length up to 256 elements # Varite the length of the string and tuple to see the difference. # Short strings a = \"Hello\" * 3 # Tuples b = (1, 2) * 3 # Expressions c = 60 * 60 return a, b, c print(unoptimized_const.__code__.co_consts) # (None, 'Hello', 1, 2, 5, (10, 20, 30), 7) print(peephole_const.__code__.co_consts) # (None, 604800, 'HelloHelloHello', (1, 2, 1, 2, 1, 2)) Peephole Constant Propagation \"\"\" Example: Peephole Optimization - Constant Propagation Replace variables with their values if they are constant. This is done at compile time. It seems that this 08-optimization is not implemented. \"\"\" def unoptimized(): a = 1 b = 2 * a return b def peepholed(): return 2 print(unoptimized.__code__.co_consts) # (None, 1, 2) print(peepholed.__code__.co_consts) # (None, 2) Peephole Membership # Example: Peephole Optimization - Membership Test def unoptimized_membership(name): # Simulates the creation an unoptimized membership test names = list() names.append(\"John\") names.append(\"Doe\") names.append(\"Jane\") names.append(\"Smith\") if name in names: pass def peephole_membership(name): # Membership tests are optimized for lists and sets if name in [\"John\", \"Doe\", \"Jane\", \"Smith\"]: pass print(unoptimized_membership.__code__.co_consts) # (None, 'John', 'Doe', 'Jane', 'Smith') print(peephole_membership.__code__.co_consts) # (None, ('John', 'Doe', 'Jane', 'Smith'), 'Is junior member') String Interning # Example: String Interning import sys # Create two string literals with the same content str1 = \"hello\" str2 = \"hello\" # Check if str1 and str2 reference the same object (identity check) print(\"> Creating two string literals with the same content\") print(\"# {} is {}: {}\\n\".format(str1, str2, str1 is str2)) # Create junior non-literal strings with the same content str3 = \"\" str3 += \"h\" str3 += \"e\" str3 += \"l\" str3 += \"l\" str3 += \"o\" # Check if str1 and str2 reference the same object (identity check) print(\"> Create junior non-literal string with the same content\") print(\"# {} is {}: {}\\n\".format(str1, str3, str1 is str3)) # Intern the string referenced by str3 str3 = sys.intern(str3) # Check if str1 and str3 reference the same object (identity check) print(\"> Intern the non-literal string\") print(\"# {} is {}: {}\\n\".format(str1, str3, str1 is str3)) Use Arrays Use Comprehension Use Jit Compilers","title":"Optimization"},{"location":"examples/28_optimization/#optimization","text":"","title":"Optimization"},{"location":"examples/28_optimization/#function-caching","text":"","title":"Function Caching"},{"location":"examples/28_optimization/#loop-fusion","text":"# Original code with two separate loops import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): array_a = [i for i in range(iterations)] array_b = [i * 2 for i in range(iterations)] sum_a = 0 i = 0 while i < iterations: sum_a += array_a[i] i += 1 sum_b = 0 j = 0 while j < iterations: sum_b += array_b[j] j += 1 return sum_a, sum_b @stats(num_samples=SAMPLES) def optimized_loop(iterations): array_a = [i for i in range(iterations)] array_b = [i * 2 for i in range(iterations)] sum_a = 0 sum_b = 0 i = 0 while i < iterations: sum_a += array_a[i] sum_b += array_b[i] i += 1 return sum_a, sum_b t1 = unoptimized_loop(ITERATIONS) print('Output of unoptimized loop: ', t1, '\\n') t2 = optimized_loop(ITERATIONS) print('Output of optimized loop: ', t2, '\\n')","title":"Loop Fusion"},{"location":"examples/28_optimization/#loop-with-invariant-code","text":"# Example: Loop Optimization with by moving invariant code out of the loop import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): # Sums and multiplies by 2 num = 1 result = 0 while num < iterations: num += 1 result = num * 2 return result @stats(num_samples=SAMPLES) def optimized_loop(iterations): # Uses the fact that (1*2 + 2*2 + 3*2 + ... + n*2) = 2 * (1 + 2 + 3 + ... + n) num = 1 factor = 2 while num < iterations: num += 1 return num * factor t1 = unoptimized_loop(ITERATIONS) print('-> Output:', t1) t2 = optimized_loop(ITERATIONS) print('-> Output:', t2)","title":"Loop With Invariant Code"},{"location":"examples/28_optimization/#loop-with-list-comprehension","text":"# Example: Loop Optimization with List Comprehension import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] for i in range(num_samples): start = time.time() func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def squares_for_loop(iterations): squares = [] num = 0 while num < iterations: squares.append(num ** 2) num += 1 return squares @stats(num_samples=SAMPLES) def squares_list_comprehension(iterations): squares = [num ** 2 for num in range(1, iterations)] return squares squares_for_loop(ITERATIONS) squares_list_comprehension(ITERATIONS)","title":"Loop With List Comprehension"},{"location":"examples/28_optimization/#loop-with-unrolling","text":"# Original loop import time, numpy def stats(num_samples): def decorator(func): def wrapper(*args, **kwargs): print(\"=\" * 80) print(\"Timings in seconds:\", func.__name__) print(\"=\" * 80) func.stats = [] calc = 0 for i in range(num_samples): start = time.time() calc = func(*args, **kwargs) end = time.time() func.stats.append(end - start) # print(\"Sample {} / Time taken: {}\".format(i, end - start)) print(\"Samples :\", len(func.stats)) print(\"Mean :\", numpy.mean(func.stats)) print(\"Stdev :\", numpy.std(func.stats)) print(\"Min :\", min(func.stats)) print(\"Max :\", max(func.stats)) return calc return wrapper return decorator SAMPLES = 10 ITERATIONS = int(1e6) @stats(num_samples=SAMPLES) def unoptimized_loop(iterations): steps = 0 result = 0 for _ in range(0, iterations, 1): steps += 1 result += 1 return result @stats(num_samples=SAMPLES) def optimized_loop(iterations): steps = 0 result = 0 for _ in range(0, iterations, 2): steps += 1 result += 1 result += 1 return result t1 = unoptimized_loop(ITERATIONS) print('Output of unoptimized_loop: ', t1, '\\n') t2 = optimized_loop(ITERATIONS) print('Output of optimized_loop: ', t2, '\\n')","title":"Loop With Unrolling"},{"location":"examples/28_optimization/#peephole-constant-folding","text":"# Example: Peephole Optimization - Constant Folding def unoptimized_const(): # Simulates the creation of unoptimized constants # Short strings a = \"Hello\" a = a + a + a # Tuples b = (1, 2) b = b * 3 # Expressions c = 60 c = c * 5 return a, b, c def peephole_const(): # Python optimizes strings up to 4096 characters and tuples of length up to 256 elements # Varite the length of the string and tuple to see the difference. # Short strings a = \"Hello\" * 3 # Tuples b = (1, 2) * 3 # Expressions c = 60 * 60 return a, b, c print(unoptimized_const.__code__.co_consts) # (None, 'Hello', 1, 2, 5, (10, 20, 30), 7) print(peephole_const.__code__.co_consts) # (None, 604800, 'HelloHelloHello', (1, 2, 1, 2, 1, 2))","title":"Peephole Constant Folding"},{"location":"examples/28_optimization/#peephole-constant-propagation","text":"\"\"\" Example: Peephole Optimization - Constant Propagation Replace variables with their values if they are constant. This is done at compile time. It seems that this 08-optimization is not implemented. \"\"\" def unoptimized(): a = 1 b = 2 * a return b def peepholed(): return 2 print(unoptimized.__code__.co_consts) # (None, 1, 2) print(peepholed.__code__.co_consts) # (None, 2)","title":"Peephole Constant Propagation"},{"location":"examples/28_optimization/#peephole-membership","text":"# Example: Peephole Optimization - Membership Test def unoptimized_membership(name): # Simulates the creation an unoptimized membership test names = list() names.append(\"John\") names.append(\"Doe\") names.append(\"Jane\") names.append(\"Smith\") if name in names: pass def peephole_membership(name): # Membership tests are optimized for lists and sets if name in [\"John\", \"Doe\", \"Jane\", \"Smith\"]: pass print(unoptimized_membership.__code__.co_consts) # (None, 'John', 'Doe', 'Jane', 'Smith') print(peephole_membership.__code__.co_consts) # (None, ('John', 'Doe', 'Jane', 'Smith'), 'Is junior member')","title":"Peephole Membership"},{"location":"examples/28_optimization/#string-interning","text":"# Example: String Interning import sys # Create two string literals with the same content str1 = \"hello\" str2 = \"hello\" # Check if str1 and str2 reference the same object (identity check) print(\"> Creating two string literals with the same content\") print(\"# {} is {}: {}\\n\".format(str1, str2, str1 is str2)) # Create junior non-literal strings with the same content str3 = \"\" str3 += \"h\" str3 += \"e\" str3 += \"l\" str3 += \"l\" str3 += \"o\" # Check if str1 and str2 reference the same object (identity check) print(\"> Create junior non-literal string with the same content\") print(\"# {} is {}: {}\\n\".format(str1, str3, str1 is str3)) # Intern the string referenced by str3 str3 = sys.intern(str3) # Check if str1 and str3 reference the same object (identity check) print(\"> Intern the non-literal string\") print(\"# {} is {}: {}\\n\".format(str1, str3, str1 is str3))","title":"String Interning"},{"location":"examples/28_optimization/#use-arrays","text":"","title":"Use Arrays"},{"location":"examples/28_optimization/#use-comprehension","text":"","title":"Use Comprehension"},{"location":"examples/28_optimization/#use-jit-compilers","text":"","title":"Use Jit Compilers"},{"location":"examples/29_packaging/","text":"Packaging Import Namespace Package import namespace_pkg print(namespace_pkg.__path__) from namespace_pkg.core import plugin print(plugin.__path__)","title":"Packaging"},{"location":"examples/29_packaging/#packaging","text":"","title":"Packaging"},{"location":"examples/29_packaging/#import-namespace-package","text":"import namespace_pkg print(namespace_pkg.__path__) from namespace_pkg.core import plugin print(plugin.__path__)","title":"Import Namespace Package"},{"location":"examples/30_compatibility/","text":"Compatibility Compatibility Future # Example: __future__ module # Most commonly used imports from the __future__ module from __future__ import print_function from __future__ import unicode_literals from __future__ import division print \"hello world\" # Shall indicate an error if the future import is not present Compatibility Six # Example: six module # The most commonly used imports from the six module from six.moves import input # Import the input function from the six.moves module from six import with_metaclass # Import the with_metaclass function from the six module class Meta(type): def __new__(cls, name, bases, dct): print(\"Allocating memory for class\", name) return super(Meta, cls).__new__(cls, name, bases, dct) def __init__(cls, name, bases, dct): print(\"Initializing class\", name) super(Meta, cls).__init__(name, bases, dct) class Base(with_metaclass(Meta)): def __init__(self): print(\"Initializing instance\", self) super(Base, self).__init__() class Derived(Base): def __init__(self): print(\"Initializing instance\", self) super(Derived, self).__init__() if __name__ == \"__main__\": # Use the six.moves.input function with Python 2 and 3 input(\"Press Enter to continue...\") # Use the six.with_metaclass function with Python 2 and 3 print(\"Creating instance of Base\") b = Base() print(\"Creating instance of Derived\") d = Derived() print(\"Finished\")","title":"Compatibility"},{"location":"examples/30_compatibility/#compatibility","text":"","title":"Compatibility"},{"location":"examples/30_compatibility/#compatibility-future","text":"# Example: __future__ module # Most commonly used imports from the __future__ module from __future__ import print_function from __future__ import unicode_literals from __future__ import division print \"hello world\" # Shall indicate an error if the future import is not present","title":"Compatibility Future"},{"location":"examples/30_compatibility/#compatibility-six","text":"# Example: six module # The most commonly used imports from the six module from six.moves import input # Import the input function from the six.moves module from six import with_metaclass # Import the with_metaclass function from the six module class Meta(type): def __new__(cls, name, bases, dct): print(\"Allocating memory for class\", name) return super(Meta, cls).__new__(cls, name, bases, dct) def __init__(cls, name, bases, dct): print(\"Initializing class\", name) super(Meta, cls).__init__(name, bases, dct) class Base(with_metaclass(Meta)): def __init__(self): print(\"Initializing instance\", self) super(Base, self).__init__() class Derived(Base): def __init__(self): print(\"Initializing instance\", self) super(Derived, self).__init__() if __name__ == \"__main__\": # Use the six.moves.input function with Python 2 and 3 input(\"Press Enter to continue...\") # Use the six.with_metaclass function with Python 2 and 3 print(\"Creating instance of Base\") b = Base() print(\"Creating instance of Derived\") d = Derived() print(\"Finished\")","title":"Compatibility Six"},{"location":"project/","text":"Python by Example Documentation Welcome to the documentation for Python by Example . This site contains a collection of examples demonstrating many facets of the Python programming language. Browse the example files or use the navigation to jump to a specific topic.","title":"Python by Example Documentation"},{"location":"project/#python-by-example-documentation","text":"Welcome to the documentation for Python by Example . This site contains a collection of examples demonstrating many facets of the Python programming language. Browse the example files or use the navigation to jump to a specific topic.","title":"Python by Example Documentation"}]}