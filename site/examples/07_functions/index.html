<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Functions - Python by Example</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Functions";
        var mkdocs_page_input_path = "examples\\07_functions.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Python by Example
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Examples</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../01_hello_world/">Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02_variables/">Variables</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_comments/">Comments</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04_operators/">Operators</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_user_input/">User Input</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_control_flow/">Control Flow</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Functions</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#func-annotations">Func Annotations</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-attributes">Func Attributes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-attributes-decorator">Func Attributes Decorator</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-callback">Func Callback</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-closures">Func Closures</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-decorator">Func Decorator</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-decorator-with-args">Func Decorator With Args</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-default-arguments">Func Default Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-factory">Func Factory</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-introspection">Func Introspection</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-keyword-arguments">Func Keyword Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-keyword-only-arguments">Func Keyword Only Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-arguments">Func Lambda Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-assignment">Func Lambda Assignment</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-bytecodes">Func Lambda Bytecodes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-conditional">Func Lambda Conditional</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-nested-conditions">Func Lambda Nested Conditions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-recursive">Func Lambda Recursive</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-lambda-syntax">Func Lambda Syntax</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-memoization">Func Memoization</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-nested">Func Nested</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-positional-arguments">Func Positional Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-positional-only-arguments">Func Positional Only Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-recursion">Func Recursion</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-scope">Func Scope</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-structure">Func Structure</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-unpacking-arguments">Func Unpacking Arguments</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-variable-arguments-python2">Func Variable Arguments Python2</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#func-variable-arguments-python3">Func Variable Arguments Python3</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../08_classes/">Classes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../09_docstrings/">Docstrings</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../10_debugging/">Debugging</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../11_oop_pillars/">OOP Pillars</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../12_solid_principles/">SOLID Principles</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_logging/">Logging</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../14_exceptions/">Exceptions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../15_dunder_methods/">Dunder Methods</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../16_data_types/">Data Types</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../17_import_system/">Import System</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../18_linting_tools/">Linting Tools</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../19_test_frameworks/">Test Frameworks</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../20_package_managers/">Package Managers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../21_design_patterns/">Design Patterns</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../23_meta_classes/">Meta Classes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../24_generators/">Generators</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../25_coroutines/">Coroutines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../28_optimization/">Optimization</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../29_packaging/">Packaging</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../30_compatibility/">Compatibility</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Project</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../project/">Python by Example Documentation</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Python by Example</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Examples</li>
      <li class="breadcrumb-item active">Functions</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/braboj/tutorial-python/edit/master/docs/examples/07_functions.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="functions">Functions</h1>
<h2 id="func-annotations">Func Annotations</h2>
<pre><code class="language-python"># Function annotations for parameters and return values
# --------------------------------------------------------------------------------
# Annotations in Python functions allow you to specify the expected types of
# parameters and the return type of the function. This can help with code
# readability and static type checking.
#
# There are no strict rules enforced by Python regarding these annotations,
# but they serve as a guide for developers and can be used by tools like
# type checkers, IDEs, and documentation generators.

def add(x: int, y: int) -&gt; int:
    return x + y
</code></pre>
<h2 id="func-attributes">Func Attributes</h2>
<pre><code class="language-python"># Adding attributes to functions
# --------------------------------------------------------------------------------
# Functions in Python are first-class objects, which means they can have
# attributes just like any other object. Attributes are accessed using
# the dot notation (e.g. `foo.name`), and can be used to store metadata
# about the function, such as its name, description, or author.

def foo():
    pass


foo.name = &quot;MyFunc&quot;
foo.description = &quot;This is my function&quot;
foo.author = &quot;Me&quot;

print(foo.author)
# Output: Me

print(foo.name)
# Output: MyFunc

print(foo.description)
# This is my function
</code></pre>
<h2 id="func-attributes-decorator">Func Attributes Decorator</h2>
<pre><code class="language-python"># Adding attributes to functions using decorators
# --------------------------------------------------------------------------------
# Sometimes you may want to add metadata to a function, such as an author
# name or version without modifying the function's code directly. A good way
# to do this is by using a decorator. Decorators are functions that modify
# the behavior of another function. In this case, we can create a decorator
# that adds an attribute to the function it decorates.

def owned(func):
    func.author = &quot;Branimir Georgiev&quot;
    return func


@owned
def hello():
    pass


print(hello.author)
# Output: Branimir Georgiev
</code></pre>
<h2 id="func-callback">Func Callback</h2>
<pre><code class="language-python"># Using callback functions to handle events
# --------------------------------------------------------------------------------
# A callback function is passed as an argument to another function and executed
# when a particular event occurs. This technique lets the caller customize
# behavior without changing the callee. Callbacks are common in event-driven
# architectures and asynchronous code.

_listeners = {}

def on(event_name, callback):
    _listeners.setdefault(event_name, []).append(callback)


def emit(event_name, *args, **kwargs):
    for callback in _listeners.get(event_name, []):
        callback(*args, **kwargs)


def handle_data(data):
    print(f&quot;[DATA] Received: {data!r}&quot;)


def handle_error(msg):
    print(f&quot;[ERROR] {msg}&quot;)


on(&quot;data&quot;, handle_data)
on(&quot;error&quot;, handle_error)

emit(&quot;data&quot;, {&quot;id&quot;: 1, &quot;value&quot;: 42})
emit(&quot;data&quot;, {&quot;id&quot;: 2, &quot;value&quot;: 99})
emit(&quot;error&quot;, &quot;Timeout occurred&quot;)
</code></pre>
<h2 id="func-closures">Func Closures</h2>
<pre><code class="language-python"># Closures in Python
# --------------------------------------------------------------------------------
# A closure in Python is a function object that “remembers” values from its
# enclosing scope even when that scope has finished execution. In other
# words, a closure lets you bind variables from an outer function into an
# inner function, and keep using them later.

def greet(message):
    def inner_function(name):
        return &quot;{} {}&quot;.format(message, name)
    return inner_function


welcome = greet(&quot;Welcome&quot;)
print(welcome('Branko'))
# Output: Welcome Branko

print(greet('Hello')('Branko'))
# Output: Hello Branko
</code></pre>
<h2 id="func-decorator">Func Decorator</h2>
<pre><code class="language-python"># Decorators to modify or extend function behavior
# --------------------------------------------------------------------------------
# A decorator is a function that takes another function as an argument,
# modifies or extends its behavior, and returns a new function. They are
# related to closures, as they can access variables from the enclosing scope.

def decorate(func):
    &quot;&quot;&quot;A simple decorator function.&quot;&quot;&quot;

    def wrapper(*args, **kwargs):
        &quot;&quot;&quot;Wrapper function with additional behavior.&quot;&quot;&quot;

        result = func(*args, **kwargs)
        print(f&quot;Function '{func.__name__}' called with {args} and {kwargs}&quot;)
        return result

    return wrapper

@decorate
def hello_world():
    print('Hello world')

hello_world()

def hello_python():
    print('Hello Python')

hello_python = decorate(hello_python)
hello_python()
</code></pre>
<h2 id="func-decorator-with-args">Func Decorator With Args</h2>
<pre><code class="language-python"># Parameterized decorators in Python
# --------------------------------------------------------------------------------
# Unfortunately, Python does not support passing parameters to decorators
# directly. A decorator of a function has always one argument, which is the
# original function to be decorated.
#
# In order to pass parameters to a decorator, we need to create an enclosing
# function that takes the decorator parameters and returns a decorator
# function.
#
# The decorator function will then take the original function as an argument
# and return a wrapper function modifying the behavior of the original function.

def log(message=&quot;Operation&quot;):
    def decorator(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)
            print(f&quot;{message}: {func.__name__} called with args: {args}&quot;)
            return result
        return wrapper
    return decorator

@log()
def add(a, b):
    return a + b

@log(&quot;Custom log&quot;)
def sub(a, b):
    return a - b

def div(a, b):
    return a / b

add(5, 3)
# Output: Operation: add called with args: (5, 3)

sub(10, 4)
# Output: Custom log: sub called with args: (10, 4)

div = log(&quot;Division operation&quot;)(div)
div(10, 2)
# Output: Division operation: div called with args: (10, 2)
</code></pre>
<h2 id="func-default-arguments">Func Default Arguments</h2>
<pre><code class="language-python"># Default arguments in functions
# --------------------------------------------------------------------------------
# Functions may define default values for parameters so callers can omit those
# arguments. This simplifies the call site and allows optional behavior.
# Remember that default expressions are evaluated when the function is defined.

def greet(name='Nemo', age=42):
    print(&quot;Hello, {0}! You are {1} years old.&quot;.format(name, age))


greet()
# Output: Hello, Nemo! You are 42 years old.
</code></pre>
<h2 id="func-factory">Func Factory</h2>
<pre><code class="language-python"># Function factories to create specialized functions
# --------------------------------------------------------------------------------
# A function factory returns a new function tailored to the argument it
# receives. It enables creation of many small functions without repeating code.
# Each generated function captures the parameters provided to the factory.

def power_of(n):
    def power(x):
        return x ** n

    return power


# Square root
sqrt = power_of(0.5)
print(sqrt(100.0))

# Square
sqr = power_of(2)
print(sqr(10.0))
</code></pre>
<h2 id="func-introspection">Func Introspection</h2>
<pre><code class="language-python"># Inspect function attributes
# --------------------------------------------------------------------------------
# Python stores a variety of metadata about functions on the function object
# itself. Attributes such as ``__name__``, ``__doc__`` and ``__code__`` can be
# inspected at runtime to learn more about a function's definition. This
# introspection ability is useful for debugging and for frameworks that
# manipulate functions.

def foo(a, b=10, c=20, *args, **kwargs):
    &quot;&quot;&quot;This is 'foo' function that does nothing.&quot;&quot;&quot;

    pi = 3.14

    def bar(a=1, b=2, c=3, *args, **kwargs):
        &quot;&quot;&quot;This is 'bar' function that does nothing.&quot;&quot;&quot;

        print(pi)

        introspections = {
            '__globals__': bar.__globals__,
            '__name__': bar.__name__,
            '__doc__': bar.__doc__,
            '__code__': bar.__code__,
            '__defaults__': bar.__defaults__,
            '__closure__': bar.__closure__,
            '__dict__': bar.__dict__,
        }

        # A function has a name
        test = introspections['__name__']
        print(&quot;Getting function attribute __name__ -&gt; {} &quot;.format(test))

        # A function has a docstring
        test = introspections['__doc__']
        print(&quot;Getting function attribute __doc__ -&gt; {} &quot;.format(test))

        # A function has default arguments
        test = introspections['__defaults__']
        print(&quot;Getting function attribute __defaults__ -&gt; {} &quot;.format(test))

        # A function has access to the global namespace
        test = introspections['__globals__']
        print(&quot;Getting function attribute __globals__ -&gt; {} &quot;.format(test))

        # A function has a closure
        test = introspections['__closure__']
        print(&quot;Getting function attribute __closure__ -&gt; {} &quot;.format(test))

        # A function has a variables dictionary
        test = introspections['__dict__']
        print(&quot;Getting function attribute __dict__ -&gt; {} &quot;.format(test))

        # A function has a code object
        test = introspections['__code__']
        print(&quot;Getting function attribute __code__ -&gt; {} &quot;.format(test))

        # A code object has name
        print(test.co_name)

    bar()


# foo(1, 2, 3, 4, 5, c=30, d=40, e=50)
foo(a=1, d=40, e=50)
</code></pre>
<h2 id="func-keyword-arguments">Func Keyword Arguments</h2>
<pre><code class="language-python"># Calling functions with keyword arguments
# --------------------------------------------------------------------------------
# When a function call includes parameter names, the order of those arguments no
# longer matters. Keyword arguments make the call site clearer and allow some
# parameters to be skipped if they have defaults. They also pair well with
# functions that accept many optional settings.

def greet(name, age):
    print(&quot;Hello, {0}! You are {1} years old.&quot;.format(name, age))


# Calling the greet() function with named arguments
greet(name=&quot;Alice&quot;, age=25)
</code></pre>
<h2 id="func-keyword-only-arguments">Func Keyword Only Arguments</h2>
<pre><code class="language-python"># Keyword-only arguments
# --------------------------------------------------------------------------------
# Keyword-only parameters must be specified by name in the call. This avoids
# ambiguity and makes the purpose of each argument clear. It is particularly
# helpful when a function accepts many optional parameters.

# The arguments a and b are keyword-only
def keyword_only_arguments(*, a, b):
    return a + b


# The argument a is positional or keyword, b is keyword-only
def one_keyword_only_argument(a, *, b):
    return a + b


# The argument a is positional only, b is keyword-only
def separate_arguments(a, /, *, b):
    return a + b
</code></pre>
<h2 id="func-lambda-arguments">Func Lambda Arguments</h2>
<pre><code class="language-python"># Lambda functions with multiple arguments
# --------------------------------------------------------------------------------
# A lambda expression can accept several parameters just like a regular
# function. It is useful for short, inline operations where defining a full
# function would be excessive. Here we compute a simple expression using five
# arguments.

# Multi-parameter lambda
x = lambda a, b, c, d, e: (a + b) * (c + d) / e
print(x(1, 2, 3, 4, 5))
</code></pre>
<h2 id="func-lambda-assignment">Func Lambda Assignment</h2>
<pre><code class="language-python"># Assigning a lambda expression to a variable
# --------------------------------------------------------------------------------
# Lambda expressions can be assigned to variables to create small, unnamed
# functions on the fly. Doing so lets you reuse the lambda just like a regular
# function object. This pattern is handy for callbacks or short computations.

nop = lambda: None
print(nop())
</code></pre>
<h2 id="func-lambda-bytecodes">Func Lambda Bytecodes</h2>
<pre><code class="language-python"># Lambda and def produce the same bytecode
# --------------------------------------------------------------------------------
# This script compiles a lambda expression and a regular function to compare
# their bytecode output. Both forms compile into nearly identical instructions.
# Using ``lambda`` therefore carries no extra runtime cost compared to ``def``.

import dis

func1 = lambda x: x * x


def func2(x):
    return x * x


print(dis.dis(func1))
print(dis.dis(func2))
</code></pre>
<h2 id="func-lambda-conditional">Func Lambda Conditional</h2>
<pre><code class="language-python"># Conditional lambda
# --------------------------------------------------------------------------------
# A lambda can contain a conditional expression to produce different values
# based on its input. This one returns ``1`` when the argument is positive and
# ``0`` otherwise. Such compact expressions are useful for simple
# transformations.
y = lambda b: 1 if b &gt; 0 else 0
print(y(-1), y(0), y(1))
</code></pre>
<h2 id="func-lambda-nested-conditions">Func Lambda Nested Conditions</h2>
<pre><code class="language-python"># Lambda function with nested conditionals
# --------------------------------------------------------------------------------
# This lambda expression checks two ranges using nested conditional operators.
# It returns ``1`` when the argument exceeds 10 or falls below -10 and ``0`` in
# all other cases. The expression remains concise despite the multiple branches.
z = lambda c: 1 if c &gt; 10 else (1 if c &lt; -10 else 0)
print(-11, -10, -1, 0, 1, 10, 11, sep='\t')
print(z(-11), z(-10), z(-1), z(0), z(1), z(10), z(11), sep='\t')
</code></pre>
<h2 id="func-lambda-recursive">Func Lambda Recursive</h2>
<pre><code class="language-python"># Lambda function with recursion
# --------------------------------------------------------------------------------
# Although lambdas are typically simple, they can also be used recursively.
# The expression here computes factorial by calling itself for successive
# decrements. Assigning the lambda to a variable is required so it can
# reference itself.

x = lambda a: a * x(a - 1) if a &gt; 1 else 1
print(x(5))
</code></pre>
<h2 id="func-lambda-syntax">Func Lambda Syntax</h2>
<pre><code class="language-python"># Lambda functions
# --------------------------------------------------------------------------------
# Lambda expressions provide a compact way to create anonymous functions.
# They consist of a parameter list, a colon and a single expression that becomes
# the return value. Because they are limited to one expression, lambdas are best
# suited for small operations.

&quot;&quot;&quot;
lambda [param1, param2, ..]: expression

Lambda functions are one-line functions which return an expression using
the pre-defined parameters param1, param2, ... paramN.

Lambda functions are normally used for quick operations on data,
most notably in combination with map, filter, reduce.

&quot;&quot;&quot;

# Define a list to iterate over
data_in = [1, 2, 3]

# Use a lambda function to square the input and then map the result to a list `data_out`
data_out = list(map(lambda x: x * x, data_in))

# Print the result
print(data_in, data_out)
</code></pre>
<h2 id="func-memoization">Func Memoization</h2>
<pre><code class="language-python"># Memoization with an inner function that caches results
# --------------------------------------------------------------------------------
# The inner ``memoized_fibonacci`` function stores each computed Fibonacci
# number in the ``cache`` dictionary. On subsequent calls with the same
# argument, the cached value is returned instead of recalculating it. This
# avoids redundant work and illustrates the principle of memoization.

# Explicit memoization using a dictionary
def fibonacci(n):
    cache = {}

    def memoized_fibonacci(n):
        if n in cache:
            return cache[n]
        if n &lt;= 1:
            result = n
        else:
            result = memoized_fibonacci(n - 1) + memoized_fibonacci(n - 2)
        cache[n] = result
        return result

    return memoized_fibonacci(n)


print(fibonacci(5))
print(fibonacci(10))


# Memoization using a decorator (the internal cache is a dictionary)
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(5))
print(fib(10))
</code></pre>
<h2 id="func-nested">Func Nested</h2>
<pre><code class="language-python"># Nested functions and their access to enclosing variables
# --------------------------------------------------------------------------------
# Inner functions can access variables from the outer function that defines
# them. This ability creates a closure which preserves the environment even
# after the outer function has finished executing. It allows the inner function
# to operate using data that would otherwise be out of scope.

def absolute_value(x):
    # Emulate the built-in abs() function, e.g. abs(-1) == 1 and abs(1) == 1

    def negative_value():
        # An inner function can access the variables of the outer function

        return -x

    def positive_value():
        # An inner function can also access the variables of the outer function

        return x

    # Use the inner functions to return the correct value
    return negative_value() if x &lt; 0 else positive_value()


print(absolute_value(-1))  # 1
print(absolute_value(1))  # 1
</code></pre>
<h2 id="func-positional-arguments">Func Positional Arguments</h2>
<pre><code class="language-python"># Using positional arguments
# --------------------------------------------------------------------------------
# Each value is matched to a parameter based on where it appears, so the order
# of the provided arguments matters. Positional parameters correspond directly
# to the order defined in the function signature. Mixing up the order can lead
# to incorrect results or errors.

def greet(name, age):
    print(&quot;Hello, {0}! You are {1} years old.&quot;.format(name, age))


# Calling the greet() function with positional arguments
greet(&quot;Alice&quot;, 25)
</code></pre>
<h2 id="func-positional-only-arguments">Func Positional Only Arguments</h2>
<pre><code class="language-python"># Positional-only arguments
# --------------------------------------------------------------------------------
# Some parameters can be declared positional-only so they cannot be passed by
# name. This keeps the API minimal and prevents accidental clashes with keyword
# arguments. The syntax uses a ``/`` in the parameter list to mark the end of
# positional-only parameters.

# The arguments a and b are positional-only
def positional_only_arguments(a, b, /):
    return a + b


# The argument a is positional-only, b is positional or keyword
def one_positional_only_argument(a, /, b):
    return a + b
</code></pre>
<h2 id="func-recursion">Func Recursion</h2>
<pre><code class="language-python"># Recursive functions in Python
# --------------------------------------------------------------------------------
# A recursive function repeatedly calls itself with a simpler version of the
# original problem. Each call works toward a base case that stops the recursion.
# This technique is often used for tasks that can be defined in terms of similar
# subproblems.

def factorial(n):
    # Base case
    if n == 0:
        return 1

    # Recursive case
    else:
        return n * factorial(n - 1)


test_function = factorial(5)
print(test_function)
</code></pre>
<h2 id="func-scope">Func Scope</h2>
<pre><code class="language-python"># Understanding variable scope in Python
# --------------------------------------------------------------------------------
# There are two types of variable scope in Python: global and local. If a
# local variable has the same name as a global variable, the local variable
# will take precedence within the function.
#
# If the function needs to use the global variable, it must declare it as
# global using the `global` keyword.
#
# !!! WARNING !!!
# Modifying a global variable inside a function can lead to unexpected behavior
# and should be done with caution. A good practice is to avoid the use of
# global variables altogether, unless absolutely necessary.

var = 1
print(var)


# Output: 1

# Local variable with the same name
def func_local_var():
    # Redefine the variable within the function scope
    var = 2
    print(var)


func_local_var()
print(var)


# Output: 1

def func_using_global_var():
    # Declare that we want to use the global variable
    global var
    var = 3
    print(var)


func_using_global_var()
</code></pre>
<h2 id="func-structure">Func Structure</h2>
<pre><code class="language-python"># Anatomy of a Python function
# --------------------------------------------------------------------------------
# A function definition begins with the ``def`` keyword followed by its name and
# parameters. The body can perform operations using those parameters and return
# a value. Well-documented functions include a docstring that briefly states
# their purpose.

def function_name(parameter1, parameter2):
    &quot;&quot;&quot; Docstring: description of the function &quot;&quot;&quot;

    # Code to be executed when the function is called
    result = parameter1 + parameter2
    print(result)

    # Return statement (optional)
    return result
</code></pre>
<h2 id="func-unpacking-arguments">Func Unpacking Arguments</h2>
<pre><code class="language-python"># Argument unpacking with `*args`
# --------------------------------------------------------------------------------
# When calling a function, the star operator can expand an iterable into
# positional arguments. This allows you to store the arguments in a list or
# other iterable and pass them all at once.

def my_function(a, b, c):
    print(a, b, c)


args = [1, 2, 3]
my_function(*args)
</code></pre>
<h2 id="func-variable-arguments-python2">Func Variable Arguments Python2</h2>
<pre><code class="language-python"># Handling a variable number of arguments in Python 2
# --------------------------------------------------------------------------------
# This code captures extra positional arguments with ``*args`` and extra
# keyword arguments with ``**kwargs`` when keyword-only parameters are
# unavailable. In Python 3 you can declare keyword-only parameters using the
# ``*`` separator instead of relying on ``**kwargs``. See
# ``func_variable_arguments_python3.py`` for comparison.

def variable_number_of_arguments(a, b, *args, **kwargs):
    print(&quot;a: {a}&quot;.format(a=a))
    print(&quot;b: {b}&quot;.format(b=b))
    print(&quot;args: {args}&quot;.format(args=args))
    print(&quot;kwargs: {kwargs}&quot;.format(kwargs=kwargs))


variable_number_of_arguments(1, 2, 3, c=4)
</code></pre>
<h2 id="func-variable-arguments-python3">Func Variable Arguments Python3</h2>
<pre><code class="language-python"># Mixing positional arguments with keyword-only arguments
# --------------------------------------------------------------------------------
# Python 3 lets you combine regular positional parameters with ``*args`` and
# keyword-only parameters that have default values. The `*` separator defines
# that the positional parameters until a key-value pair is encountered.

def variable_number_of_arguments(a, *args, b=1, **kwargs):
    print(f&quot;a: {a}&quot;)
    print(f&quot;b: {b}&quot;)
    print(f&quot;args: {args}&quot;)
    print(f&quot;kwargs: {kwargs}&quot;)


variable_number_of_arguments(1, 2, 3, c=4)
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../06_control_flow/" class="btn btn-neutral float-left" title="Control Flow"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../08_classes/" class="btn btn-neutral float-right" title="Classes">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/braboj/tutorial-python" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../06_control_flow/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../08_classes/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
